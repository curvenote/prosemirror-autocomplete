/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/rope-sequence/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

var ropeSequence = RopeSequence;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ropeSequence);


/***/ }),

/***/ "./demo/reducer.ts":
/*!*************************!*\
  !*** ./demo/reducer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reducer = void 0;
const src_1 = __webpack_require__(/*! ../src */ "./src/index.ts");
const actions_1 = __webpack_require__(/*! ../src/actions */ "./src/actions.ts");
const suggestion = document.querySelector('#suggestion');
const info = document.querySelector('#info');
const picker = {
    view: null,
    open: false,
    current: 0,
    range: null,
};
const NUM_SUGGESTIONS = suggestion.children.length;
function setInfo(action) {
    var _a;
    info.innerText = `Action: ${action.kind}, Range: ${action.range.from}-${action.range.to}, Filter: ${action.filter}, Trigger: ${action.trigger}, Type: ${(_a = action.type) === null || _a === void 0 ? void 0 : _a.name}`;
}
function placeSuggestion() {
    var _a;
    suggestion.style.display = picker.open ? 'block' : 'none';
    const rect = (_a = document.getElementsByClassName('autocomplete')[0]) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
    if (!rect)
        return;
    suggestion.style.top = `${rect.top + rect.height}px`;
    suggestion.style.left = `${rect.left}px`;
    [].forEach.call(suggestion.children, (item, i) => {
        item.classList[i === picker.current ? 'add' : 'remove']('selected');
    });
}
function reducer(action) {
    var _a;
    picker.view = action.view;
    setInfo(action);
    switch (action.kind) {
        case src_1.ActionKind.open:
            picker.current = 0;
            picker.open = true;
            picker.range = action.range;
            placeSuggestion();
            return true;
        case src_1.ActionKind.close:
            picker.open = false;
            placeSuggestion();
            return true;
        case src_1.ActionKind.up:
            picker.current -= 1;
            picker.current += NUM_SUGGESTIONS; // negative modulus doesn't work
            picker.current %= NUM_SUGGESTIONS;
            placeSuggestion();
            return true;
        case src_1.ActionKind.down:
            picker.current += 1;
            picker.current %= NUM_SUGGESTIONS;
            placeSuggestion();
            return true;
        case src_1.ActionKind.enter: {
            const tr = action.view.state.tr
                .deleteRange(action.range.from, action.range.to)
                .insertText(`You can define this ${action.type ? `${(_a = action.type) === null || _a === void 0 ? void 0 : _a.name} ` : ''}action!`);
            action.view.dispatch(tr);
            return true;
        }
        default:
            return false;
    }
}
exports.reducer = reducer;
[].forEach.call(suggestion.children, (item, i) => {
    item.addEventListener('click', () => {
        if (!picker.view)
            return;
        (0, actions_1.closeAutocomplete)(picker.view);
        picker.open = false;
        placeSuggestion();
        if (!picker.range)
            return;
        const tr = picker.view.state.tr
            .deleteRange(picker.range.from, picker.range.to)
            .insertText(`Clicked on ${i + 1}`);
        picker.view.dispatch(tr);
        picker.view.focus();
    });
});


/***/ }),

/***/ "./src/actions.ts":
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.closeAutocomplete = exports.openAutocomplete = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function openAutocomplete(view, trigger, filter) {
    // TODO: Can activate a type?
    const plugin = utils_1.pluginKey.get(view.state);
    const meta = { action: 'add', trigger, filter, type: null };
    const tr = view.state.tr
        .insertText(`${trigger}${filter !== null && filter !== void 0 ? filter : ''}`)
        .scrollIntoView()
        .setMeta(plugin, meta);
    view.dispatch(tr);
}
exports.openAutocomplete = openAutocomplete;
function closeAutocomplete(view) {
    const plugin = utils_1.pluginKey.get(view.state);
    const meta = { action: 'remove' };
    const tr = view.state.tr.setMeta(plugin, meta);
    view.dispatch(tr);
    return true;
}
exports.closeAutocomplete = closeAutocomplete;


/***/ }),

/***/ "./src/decoration.ts":
/*!***************************!*\
  !*** ./src/decoration.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDecorationPlugin = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const inactiveAutocompleteState = {
    active: false,
    decorations: prosemirror_view_1.DecorationSet.empty,
};
function actionFromEvent(event) {
    switch (event.key) {
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowLeft':
        case 'ArrowRight':
            return event.key;
        case 'Tab':
        case 'Enter':
            return types_1.ActionKind.enter;
        case 'Escape':
            return types_1.ActionKind.close;
        default:
            return null;
    }
}
function cancelIfInsideAndPass(view) {
    const plugin = utils_1.pluginKey.get(view.state);
    const { decorations } = plugin.getState(view.state);
    if ((0, utils_1.inSuggestion)(view.state.selection, decorations)) {
        (0, actions_1.closeAutocomplete)(view);
    }
    return false;
}
function getDecorationPlugin(reducer) {
    const plugin = new prosemirror_state_1.Plugin({
        key: utils_1.pluginKey,
        view() {
            return {
                update: (view, prevState) => {
                    var _a, _b, _c, _d;
                    const prev = plugin.getState(prevState);
                    const next = plugin.getState(view.state);
                    const started = !prev.active && next.active;
                    const stopped = prev.active && !next.active;
                    const changed = next.active && !started && !stopped && prev.filter !== next.filter;
                    const action = {
                        view,
                        trigger: (_a = next.trigger) !== null && _a !== void 0 ? _a : prev.trigger,
                        filter: (_b = next.filter) !== null && _b !== void 0 ? _b : prev.filter,
                        range: (_c = next.range) !== null && _c !== void 0 ? _c : prev.range,
                        type: (_d = next.type) !== null && _d !== void 0 ? _d : prev.type,
                    };
                    if (started)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.open }));
                    if (changed)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.filter }));
                    if (stopped)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.close }));
                },
            };
        },
        state: {
            init: () => inactiveAutocompleteState,
            apply(tr, state) {
                var _a, _b, _c;
                const meta = tr.getMeta(plugin);
                if ((meta === null || meta === void 0 ? void 0 : meta.action) === 'add') {
                    const { trigger, filter, type } = meta;
                    const from = tr.selection.from - trigger.length - ((_a = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a !== void 0 ? _a : 0);
                    const to = tr.selection.from;
                    const className = ((_b = type === null || type === void 0 ? void 0 : type.decorationAttrs) === null || _b === void 0 ? void 0 : _b.class)
                        ? ['autocomplete', (_c = type === null || type === void 0 ? void 0 : type.decorationAttrs) === null || _c === void 0 ? void 0 : _c.class].join(' ')
                        : 'autocomplete';
                    const attrs = Object.assign(Object.assign({}, type === null || type === void 0 ? void 0 : type.decorationAttrs), { class: className });
                    const deco = prosemirror_view_1.Decoration.inline(from, to, attrs, {
                        inclusiveStart: false,
                        inclusiveEnd: true,
                    });
                    return {
                        active: true,
                        trigger: meta.trigger,
                        decorations: prosemirror_view_1.DecorationSet.create(tr.doc, [deco]),
                        filter: filter !== null && filter !== void 0 ? filter : '',
                        range: { from, to },
                        type,
                    };
                }
                const { decorations } = state;
                const nextDecorations = decorations.map(tr.mapping, tr.doc);
                const hasDecoration = nextDecorations.find().length > 0;
                // If no decoration, explicitly remove, or click somewhere else in the editor
                if ((meta === null || meta === void 0 ? void 0 : meta.action) === 'remove' ||
                    !(0, utils_1.inSuggestion)(tr.selection, nextDecorations) ||
                    !hasDecoration)
                    return inactiveAutocompleteState;
                const { active, trigger, type } = state;
                // Ensure that the trigger is in the decoration
                const { from, to } = nextDecorations.find()[0];
                const text = tr.doc.textBetween(from, to);
                if (!text.startsWith(trigger))
                    return inactiveAutocompleteState;
                return {
                    active,
                    trigger,
                    decorations: nextDecorations,
                    filter: text.slice(trigger.length),
                    range: { from, to },
                    type,
                };
            },
        },
        props: {
            decorations: (state) => { var _a; return (_a = plugin.getState(state)) === null || _a === void 0 ? void 0 : _a.decorations; },
            handlePaste: (view) => cancelIfInsideAndPass(view),
            handleDrop: (view) => cancelIfInsideAndPass(view),
            handleKeyDown(view, event) {
                var _a, _b;
                const { trigger, active, decorations, type } = plugin.getState(view.state);
                if (!active || !(0, utils_1.inSuggestion)(view.state.selection, decorations))
                    return false;
                const { from, to } = decorations.find()[0];
                const text = view.state.doc.textBetween(from, to);
                // Be defensive, just in case the trigger doesn't exist
                const filter = text.slice((_a = trigger === null || trigger === void 0 ? void 0 : trigger.length) !== null && _a !== void 0 ? _a : 1);
                const checkCancelOnSpace = (_b = type === null || type === void 0 ? void 0 : type.cancelOnFirstSpace) !== null && _b !== void 0 ? _b : true;
                if (checkCancelOnSpace &&
                    filter.length === 0 &&
                    (event.key === ' ' || event.key === 'Spacebar')) {
                    (0, actions_1.closeAutocomplete)(view);
                    // Take over the space creation so no other input rules are fired
                    view.dispatch(view.state.tr.insertText(' ').scrollIntoView());
                    return true;
                }
                if (filter.length === 0 && event.key === 'Backspace') {
                    (0, prosemirror_inputrules_1.undoInputRule)(view.state, view.dispatch);
                    (0, actions_1.closeAutocomplete)(view);
                    return true;
                }
                const kind = actionFromEvent(event);
                const action = {
                    view,
                    trigger,
                    filter,
                    range: { from, to },
                    type,
                };
                switch (kind) {
                    case types_1.ActionKind.close:
                        // The user action will be handled in the view code above
                        // Allows clicking off to be handled in the same way
                        return (0, actions_1.closeAutocomplete)(view);
                    case types_1.ActionKind.enter: {
                        // Only trigger the cancel if it is not expliticly handled in the select
                        const result = reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.enter }));
                        if (result === types_1.KEEP_OPEN)
                            return true;
                        return result || (0, actions_1.closeAutocomplete)(view);
                    }
                    case types_1.ActionKind.up:
                    case types_1.ActionKind.down:
                        return Boolean(reducer(Object.assign(Object.assign({}, action), { kind })));
                    case types_1.ActionKind.left:
                    case types_1.ActionKind.right:
                        if (!(type === null || type === void 0 ? void 0 : type.allArrowKeys))
                            return false;
                        return Boolean(reducer(Object.assign(Object.assign({}, action), { kind })));
                    default:
                        break;
                }
                return false;
            },
        },
    });
    return plugin;
}
exports.getDecorationPlugin = getDecorationPlugin;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const plugin_1 = __webpack_require__(/*! ./plugin */ "./src/plugin.ts");
__exportStar(__webpack_require__(/*! ./types */ "./src/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils */ "./src/utils.ts"), exports);
__exportStar(__webpack_require__(/*! ./plugin */ "./src/plugin.ts"), exports);
__exportStar(__webpack_require__(/*! ./actions */ "./src/actions.ts"), exports);
exports["default"] = plugin_1.autocomplete;


/***/ }),

/***/ "./src/inputRules.ts":
/*!***************************!*\
  !*** ./src/inputRules.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInputRule = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function createInputRule(plugin, type) {
    const trigger = typeof type.trigger === 'string'
        ? RegExp(`(?:^|\\s|\\n|[^\\d\\w])(${type.trigger.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})$`)
        : type.trigger;
    return new prosemirror_inputrules_1.InputRule(trigger, (state, match) => {
        const { decorations } = plugin.getState(state);
        // If we are currently suggesting, don't activate
        if ((0, utils_1.inSuggestion)(state.selection, decorations))
            return null;
        // We are taking over the text input here
        const tr = state.tr.insertText(match[1][match[1].length - 1]).scrollIntoView();
        const meta = { action: 'add', trigger: match[1], type };
        tr.setMeta(plugin, meta);
        return tr;
    });
}
exports.createInputRule = createInputRule;


/***/ }),

/***/ "./src/plugin.ts":
/*!***********************!*\
  !*** ./src/plugin.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autocomplete = exports.defaultReducer = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const decoration_1 = __webpack_require__(/*! ./decoration */ "./src/decoration.ts");
const inputRules_1 = __webpack_require__(/*! ./inputRules */ "./src/inputRules.ts");
function defaultReducer(options) {
    return (action) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        switch (action.kind) {
            case types_1.ActionKind.open:
                return (_b = (_a = options.onOpen) === null || _a === void 0 ? void 0 : _a.call(options, action)) !== null && _b !== void 0 ? _b : false;
            case types_1.ActionKind.close:
                return (_d = (_c = options.onClose) === null || _c === void 0 ? void 0 : _c.call(options, action)) !== null && _d !== void 0 ? _d : false;
            case types_1.ActionKind.up:
            case types_1.ActionKind.down:
            case types_1.ActionKind.left:
            case types_1.ActionKind.right:
                return (_f = (_e = options.onArrow) === null || _e === void 0 ? void 0 : _e.call(options, action)) !== null && _f !== void 0 ? _f : false;
            case types_1.ActionKind.filter:
                return (_h = (_g = options.onFilter) === null || _g === void 0 ? void 0 : _g.call(options, action)) !== null && _h !== void 0 ? _h : false;
            case types_1.ActionKind.enter:
                return (_k = (_j = options.onEnter) === null || _j === void 0 ? void 0 : _j.call(options, action)) !== null && _k !== void 0 ? _k : false;
            default:
                return false;
        }
    };
}
exports.defaultReducer = defaultReducer;
function autocomplete(opts = {}) {
    const options = Object.assign({ triggers: [], reducer: defaultReducer(opts) }, opts);
    const { reducer, triggers } = options;
    const plugin = (0, decoration_1.getDecorationPlugin)(reducer);
    const rules = [
        plugin,
        (0, prosemirror_inputrules_1.inputRules)({
            // Create an input rule for each trigger
            rules: triggers.map((type) => (0, inputRules_1.createInputRule)(plugin, type)),
        }),
    ];
    return rules;
}
exports.autocomplete = autocomplete;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionKind = exports.KEEP_OPEN = void 0;
exports.KEEP_OPEN = 'KEEP_OPEN';
var ActionKind;
(function (ActionKind) {
    ActionKind["open"] = "open";
    ActionKind["close"] = "close";
    ActionKind["filter"] = "filter";
    ActionKind["up"] = "ArrowUp";
    ActionKind["down"] = "ArrowDown";
    ActionKind["left"] = "ArrowLeft";
    ActionKind["right"] = "ArrowRight";
    ActionKind["enter"] = "enter";
})(ActionKind = exports.ActionKind || (exports.ActionKind = {}));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inSuggestion = exports.pluginKey = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
exports.pluginKey = new prosemirror_state_1.PluginKey('autocomplete');
function inSuggestion(selection, decorations) {
    return decorations.find(selection.from, selection.to).length > 0;
}
exports.inSuggestion = inSuggestion;


/***/ }),

/***/ "./node_modules/crelt/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/crelt/dist/index.cjs ***!
  \*******************************************/
/***/ ((module) => {



function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);
      else if (value != null) elt[name] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt, arguments[i]);
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) ; else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}

module.exports = crelt;


/***/ }),

/***/ "./node_modules/orderedmap/dist/index.cjs":
/*!************************************************!*\
  !*** ./node_modules/orderedmap/dist/index.cjs ***!
  \************************************************/
/***/ ((module) => {



// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

module.exports = OrderedMap;


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var deleteSelection = function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};

var joinBackward = function joinBackward(state, dispatch, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) return false;
  var $cut = findCutBefore($cursor);

  if (!$cut) {
    var range = $cursor.blockRange(),
        target = range && prosemirrorTransform.liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  var before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirrorState.NodeSelection.isSelectable(before))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }

  return false;
};

function textblockAt(node, side) {
  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock) return true;
    if (only && scan.childCount != 1) return false;
  }

  return false;
}

var selectNodeBackward = function selectNodeBackward(state, dispatch, view) {
  var _state$selection = state.selection,
      $head = _state$selection.$head,
      empty = _state$selection.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) return false;
    $cut = findCutBefore($head);
  }

  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
    if ($pos.node(i).type.spec.isolating) break;
  }
  return null;
}

var joinForward = function joinForward(state, dispatch, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) return false;
  var $cut = findCutAfter($cursor);
  if (!$cut) return false;
  var after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirrorState.NodeSelection.isSelectable(after))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }

  return false;
};

var selectNodeForward = function selectNodeForward(state, dispatch, view) {
  var _state$selection2 = state.selection,
      $head = _state$selection2.$head,
      empty = _state$selection2.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) return false;
    $cut = findCutAfter($head);
  }

  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));
    if (parent.type.spec.isolating) break;
  }
  return null;
}

var joinUp = function joinUp(state, dispatch) {
  var sel = state.selection,
      nodeSel = sel instanceof prosemirrorState.NodeSelection,
      point;

  if (nodeSel) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) return false;
    point = sel.from;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);
    if (point == null) return false;
  }

  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var joinDown = function joinDown(state, dispatch) {
  var sel = state.selection,
      point;

  if (sel instanceof prosemirrorState.NodeSelection) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) return false;
    point = sel.to;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);
    if (point == null) return false;
  }

  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
  return true;
};

var lift = function lift(state, dispatch) {
  var _state$selection3 = state.selection,
      $from = _state$selection3.$from,
      $to = _state$selection3.$to;
  var range = $from.blockRange($to),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

var newlineInCode = function newlineInCode(state, dispatch) {
  var _state$selection4 = state.selection,
      $head = _state$selection4.$head,
      $anchor = _state$selection4.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var _match$edge = match.edge(i),
        type = _match$edge.type;

    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }

  return null;
}

var exitCode = function exitCode(state, dispatch) {
  var _state$selection5 = state.selection,
      $head = _state$selection5.$head,
      $anchor = _state$selection5.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  var above = $head.node(-1),
      after = $head.indexAfter(-1),
      type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type)) return false;

  if (dispatch) {
    var pos = $head.after(),
        tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var createParagraphNear = function createParagraphNear(state, dispatch) {
  var sel = state.selection,
      $from = sel.$from,
      $to = sel.$to;
  if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) return false;

  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var liftEmptyBlock = function liftEmptyBlock(state, dispatch) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || $cursor.parent.content.size) return false;

  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();

    if (prosemirrorTransform.canSplit(state.doc, before)) {
      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }

  var range = $cursor.blockRange(),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

var splitBlock = function splitBlock(state, dispatch) {
  var _state$selection6 = state.selection,
      $from = _state$selection6.$from,
      $to = _state$selection6.$to;

  if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) return false;
    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
    return true;
  }

  if (!$from.parent.isBlock) return false;

  if (dispatch) {
    var atEnd = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd && deflt ? [{
      type: deflt
    }] : undefined;
    var can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);

    if (!types && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
      type: deflt
    }] : undefined)) {
      if (deflt) types = [{
        type: deflt
      }];
      can = true;
    }

    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);

      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()),
            $first = tr.doc.resolve(first);
        if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
      }
    }

    dispatch(tr.scrollIntoView());
  }

  return true;
};

var splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && function (tr) {
    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) tr.ensureMarks(marks);
    dispatch(tr);
  });
};

var selectParentNode = function selectParentNode(state, dispatch) {
  var _state$selection7 = state.selection,
      $from = _state$selection7.$from,
      to = _state$selection7.to,
      pos;
  var same = $from.sharedDepth(to);
  if (same == 0) return false;
  pos = $from.before(same);
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));
  return true;
};

var selectAll = function selectAll(state, dispatch) {
  if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));
  return true;
};

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore,
      after = $pos.nodeAfter,
      index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) return false;

  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) dispatch(state.tr["delete"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }

  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) return false;
  if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
      after = $cut.nodeAfter,
      conn,
      match;
  if (before.type.spec.isolating || after.type.spec.isolating) return false;
  if (joinMaybeClear(state, $cut, dispatch)) return true;
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);

  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize,
          wrap = prosemirrorModel.Fragment.empty;

      for (var i = conn.length - 1; i >= 0; i--) {
        wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));
      }

      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if (prosemirrorTransform.canJoin(tr.doc, joinAt)) tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }

    return true;
  }

  var selAfter = prosemirrorState.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
      target = range && prosemirrorTransform.liftTarget(range);

  if (target != null && target >= $cut.depth) {
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before,
        _wrap = [];

    for (;;) {
      _wrap.push(at);

      if (at.isTextblock) break;
      at = at.lastChild;
    }

    var afterText = after,
        afterDepth = 1;

    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }

    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var _end = prosemirrorModel.Fragment.empty;

        for (var _i = _wrap.length - 1; _i >= 0; _i--) {
          _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));
        }

        var _tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));

        dispatch(_tr.scrollIntoView());
      }

      return true;
    }
  }

  return false;
}

function selectTextblockSide(side) {
  return function (state, dispatch) {
    var sel = state.selection,
        $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;

    while ($pos.node(depth).isInline) {
      if (!depth) return false;
      depth--;
    }

    if (!$pos.node(depth).isTextblock) return false;
    if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}

var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);

function wrapIn(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection8 = state.selection,
        $from = _state$selection8.$from,
        $to = _state$selection8.$to;
    var range = $from.blockRange($to),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return false;
    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}

function setBlockType(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection9 = state.selection,
        from = _state$selection9.from,
        to = _state$selection9.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (applicable) return false;
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;

      if (node.type == nodeType) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos),
            index = $pos.index();
        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
      }
    });
    if (!applicable) return false;
    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());
    return true;
  };
}

function markApplies(doc, ranges, type) {
  var _loop = function _loop(i) {
    var _ranges$i = ranges[i],
        $from = _ranges$i.$from,
        $to = _ranges$i.$to;
    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) return false;
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) return {
      v: true
    };
  };

  for (var i = 0; i < ranges.length; i++) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return false;
}

function toggleMark(markType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection10 = state.selection,
        empty = _state$selection10.empty,
        $cursor = _state$selection10.$cursor,
        ranges = _state$selection10.ranges;
    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;

    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));
      } else {
        var has = false,
            tr = state.tr;

        for (var i = 0; !has && i < ranges.length; i++) {
          var _ranges$i2 = ranges[i],
              $from = _ranges$i2.$from,
              $to = _ranges$i2.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }

        for (var _i2 = 0; _i2 < ranges.length; _i2++) {
          var _ranges$_i = ranges[_i2],
              _$from = _ranges$_i.$from,
              _$to = _ranges$_i.$to;

          if (has) {
            tr.removeMark(_$from.pos, _$to.pos, markType);
          } else {
            var from = _$from.pos,
                to = _$to.pos,
                start = _$from.nodeAfter,
                end = _$to.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;

            if (from + spaceStart < to) {
              from += spaceStart;
              to -= spaceEnd;
            }

            tr.addMark(from, to, markType.create(attrs));
          }
        }

        dispatch(tr.scrollIntoView());
      }
    }

    return true;
  };
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) return dispatch(tr);
    var ranges = [];

    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];

      for (var j = 0; j < ranges.length; j++) {
        ranges[j] = map.map(ranges[j]);
      }

      map.forEach(function (_s, _e, from, to) {
        return ranges.push(from, to);
      });
    }

    var joinable = [];

    for (var _i3 = 0; _i3 < ranges.length; _i3 += 2) {
      var from = ranges[_i3],
          to = ranges[_i3 + 1];
      var $from = tr.doc.resolve(from),
          depth = $from.sharedDepth(to),
          parent = $from.node(depth);

      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) break;

        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);
        }

        pos += after.nodeSize;
      }
    }

    joinable.sort(function (a, b) {
      return a - b;
    });

    for (var _i4 = joinable.length - 1; _i4 >= 0; _i4--) {
      if (prosemirrorTransform.canJoin(tr.doc, joinable[_i4])) tr.join(joinable[_i4]);
    }

    dispatch(tr);
  };
}

function autoJoin(command, isJoinable) {
  var canJoin = Array.isArray(isJoinable) ? function (node) {
    return isJoinable.indexOf(node.type.name) > -1;
  } : isJoinable;
  return function (state, dispatch, view) {
    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);
  };
}

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return function (state, dispatch, view) {
    for (var i = 0; i < commands.length; i++) {
      if (commands[i](state, dispatch, view)) return true;
    }

    return false;
  };
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};

for (var key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
exports.autoJoin = autoJoin;
exports.baseKeymap = baseKeymap;
exports.chainCommands = chainCommands;
exports.createParagraphNear = createParagraphNear;
exports.deleteSelection = deleteSelection;
exports.exitCode = exitCode;
exports.joinBackward = joinBackward;
exports.joinDown = joinDown;
exports.joinForward = joinForward;
exports.joinUp = joinUp;
exports.lift = lift;
exports.liftEmptyBlock = liftEmptyBlock;
exports.macBaseKeymap = macBaseKeymap;
exports.newlineInCode = newlineInCode;
exports.pcBaseKeymap = pcBaseKeymap;
exports.selectAll = selectAll;
exports.selectNodeBackward = selectNodeBackward;
exports.selectNodeForward = selectNodeForward;
exports.selectParentNode = selectParentNode;
exports.selectTextblockEnd = selectTextblockEnd;
exports.selectTextblockStart = selectTextblockStart;
exports.setBlockType = setBlockType;
exports.splitBlock = splitBlock;
exports.splitBlockKeepMarks = splitBlockKeepMarks;
exports.toggleMark = toggleMark;
exports.wrapIn = wrapIn;


/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

function dropCursor() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new prosemirrorState.Plugin({
    view: function view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}

var DropCursorView = function () {
  function DropCursorView(editorView, options) {
    var _this = this;

    _classCallCheck(this, DropCursorView);

    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = options.width || 1;
    this.color = options.color || "black";
    this["class"] = options["class"];
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
      var handler = function handler(e) {
        _this[name](e);
      };

      editorView.dom.addEventListener(name, handler);
      return {
        name: name,
        handler: handler
      };
    });
  }

  _createClass(DropCursorView, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.handlers.forEach(function (_ref) {
        var name = _ref.name,
            handler = _ref.handler;
        return _this2.editorView.dom.removeEventListener(name, handler);
      });
    }
  }, {
    key: "update",
    value: function update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);else this.updateOverlay();
      }
    }
  }, {
    key: "setCursor",
    value: function setCursor(pos) {
      if (pos == this.cursorPos) return;
      this.cursorPos = pos;

      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
  }, {
    key: "updateOverlay",
    value: function updateOverlay() {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos),
          rect;

      if (!$pos.parent.inlineContent) {
        var before = $pos.nodeBefore,
            after = $pos.nodeAfter;

        if (before || after) {
          var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0)).getBoundingClientRect();
          var top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = {
            left: nodeRect.left,
            right: nodeRect.right,
            top: top - this.width / 2,
            bottom: top + this.width / 2
          };
        }
      }

      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = {
          left: coords.left - this.width / 2,
          right: coords.left + this.width / 2,
          top: coords.top,
          bottom: coords.bottom
        };
      }

      var parent = this.editorView.dom.offsetParent;

      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this["class"]) this.element.className = this["class"];
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
      }

      var parentLeft, parentTop;

      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var _rect = parent.getBoundingClientRect();

        parentLeft = _rect.left - parent.scrollLeft;
        parentTop = _rect.top - parent.scrollTop;
      }

      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    }
  }, {
    key: "scheduleRemoval",
    value: function scheduleRemoval(timeout) {
      var _this3 = this;

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        return _this3.setCursor(null);
      }, timeout);
    }
  }, {
    key: "dragover",
    value: function dragover(event) {
      if (!this.editorView.editable) return;
      var pos = this.editorView.posAtCoords({
        left: event.clientX,
        top: event.clientY
      });
      var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      var disableDropCursor = node && node.type.spec.disableDropCursor;
      var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos) : disableDropCursor;

      if (pos && !disabled) {
        var target = pos.pos;

        if (this.editorView.dragging && this.editorView.dragging.slice) {
          target = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (target == null) return this.setCursor(null);
        }

        this.setCursor(target);
        this.scheduleRemoval(5000);
      }
    }
  }, {
    key: "dragend",
    value: function dragend() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "drop",
    value: function drop() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "dragleave",
    value: function dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);
    }
  }]);

  return DropCursorView;
}();

exports.dropCursor = dropCursor;


/***/ }),

/***/ "./node_modules/prosemirror-example-setup/dist/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/prosemirror-example-setup/dist/index.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.cjs");

var prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.cjs");

var prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorDropcursor = __webpack_require__(/*! prosemirror-dropcursor */ "./node_modules/prosemirror-dropcursor/dist/index.cjs");

var prosemirrorGapcursor = __webpack_require__(/*! prosemirror-gapcursor */ "./node_modules/prosemirror-gapcursor/dist/index.cjs");

var prosemirrorMenu = __webpack_require__(/*! prosemirror-menu */ "./node_modules/prosemirror-menu/dist/index.cjs");

var prosemirrorSchemaList = __webpack_require__(/*! prosemirror-schema-list */ "./node_modules/prosemirror-schema-list/dist/index.cjs");

var prosemirrorInputrules = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");

var prefix = "ProseMirror-prompt";

function openPrompt(options) {
  var wrapper = document.body.appendChild(document.createElement("div"));
  wrapper.className = prefix;

  var mouseOutside = function mouseOutside(e) {
    if (!wrapper.contains(e.target)) close();
  };

  setTimeout(function () {
    return window.addEventListener("mousedown", mouseOutside);
  }, 50);

  var close = function close() {
    window.removeEventListener("mousedown", mouseOutside);
    if (wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
  };

  var domFields = [];

  for (var name in options.fields) {
    domFields.push(options.fields[name].render());
  }

  var submitButton = document.createElement("button");
  submitButton.type = "submit";
  submitButton.className = prefix + "-submit";
  submitButton.textContent = "OK";
  var cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.className = prefix + "-cancel";
  cancelButton.textContent = "Cancel";
  cancelButton.addEventListener("click", close);
  var form = wrapper.appendChild(document.createElement("form"));
  if (options.title) form.appendChild(document.createElement("h5")).textContent = options.title;
  domFields.forEach(function (field) {
    form.appendChild(document.createElement("div")).appendChild(field);
  });
  var buttons = form.appendChild(document.createElement("div"));
  buttons.className = prefix + "-buttons";
  buttons.appendChild(submitButton);
  buttons.appendChild(document.createTextNode(" "));
  buttons.appendChild(cancelButton);
  var box = wrapper.getBoundingClientRect();
  wrapper.style.top = (window.innerHeight - box.height) / 2 + "px";
  wrapper.style.left = (window.innerWidth - box.width) / 2 + "px";

  var submit = function submit() {
    var params = getValues(options.fields, domFields);

    if (params) {
      close();
      options.callback(params);
    }
  };

  form.addEventListener("submit", function (e) {
    e.preventDefault();
    submit();
  });
  form.addEventListener("keydown", function (e) {
    if (e.keyCode == 27) {
      e.preventDefault();
      close();
    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
      e.preventDefault();
      submit();
    } else if (e.keyCode == 9) {
      window.setTimeout(function () {
        if (!wrapper.contains(document.activeElement)) close();
      }, 500);
    }
  });
  var input = form.elements[0];
  if (input) input.focus();
}

function getValues(fields, domFields) {
  var result = Object.create(null),
      i = 0;

  for (var name in fields) {
    var field = fields[name],
        dom = domFields[i++];
    var value = field.read(dom),
        bad = field.validate(value);

    if (bad) {
      reportInvalid(dom, bad);
      return null;
    }

    result[name] = field.clean(value);
  }

  return result;
}

function reportInvalid(dom, message) {
  var parent = dom.parentNode;
  var msg = parent.appendChild(document.createElement("div"));
  msg.style.left = dom.offsetLeft + dom.offsetWidth + 2 + "px";
  msg.style.top = dom.offsetTop - 5 + "px";
  msg.className = "ProseMirror-invalid";
  msg.textContent = message;
  setTimeout(function () {
    return parent.removeChild(msg);
  }, 1500);
}

var Field = function () {
  function Field(options) {
    _classCallCheck(this, Field);

    this.options = options;
  }

  _createClass(Field, [{
    key: "read",
    value: function read(dom) {
      return dom.value;
    }
  }, {
    key: "validateType",
    value: function validateType(value) {
      return null;
    }
  }, {
    key: "validate",
    value: function validate(value) {
      if (!value && this.options.required) return "Required field";
      return this.validateType(value) || (this.options.validate ? this.options.validate(value) : null);
    }
  }, {
    key: "clean",
    value: function clean(value) {
      return this.options.clean ? this.options.clean(value) : value;
    }
  }]);

  return Field;
}();

var TextField = function (_Field) {
  _inherits(TextField, _Field);

  var _super = _createSuper(TextField);

  function TextField() {
    _classCallCheck(this, TextField);

    return _super.apply(this, arguments);
  }

  _createClass(TextField, [{
    key: "render",
    value: function render() {
      var input = document.createElement("input");
      input.type = "text";
      input.placeholder = this.options.label;
      input.value = this.options.value || "";
      input.autocomplete = "off";
      return input;
    }
  }]);

  return TextField;
}(Field);

function canInsert(state, nodeType) {
  var $from = state.selection.$from;

  for (var d = $from.depth; d >= 0; d--) {
    var index = $from.index(d);
    if ($from.node(d).canReplaceWith(index, index, nodeType)) return true;
  }

  return false;
}

function insertImageItem(nodeType) {
  return new prosemirrorMenu.MenuItem({
    title: "Insert image",
    label: "Image",
    enable: function enable(state) {
      return canInsert(state, nodeType);
    },
    run: function run(state, _, view) {
      var _state$selection = state.selection,
          from = _state$selection.from,
          to = _state$selection.to,
          attrs = null;
      if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.type == nodeType) attrs = state.selection.node.attrs;
      openPrompt({
        title: "Insert image",
        fields: {
          src: new TextField({
            label: "Location",
            required: true,
            value: attrs && attrs.src
          }),
          title: new TextField({
            label: "Title",
            value: attrs && attrs.title
          }),
          alt: new TextField({
            label: "Description",
            value: attrs ? attrs.alt : state.doc.textBetween(from, to, " ")
          })
        },
        callback: function callback(attrs) {
          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));
          view.focus();
        }
      });
    }
  });
}

function cmdItem(cmd, options) {
  var passedOptions = {
    label: options.title,
    run: cmd
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  if (!options.enable && !options.select) passedOptions[options.enable ? "enable" : "select"] = function (state) {
    return cmd(state);
  };
  return new prosemirrorMenu.MenuItem(passedOptions);
}

function markActive(state, type) {
  var _state$selection2 = state.selection,
      from = _state$selection2.from,
      $from = _state$selection2.$from,
      to = _state$selection2.to,
      empty = _state$selection2.empty;
  if (empty) return !!type.isInSet(state.storedMarks || $from.marks());else return state.doc.rangeHasMark(from, to, type);
}

function markItem(markType, options) {
  var passedOptions = {
    active: function active(state) {
      return markActive(state, markType);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return cmdItem(prosemirrorCommands.toggleMark(markType), passedOptions);
}

function linkItem(markType) {
  return new prosemirrorMenu.MenuItem({
    title: "Add or remove link",
    icon: prosemirrorMenu.icons.link,
    active: function active(state) {
      return markActive(state, markType);
    },
    enable: function enable(state) {
      return !state.selection.empty;
    },
    run: function run(state, dispatch, view) {
      if (markActive(state, markType)) {
        prosemirrorCommands.toggleMark(markType)(state, dispatch);
        return true;
      }

      openPrompt({
        title: "Create a link",
        fields: {
          href: new TextField({
            label: "Link target",
            required: true
          }),
          title: new TextField({
            label: "Title"
          })
        },
        callback: function callback(attrs) {
          prosemirrorCommands.toggleMark(markType, attrs)(view.state, view.dispatch);
          view.focus();
        }
      });
    }
  });
}

function wrapListItem(nodeType, options) {
  return cmdItem(prosemirrorSchemaList.wrapInList(nodeType, options.attrs), options);
}

function buildMenuItems(schema) {
  var r = {};
  var mark;
  if (mark = schema.marks.strong) r.toggleStrong = markItem(mark, {
    title: "Toggle strong style",
    icon: prosemirrorMenu.icons.strong
  });
  if (mark = schema.marks.em) r.toggleEm = markItem(mark, {
    title: "Toggle emphasis",
    icon: prosemirrorMenu.icons.em
  });
  if (mark = schema.marks.code) r.toggleCode = markItem(mark, {
    title: "Toggle code font",
    icon: prosemirrorMenu.icons.code
  });
  if (mark = schema.marks.link) r.toggleLink = linkItem(mark);
  var node;
  if (node = schema.nodes.image) r.insertImage = insertImageItem(node);
  if (node = schema.nodes.bullet_list) r.wrapBulletList = wrapListItem(node, {
    title: "Wrap in bullet list",
    icon: prosemirrorMenu.icons.bulletList
  });
  if (node = schema.nodes.ordered_list) r.wrapOrderedList = wrapListItem(node, {
    title: "Wrap in ordered list",
    icon: prosemirrorMenu.icons.orderedList
  });
  if (node = schema.nodes.blockquote) r.wrapBlockQuote = prosemirrorMenu.wrapItem(node, {
    title: "Wrap in block quote",
    icon: prosemirrorMenu.icons.blockquote
  });
  if (node = schema.nodes.paragraph) r.makeParagraph = prosemirrorMenu.blockTypeItem(node, {
    title: "Change to paragraph",
    label: "Plain"
  });
  if (node = schema.nodes.code_block) r.makeCodeBlock = prosemirrorMenu.blockTypeItem(node, {
    title: "Change to code block",
    label: "Code"
  });
  if (node = schema.nodes.heading) for (var i = 1; i <= 10; i++) {
    r["makeHead" + i] = prosemirrorMenu.blockTypeItem(node, {
      title: "Change to heading " + i,
      label: "Level " + i,
      attrs: {
        level: i
      }
    });
  }

  if (node = schema.nodes.horizontal_rule) {
    var hr = node;
    r.insertHorizontalRule = new prosemirrorMenu.MenuItem({
      title: "Insert horizontal rule",
      label: "Horizontal rule",
      enable: function enable(state) {
        return canInsert(state, hr);
      },
      run: function run(state, dispatch) {
        dispatch(state.tr.replaceSelectionWith(hr.create()));
      }
    });
  }

  var cut = function cut(arr) {
    return arr.filter(function (x) {
      return x;
    });
  };

  r.insertMenu = new prosemirrorMenu.Dropdown(cut([r.insertImage, r.insertHorizontalRule]), {
    label: "Insert"
  });
  r.typeMenu = new prosemirrorMenu.Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new prosemirrorMenu.DropdownSubmenu(cut([r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6]), {
    label: "Heading"
  })]), {
    label: "Type..."
  });
  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];
  r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, prosemirrorMenu.joinUpItem, prosemirrorMenu.liftItem, prosemirrorMenu.selectParentNodeItem])];
  r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[prosemirrorMenu.undoItem, prosemirrorMenu.redoItem]], r.blockMenu);
  return r;
}

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function buildKeymap(schema, mapKeys) {
  var keys = {},
      type;

  function bind(key, cmd) {
    if (mapKeys) {
      var mapped = mapKeys[key];
      if (mapped === false) return;
      if (mapped) key = mapped;
    }

    keys[key] = cmd;
  }

  bind("Mod-z", prosemirrorHistory.undo);
  bind("Shift-Mod-z", prosemirrorHistory.redo);
  bind("Backspace", prosemirrorInputrules.undoInputRule);
  if (!mac) bind("Mod-y", prosemirrorHistory.redo);
  bind("Alt-ArrowUp", prosemirrorCommands.joinUp);
  bind("Alt-ArrowDown", prosemirrorCommands.joinDown);
  bind("Mod-BracketLeft", prosemirrorCommands.lift);
  bind("Escape", prosemirrorCommands.selectParentNode);

  if (type = schema.marks.strong) {
    bind("Mod-b", prosemirrorCommands.toggleMark(type));
    bind("Mod-B", prosemirrorCommands.toggleMark(type));
  }

  if (type = schema.marks.em) {
    bind("Mod-i", prosemirrorCommands.toggleMark(type));
    bind("Mod-I", prosemirrorCommands.toggleMark(type));
  }

  if (type = schema.marks.code) bind("Mod-`", prosemirrorCommands.toggleMark(type));
  if (type = schema.nodes.bullet_list) bind("Shift-Ctrl-8", prosemirrorSchemaList.wrapInList(type));
  if (type = schema.nodes.ordered_list) bind("Shift-Ctrl-9", prosemirrorSchemaList.wrapInList(type));
  if (type = schema.nodes.blockquote) bind("Ctrl->", prosemirrorCommands.wrapIn(type));

  if (type = schema.nodes.hard_break) {
    var br = type,
        cmd = prosemirrorCommands.chainCommands(prosemirrorCommands.exitCode, function (state, dispatch) {
      if (dispatch) dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true;
    });
    bind("Mod-Enter", cmd);
    bind("Shift-Enter", cmd);
    if (mac) bind("Ctrl-Enter", cmd);
  }

  if (type = schema.nodes.list_item) {
    bind("Enter", prosemirrorSchemaList.splitListItem(type));
    bind("Mod-[", prosemirrorSchemaList.liftListItem(type));
    bind("Mod-]", prosemirrorSchemaList.sinkListItem(type));
  }

  if (type = schema.nodes.paragraph) bind("Shift-Ctrl-0", prosemirrorCommands.setBlockType(type));
  if (type = schema.nodes.code_block) bind("Shift-Ctrl-\\", prosemirrorCommands.setBlockType(type));
  if (type = schema.nodes.heading) for (var i = 1; i <= 6; i++) {
    bind("Shift-Ctrl-" + i, prosemirrorCommands.setBlockType(type, {
      level: i
    }));
  }

  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    bind("Mod-_", function (state, dispatch) {
      if (dispatch) dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
      return true;
    });
  }

  return keys;
}

function blockQuoteRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^\s*>\s$/, nodeType);
}

function orderedListRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^(\d+)\.\s$/, nodeType, function (match) {
    return {
      order: +match[1]
    };
  }, function (match, node) {
    return node.childCount + node.attrs.order == +match[1];
  });
}

function bulletListRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^\s*([-+*])\s$/, nodeType);
}

function codeBlockRule(nodeType) {
  return prosemirrorInputrules.textblockTypeInputRule(/^```$/, nodeType);
}

function headingRule(nodeType, maxLevel) {
  return prosemirrorInputrules.textblockTypeInputRule(new RegExp("^(#{1," + maxLevel + "})\\s$"), nodeType, function (match) {
    return {
      level: match[1].length
    };
  });
}

function buildInputRules(schema) {
  var rules = prosemirrorInputrules.smartQuotes.concat(prosemirrorInputrules.ellipsis, prosemirrorInputrules.emDash),
      type;
  if (type = schema.nodes.blockquote) rules.push(blockQuoteRule(type));
  if (type = schema.nodes.ordered_list) rules.push(orderedListRule(type));
  if (type = schema.nodes.bullet_list) rules.push(bulletListRule(type));
  if (type = schema.nodes.code_block) rules.push(codeBlockRule(type));
  if (type = schema.nodes.heading) rules.push(headingRule(type, 6));
  return prosemirrorInputrules.inputRules({
    rules: rules
  });
}

function exampleSetup(options) {
  var plugins = [buildInputRules(options.schema), prosemirrorKeymap.keymap(buildKeymap(options.schema, options.mapKeys)), prosemirrorKeymap.keymap(prosemirrorCommands.baseKeymap), prosemirrorDropcursor.dropCursor(), prosemirrorGapcursor.gapCursor()];
  if (options.menuBar !== false) plugins.push(prosemirrorMenu.menuBar({
    floating: options.floatingMenu !== false,
    content: options.menuContent || buildMenuItems(options.schema).fullMenu
  }));
  if (options.history !== false) plugins.push(prosemirrorHistory.history());
  return plugins.concat(new prosemirrorState.Plugin({
    props: {
      attributes: {
        "class": "ProseMirror-example-setup-style"
      }
    }
  }));
}

exports.buildInputRules = buildInputRules;
exports.buildKeymap = buildKeymap;
exports.buildMenuItems = buildMenuItems;
exports.exampleSetup = exampleSetup;


/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorView = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");

var GapCursor = function (_prosemirrorState$Sel) {
  _inherits(GapCursor, _prosemirrorState$Sel);

  var _super = _createSuper(GapCursor);

  function GapCursor($pos) {
    _classCallCheck(this, GapCursor);

    return _super.call(this, $pos, $pos);
  }

  _createClass(GapCursor, [{
    key: "map",
    value: function map(doc, mapping) {
      var $pos = doc.resolve(mapping.map(this.head));
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return prosemirrorModel.Slice.empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof GapCursor && other.head == this.head;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "gapcursor",
        pos: this.head
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new GapBookmark(this.anchor);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new GapCursor(doc.resolve(json.pos));
    }
  }, {
    key: "valid",
    value: function valid($pos) {
      var parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;
      var override = parent.type.spec.allowGapCursor;
      if (override != null) return override;
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
  }, {
    key: "findGapCursorFrom",
    value: function findGapCursorFrom($pos, dir) {
      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      search: for (;;) {
        if (!mustMove && GapCursor.valid($pos)) return $pos;
        var pos = $pos.pos,
            next = null;

        for (var d = $pos.depth;; d--) {
          var parent = $pos.node(d);

          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }

          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur)) return $cur;
        }

        for (;;) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;

          if (!inside) {
            if (next.isAtom && !next.isText && !prosemirrorState.NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }

            break;
          }

          next = inside;
          pos += dir;

          var _$cur = $pos.doc.resolve(pos);

          if (GapCursor.valid(_$cur)) return _$cur;
        }

        return null;
      }
    }
  }]);

  return GapCursor;
}(prosemirrorState.Selection);

GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
prosemirrorState.Selection.jsonID("gapcursor", GapCursor);

var GapBookmark = function () {
  function GapBookmark(pos) {
    _classCallCheck(this, GapBookmark);

    this.pos = pos;
  }

  _createClass(GapBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
    }
  }]);

  return GapBookmark;
}();

function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d),
        parent = $pos.node(d);

    if (index == 0) {
      if (parent.type.spec.isolating) return true;
      continue;
    }

    for (var before = parent.child(index - 1);; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;
      if (before.inlineContent) return false;
    }
  }

  return true;
}

function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d),
        parent = $pos.node(d);

    if (index == parent.childCount) {
      if (parent.type.spec.isolating) return true;
      continue;
    }

    for (var after = parent.child(index);; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;
      if (after.inlineContent) return false;
    }
  }

  return true;
}

function gapCursor() {
  return new prosemirrorState.Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick: handleClick,
      handleKeyDown: handleKeyDown,
      handleDOMEvents: {
        beforeinput: beforeinput
      }
    }
  });
}

var handleKeyDown = prosemirrorKeymap.keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function (state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from,
        mustMove = sel.empty;

    if (sel instanceof prosemirrorState.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }

    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found) return false;
    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}

function handleClick(view, pos, event) {
  if (!view || !view.editable) return false;
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) return false;
  var clickPos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (clickPos && clickPos.inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}

function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) return false;
  var $from = view.state.selection.$from;
  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert) return false;
  var frag = prosemirrorModel.Fragment.empty;

  for (var i = insert.length - 1; i >= 0; i--) {
    frag = prosemirrorModel.Fragment.from(insert[i].createAndFill(null, frag));
  }

  var tr = view.state.tr.replace($from.pos, $from.pos, new prosemirrorModel.Slice(frag, 0, 0));
  tr.setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}

function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) return null;
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node, {
    key: "gapcursor"
  })]);
}

exports.GapCursor = GapCursor;
exports.gapCursor = gapCursor;


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var RopeSequence = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.es.js");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var RopeSequence__default = _interopDefaultLegacy(RopeSequence);

var max_empty_items = 500;

var Branch = function () {
  function Branch(items, eventCount) {
    _classCallCheck(this, Branch);

    this.items = items;
    this.eventCount = eventCount;
  }

  _createClass(Branch, [{
    key: "popEvent",
    value: function popEvent(state, preserveItems) {
      var _this = this;

      if (this.eventCount == 0) return null;
      var end = this.items.length;

      for (;; end--) {
        var next = this.items.get(end - 1);

        if (next.selection) {
          --end;
          break;
        }
      }

      var remap, mapFrom;

      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }

      var transform = state.tr;
      var selection, remaining;
      var addAfter = [],
          addBefore = [];
      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = _this.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }

          mapFrom--;
          addBefore.push(item);
          return;
        }

        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)),
              map;

          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));
          }

          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }

        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return {
        remaining: remaining,
        transform: transform,
        selection: selection
      };
    }
  }, {
    key: "addTransform",
    value: function addTransform(transform, selection, histOptions, preserveItems) {
      var newItems = [],
          eventCount = this.eventCount;
      var oldItems = this.items,
          lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection),
            merged = void 0;

        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);
        }

        newItems.push(item);

        if (selection) {
          eventCount++;
          selection = undefined;
        }

        if (!preserveItems) lastItem = item;
      }

      var overflow = eventCount - histOptions.depth;

      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }

      return new Branch(oldItems.append(newItems), eventCount);
    }
  }, {
    key: "remapping",
    value: function remapping(from, to) {
      var maps = new prosemirrorTransform.Mapping();
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    }
  }, {
    key: "addMaps",
    value: function addMaps(array) {
      if (this.eventCount == 0) return this;
      return new Branch(this.items.append(array.map(function (map) {
        return new Item(map);
      })), this.eventCount);
    }
  }, {
    key: "rebased",
    value: function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) return this;
      var rebasedItems = [],
          start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) {
        if (item.selection) eventCount--;
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) return;
        newUntil = Math.min(newUntil, pos);
        var map = mapping.maps[pos];

        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) eventCount++;
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);
      var newMaps = [];

      for (var i = rebasedCount; i < newUntil; i++) {
        newMaps.push(new Item(mapping.maps[i]));
      }

      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
  }, {
    key: "emptyItemCount",
    value: function emptyItemCount() {
      var count = 0;
      this.items.forEach(function (item) {
        if (!item.step) count++;
      });
      return count;
    }
  }, {
    key: "compress",
    value: function compress() {
      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var remap = this.remapping(0, upto),
          mapFrom = remap.maps.length;
      var items = [],
          events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) events++;
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)),
              map = step && step.getMap();
          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);

          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) events++;
            var newItem = new Item(map.invert(), step, selection),
                merged,
                last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence__default["default"].from(items.reverse()), events);
    }
  }]);

  return Branch;
}();

Branch.empty = new Branch(RopeSequence__default["default"].empty, 0);

function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}

var Item = function () {
  function Item(map, step, selection, mirrorOffset) {
    _classCallCheck(this, Item);

    this.map = map;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }

  _createClass(Item, [{
    key: "merge",
    value: function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }]);

  return Item;
}();

var HistoryState = _createClass(function HistoryState(done, undone, prevRanges, prevTime) {
  _classCallCheck(this, HistoryState);

  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
});

var DEPTH_OVERFLOW = 20;

function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey),
      rebased;
  if (historyTr) return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0);
  var appended = tr.getMeta("appendedTransaction");

  if (tr.steps.length == 0) {
    return history;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
  }
}

function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) return false;
  if (!transform.docChanged) return true;
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2) {
      if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;
    }
  });
  return adjacent;
}

function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) {
    return result.push(from, to);
  });
  return result;
}

function mapRanges(ranges, mapping) {
  if (!ranges) return null;
  var result = [];

  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1),
        to = mapping.map(ranges[i + 1], -1);
    if (from <= to) result.push(from, to);
  }

  return result;
}

function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state);
  var histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) return;
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {
    redo: redo,
    historyState: newHist
  }).scrollIntoView());
}

var cachedPreserveItems = false,
    cachedPreserveItemsPlugins = null;

function mustPreserveItems(state) {
  var plugins = state.plugins;

  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;

    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }

  return cachedPreserveItems;
}

function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true);
}

var historyKey = new prosemirrorState.PluginKey("history");
var closeHistoryKey = new prosemirrorState.PluginKey("closeHistory");

function history() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new prosemirrorState.Plugin({
    key: historyKey,
    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config: config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var inputType = e.inputType;
          var command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command) return false;
          e.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}

var undo = function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, false);
  return true;
};

var redo = function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, true);
  return true;
};

function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}

function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}

exports.closeHistory = closeHistory;
exports.history = history;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.undo = undo;
exports.undoDepth = undoDepth;


/***/ }),

/***/ "./node_modules/prosemirror-inputrules/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-inputrules/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var InputRule = _createClass(function InputRule(match, handler) {
  _classCallCheck(this, InputRule);

  this.match = match;
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
});

function stringHandler(string) {
  return function (state, match, start, end) {
    var insert = string;

    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;

      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }

    return state.tr.insertText(insert, start, end);
  };
}

var MAX_MATCH = 500;

function inputRules(_ref) {
  var rules = _ref.rules;
  var plugin = new prosemirrorState.Plugin({
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) return stored;
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: function compositionend(view) {
          setTimeout(function () {
            var $cursor = view.state.selection.$cursor;
            if ($cursor) run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) return false;
  var state = view.state,
      $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) return false;
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text;

  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) continue;
    view.dispatch(tr.setMeta(plugin, {
      transform: tr,
      from: from,
      to: to,
      text: text
    }));
    return true;
  }

  return false;
}

var undoInputRule = function undoInputRule(state, dispatch) {
  var plugins = state.plugins;

  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i],
        undoable = void 0;

    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr,
            toUndo = undoable.transform;

        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }

        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr["delete"](undoable.from, undoable.to);
        }

        dispatch(tr);
      }

      return true;
    }
  }

  return false;
};

var emDash = new InputRule(/--$/, "—");
var ellipsis = new InputRule(/\.\.\.$/, "…");
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
var closeDoubleQuote = new InputRule(/"$/, "”");
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
var closeSingleQuote = new InputRule(/'$/, "’");
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

function wrappingInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var joinPredicate = arguments.length > 3 ? arguments[3] : undefined;
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr["delete"](start, end);
    var $start = tr.doc.resolve(start),
        range = $start.blockRange(),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return null;
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && prosemirrorTransform.canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);
    return tr;
  });
}

function textblockTypeInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;
    return state.tr["delete"](start, end).setBlockType(start, start, nodeType, attrs);
  });
}

exports.InputRule = InputRule;
exports.closeDoubleQuote = closeDoubleQuote;
exports.closeSingleQuote = closeSingleQuote;
exports.ellipsis = ellipsis;
exports.emDash = emDash;
exports.inputRules = inputRules;
exports.openDoubleQuote = openDoubleQuote;
exports.openSingleQuote = openSingleQuote;
exports.smartQuotes = smartQuotes;
exports.textblockTypeInputRule = textblockTypeInputRule;
exports.undoInputRule = undoInputRule;
exports.wrappingInputRule = wrappingInputRule;


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var w3cKeyname = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/),
      result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  var alt, ctrl, shift, meta;

  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (mac) meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }

  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}

function normalize(map) {
  var copy = Object.create(null);

  for (var prop in map) {
    copy[normalizeKeyName(prop)] = map[prop];
  }

  return copy;
}

function modifiers(name, event, shift) {
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift !== false && event.shiftKey) name = "Shift-" + name;
  return name;
}

function keymap(bindings) {
  return new prosemirrorState.Plugin({
    props: {
      handleKeyDown: keydownHandler(bindings)
    }
  });
}

function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function (view, event) {
    var name = w3cKeyname.keyName(event),
        isChar = name.length == 1 && name != " ",
        baseName;
    var direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) return true;

    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
      var fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
    } else if (isChar && event.shiftKey) {
      var withShift = map[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) return true;
    }

    return false;
  };
}

exports.keydownHandler = keydownHandler;
exports.keymap = keymap;


/***/ }),

/***/ "./node_modules/prosemirror-menu/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-menu/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var crel = __webpack_require__(/*! crelt */ "./node_modules/crelt/dist/index.cjs");

var prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.cjs");

var prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var crel__default = _interopDefaultLegacy(crel);

var SVG = "http://www.w3.org/2000/svg";
var XLINK = "http://www.w3.org/1999/xlink";
var prefix$2 = "ProseMirror-icon";

function hashPath(path) {
  var hash = 0;

  for (var i = 0; i < path.length; i++) {
    hash = (hash << 5) - hash + path.charCodeAt(i) | 0;
  }

  return hash;
}

function getIcon(icon) {
  var node = document.createElement("div");
  node.className = prefix$2;

  if (icon.path) {
    var path = icon.path,
        width = icon.width,
        height = icon.height;
    var name = "pm-icon-" + hashPath(path).toString(16);
    if (!document.getElementById(name)) buildSVG(name, icon);
    var svg = node.appendChild(document.createElementNS(SVG, "svg"));
    svg.style.width = width / height + "em";
    var use = svg.appendChild(document.createElementNS(SVG, "use"));
    use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location.toString())[1] + "#" + name);
  } else if (icon.dom) {
    node.appendChild(icon.dom.cloneNode(true));
  } else {
    var text = icon.text,
        css = icon.css;
    node.appendChild(document.createElement("span")).textContent = text || '';
    if (css) node.firstChild.style.cssText = css;
  }

  return node;
}

function buildSVG(name, data) {
  var collection = document.getElementById(prefix$2 + "-collection");

  if (!collection) {
    collection = document.createElementNS(SVG, "svg");
    collection.id = prefix$2 + "-collection";
    collection.style.display = "none";
    document.body.insertBefore(collection, document.body.firstChild);
  }

  var sym = document.createElementNS(SVG, "symbol");
  sym.id = name;
  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
  var path = sym.appendChild(document.createElementNS(SVG, "path"));
  path.setAttribute("d", data.path);
  collection.appendChild(sym);
}

var prefix$1 = "ProseMirror-menu";

var MenuItem = function () {
  function MenuItem(spec) {
    _classCallCheck(this, MenuItem);

    this.spec = spec;
  }

  _createClass(MenuItem, [{
    key: "render",
    value: function render(view) {
      var spec = this.spec;
      var dom = spec.render ? spec.render(view) : spec.icon ? getIcon(spec.icon) : spec.label ? crel__default["default"]("div", null, translate(view, spec.label)) : null;
      if (!dom) throw new RangeError("MenuItem without icon or label property");

      if (spec.title) {
        var title = typeof spec.title === "function" ? spec.title(view.state) : spec.title;
        dom.setAttribute("title", translate(view, title));
      }

      if (spec["class"]) dom.classList.add(spec["class"]);
      if (spec.css) dom.style.cssText += spec.css;
      dom.addEventListener("mousedown", function (e) {
        e.preventDefault();
        if (!dom.classList.contains(prefix$1 + "-disabled")) spec.run(view.state, view.dispatch, view, e);
      });

      function update(state) {
        if (spec.select) {
          var selected = spec.select(state);
          dom.style.display = selected ? "" : "none";
          if (!selected) return false;
        }

        var enabled = true;

        if (spec.enable) {
          enabled = spec.enable(state) || false;
          setClass(dom, prefix$1 + "-disabled", !enabled);
        }

        if (spec.active) {
          var active = enabled && spec.active(state) || false;
          setClass(dom, prefix$1 + "-active", active);
        }

        return true;
      }

      return {
        dom: dom,
        update: update
      };
    }
  }]);

  return MenuItem;
}();

function translate(view, text) {
  return view._props.translate ? view._props.translate(text) : text;
}

var lastMenuEvent = {
  time: 0,
  node: null
};

function markMenuEvent(e) {
  lastMenuEvent.time = Date.now();
  lastMenuEvent.node = e.target;
}

function isMenuEvent(wrapper) {
  return Date.now() - 100 < lastMenuEvent.time && lastMenuEvent.node && wrapper.contains(lastMenuEvent.node);
}

var Dropdown = function () {
  function Dropdown(content) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Dropdown);

    this.options = options;
    this.options = options || {};
    this.content = Array.isArray(content) ? content : [content];
  }

  _createClass(Dropdown, [{
    key: "render",
    value: function render(view) {
      var _this = this;

      var content = renderDropdownItems(this.content, view);
      var label = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown " + (this.options["class"] || ""),
        style: this.options.css
      }, translate(view, this.options.label || ""));
      if (this.options.title) label.setAttribute("title", translate(view, this.options.title));
      var wrap = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown-wrap"
      }, label);
      var open = null;
      var listeningOnClose = null;

      var close = function close() {
        if (open && open.close()) {
          open = null;
          window.removeEventListener("mousedown", listeningOnClose);
        }
      };

      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);

        if (open) {
          close();
        } else {
          open = _this.expand(wrap, content.dom);
          window.addEventListener("mousedown", listeningOnClose = function listeningOnClose() {
            if (!isMenuEvent(wrap)) close();
          });
        }
      });

      function update(state) {
        var inner = content.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner;
      }

      return {
        dom: wrap,
        update: update
      };
    }
  }, {
    key: "expand",
    value: function expand(dom, items) {
      var menuDOM = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown-menu " + (this.options["class"] || "")
      }, items);
      var done = false;

      function close() {
        if (done) return;
        done = true;
        dom.removeChild(menuDOM);
        return true;
      }

      dom.appendChild(menuDOM);
      return {
        close: close,
        node: menuDOM
      };
    }
  }]);

  return Dropdown;
}();

function renderDropdownItems(items, view) {
  var rendered = [],
      updates = [];

  for (var i = 0; i < items.length; i++) {
    var _items$i$render = items[i].render(view),
        dom = _items$i$render.dom,
        update = _items$i$render.update;

    rendered.push(crel__default["default"]("div", {
      "class": prefix$1 + "-dropdown-item"
    }, dom));
    updates.push(update);
  }

  return {
    dom: rendered,
    update: combineUpdates(updates, rendered)
  };
}

function combineUpdates(updates, nodes) {
  return function (state) {
    var something = false;

    for (var i = 0; i < updates.length; i++) {
      var up = updates[i](state);
      nodes[i].style.display = up ? "" : "none";
      if (up) something = true;
    }

    return something;
  };
}

var DropdownSubmenu = function () {
  function DropdownSubmenu(content) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, DropdownSubmenu);

    this.options = options;
    this.content = Array.isArray(content) ? content : [content];
  }

  _createClass(DropdownSubmenu, [{
    key: "render",
    value: function render(view) {
      var items = renderDropdownItems(this.content, view);
      var label = crel__default["default"]("div", {
        "class": prefix$1 + "-submenu-label"
      }, translate(view, this.options.label || ""));
      var wrap = crel__default["default"]("div", {
        "class": prefix$1 + "-submenu-wrap"
      }, label, crel__default["default"]("div", {
        "class": prefix$1 + "-submenu"
      }, items.dom));
      var _listeningOnClose = null;
      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);
        setClass(wrap, prefix$1 + "-submenu-wrap-active", false);
        if (!_listeningOnClose) window.addEventListener("mousedown", _listeningOnClose = function listeningOnClose() {
          if (!isMenuEvent(wrap)) {
            wrap.classList.remove(prefix$1 + "-submenu-wrap-active");
            window.removeEventListener("mousedown", _listeningOnClose);
            _listeningOnClose = null;
          }
        });
      });

      function update(state) {
        var inner = items.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner;
      }

      return {
        dom: wrap,
        update: update
      };
    }
  }]);

  return DropdownSubmenu;
}();

function renderGrouped(view, content) {
  var result = document.createDocumentFragment();
  var updates = [],
      separators = [];

  for (var i = 0; i < content.length; i++) {
    var items = content[i],
        localUpdates = [],
        localNodes = [];

    for (var j = 0; j < items.length; j++) {
      var _items$j$render = items[j].render(view),
          dom = _items$j$render.dom,
          _update = _items$j$render.update;

      var span = crel__default["default"]("span", {
        "class": prefix$1 + "item"
      }, dom);
      result.appendChild(span);
      localNodes.push(span);
      localUpdates.push(_update);
    }

    if (localUpdates.length) {
      updates.push(combineUpdates(localUpdates, localNodes));
      if (i < content.length - 1) separators.push(result.appendChild(separator()));
    }
  }

  function update(state) {
    var something = false,
        needSep = false;

    for (var _i = 0; _i < updates.length; _i++) {
      var hasContent = updates[_i](state);

      if (_i) separators[_i - 1].style.display = needSep && hasContent ? "" : "none";
      needSep = hasContent;
      if (hasContent) something = true;
    }

    return something;
  }

  return {
    dom: result,
    update: update
  };
}

function separator() {
  return crel__default["default"]("span", {
    "class": prefix$1 + "separator"
  });
}

var icons = {
  join: {
    width: 800,
    height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024,
    height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: {
    text: "\u2B1A",
    css: "font-weight: bold"
  },
  undo: {
    width: 1024,
    height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024,
    height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805,
    height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585,
    height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896,
    height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951,
    height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768,
    height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768,
    height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640,
    height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
};
var joinUpItem = new MenuItem({
  title: "Join with above block",
  run: prosemirrorCommands.joinUp,
  select: function select(state) {
    return prosemirrorCommands.joinUp(state);
  },
  icon: icons.join
});
var liftItem = new MenuItem({
  title: "Lift out of enclosing block",
  run: prosemirrorCommands.lift,
  select: function select(state) {
    return prosemirrorCommands.lift(state);
  },
  icon: icons.lift
});
var selectParentNodeItem = new MenuItem({
  title: "Select parent node",
  run: prosemirrorCommands.selectParentNode,
  select: function select(state) {
    return prosemirrorCommands.selectParentNode(state);
  },
  icon: icons.selectParentNode
});
var undoItem = new MenuItem({
  title: "Undo last change",
  run: prosemirrorHistory.undo,
  enable: function enable(state) {
    return prosemirrorHistory.undo(state);
  },
  icon: icons.undo
});
var redoItem = new MenuItem({
  title: "Redo last undone change",
  run: prosemirrorHistory.redo,
  enable: function enable(state) {
    return prosemirrorHistory.redo(state);
  },
  icon: icons.redo
});

function wrapItem(nodeType, options) {
  var passedOptions = {
    run: function run(state, dispatch) {
      return prosemirrorCommands.wrapIn(nodeType, options.attrs)(state, dispatch);
    },
    select: function select(state) {
      return prosemirrorCommands.wrapIn(nodeType, options.attrs)(state);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return new MenuItem(passedOptions);
}

function blockTypeItem(nodeType, options) {
  var command = prosemirrorCommands.setBlockType(nodeType, options.attrs);
  var passedOptions = {
    run: command,
    enable: function enable(state) {
      return command(state);
    },
    active: function active(state) {
      var _state$selection = state.selection,
          $from = _state$selection.$from,
          to = _state$selection.to,
          node = _state$selection.node;
      if (node) return node.hasMarkup(nodeType, options.attrs);
      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return new MenuItem(passedOptions);
}

function setClass(dom, cls, on) {
  if (on) dom.classList.add(cls);else dom.classList.remove(cls);
}

var prefix = "ProseMirror-menubar";

function isIOS() {
  if (typeof navigator == "undefined") return false;
  var agent = navigator.userAgent;
  return !/Edge\/\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\/\w+/.test(agent);
}

function menuBar(options) {
  return new prosemirrorState.Plugin({
    view: function view(editorView) {
      return new MenuBarView(editorView, options);
    }
  });
}

var MenuBarView = function () {
  function MenuBarView(editorView, options) {
    var _this2 = this;

    _classCallCheck(this, MenuBarView);

    this.editorView = editorView;
    this.options = options;
    this.spacer = null;
    this.maxHeight = 0;
    this.widthForMaxHeight = 0;
    this.floating = false;
    this.scrollHandler = null;
    this.wrapper = crel__default["default"]("div", {
      "class": prefix + "-wrapper"
    });
    this.menu = this.wrapper.appendChild(crel__default["default"]("div", {
      "class": prefix
    }));
    this.menu.className = prefix;
    if (editorView.dom.parentNode) editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
    this.wrapper.appendChild(editorView.dom);

    var _renderGrouped = renderGrouped(this.editorView, this.options.content),
        dom = _renderGrouped.dom,
        update = _renderGrouped.update;

    this.contentUpdate = update;
    this.menu.appendChild(dom);
    this.update();

    if (options.floating && !isIOS()) {
      this.updateFloat();
      var potentialScrollers = getAllWrapping(this.wrapper);

      this.scrollHandler = function (e) {
        var root = _this2.editorView.root;
        if (!(root.body || root).contains(_this2.wrapper)) potentialScrollers.forEach(function (el) {
          return el.removeEventListener("scroll", _this2.scrollHandler);
        });else _this2.updateFloat(e.target.getBoundingClientRect ? e.target : undefined);
      };

      potentialScrollers.forEach(function (el) {
        return el.addEventListener('scroll', _this2.scrollHandler);
      });
    }
  }

  _createClass(MenuBarView, [{
    key: "update",
    value: function update() {
      this.contentUpdate(this.editorView.state);

      if (this.floating) {
        this.updateScrollCursor();
      } else {
        if (this.menu.offsetWidth != this.widthForMaxHeight) {
          this.widthForMaxHeight = this.menu.offsetWidth;
          this.maxHeight = 0;
        }

        if (this.menu.offsetHeight > this.maxHeight) {
          this.maxHeight = this.menu.offsetHeight;
          this.menu.style.minHeight = this.maxHeight + "px";
        }
      }
    }
  }, {
    key: "updateScrollCursor",
    value: function updateScrollCursor() {
      var selection = this.editorView.root.getSelection();
      if (!selection.focusNode) return;
      var rects = selection.getRangeAt(0).getClientRects();
      var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
      if (!selRect) return;
      var menuRect = this.menu.getBoundingClientRect();

      if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
        var scrollable = findWrappingScrollable(this.wrapper);
        if (scrollable) scrollable.scrollTop -= menuRect.bottom - selRect.top;
      }
    }
  }, {
    key: "updateFloat",
    value: function updateFloat(scrollAncestor) {
      var parent = this.wrapper,
          editorRect = parent.getBoundingClientRect(),
          top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;

      if (this.floating) {
        if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
          this.floating = false;
          this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
          this.menu.style.display = "";
          this.spacer.parentNode.removeChild(this.spacer);
          this.spacer = null;
        } else {
          var border = (parent.offsetWidth - parent.clientWidth) / 2;
          this.menu.style.left = editorRect.left + border + "px";
          this.menu.style.display = editorRect.top > window.innerHeight ? "none" : "";
          if (scrollAncestor) this.menu.style.top = top + "px";
        }
      } else {
        if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
          this.floating = true;
          var menuRect = this.menu.getBoundingClientRect();
          this.menu.style.left = menuRect.left + "px";
          this.menu.style.width = menuRect.width + "px";
          if (scrollAncestor) this.menu.style.top = top + "px";
          this.menu.style.position = "fixed";
          this.spacer = crel__default["default"]("div", {
            "class": prefix + "-spacer",
            style: "height: ".concat(menuRect.height, "px")
          });
          parent.insertBefore(this.spacer, this.menu);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.wrapper.parentNode) this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
    }
  }]);

  return MenuBarView;
}();

function selectionIsInverted(selection) {
  if (selection.anchorNode == selection.focusNode) return selection.anchorOffset > selection.focusOffset;
  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;
}

function findWrappingScrollable(node) {
  for (var cur = node.parentNode; cur; cur = cur.parentNode) {
    if (cur.scrollHeight > cur.clientHeight) return cur;
  }
}

function getAllWrapping(node) {
  var res = [window];

  for (var cur = node.parentNode; cur; cur = cur.parentNode) {
    res.push(cur);
  }

  return res;
}

exports.Dropdown = Dropdown;
exports.DropdownSubmenu = DropdownSubmenu;
exports.MenuItem = MenuItem;
exports.blockTypeItem = blockTypeItem;
exports.icons = icons;
exports.joinUpItem = joinUpItem;
exports.liftItem = liftItem;
exports.menuBar = menuBar;
exports.redoItem = redoItem;
exports.renderGrouped = renderGrouped;
exports.selectParentNodeItem = selectParentNodeItem;
exports.undoItem = undoItem;
exports.wrapItem = wrapItem;


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var OrderedMap = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var OrderedMap__default = _interopDefaultLegacy(OrderedMap);

function _findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;
    var childA = a.child(i),
        childB = b.child(i);

    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }

    if (!childA.sameMarkup(childB)) return pos;

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }

      return pos;
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffStart(childA.content, childB.content, pos + 1);

      if (inner != null) return inner;
    }

    pos += childA.nodeSize;
  }
}

function _findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0) return iA == iB ? null : {
      a: posA,
      b: posB
    };
    var childA = a.child(--iA),
        childB = b.child(--iB),
        size = childA.nodeSize;

    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }

    if (!childA.sameMarkup(childB)) return {
      a: posA,
      b: posB
    };

    if (childA.isText && childA.text != childB.text) {
      var same = 0,
          minSize = Math.min(childA.text.length, childB.text.length);

      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }

      return {
        a: posA,
        b: posB
      };
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);

      if (inner) return inner;
    }

    posA -= size;
    posB -= size;
  }
}

var Fragment = function () {
  function Fragment(content, size) {
    _classCallCheck(this, Fragment);

    this.content = content;
    this.size = size || 0;
    if (size == null) for (var i = 0; i < content.length; i++) {
      this.size += content[i].nodeSize;
    }
  }

  _createClass(Fragment, [{
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parent = arguments.length > 4 ? arguments[4] : undefined;

      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }

        pos = end;
      }
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      var text = "",
          separated = true;
      this.nodesBetween(from, to, function (node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf) {
          if (leafText) {
            text += typeof leafText === "function" ? leafText(node) : leafText;
          } else if (node.type.spec.leafText) {
            text += node.type.spec.leafText(node);
          }

          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    }
  }, {
    key: "append",
    value: function append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      var last = this.lastChild,
          first = other.firstChild,
          content = this.content.slice(),
          i = 0;

      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }

      for (; i < other.content.length; i++) {
        content.push(other.content[i]);
      }

      return new Fragment(content, this.size + other.size);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      if (from == 0 && to == this.size) return this;
      var result = [],
          size = 0;
      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }

          result.push(child);
          size += child.nodeSize;
        }

        pos = end;
      }
      return new Fragment(result, size);
    }
  }, {
    key: "cutByIndex",
    value: function cutByIndex(from, to) {
      if (from == to) return Fragment.empty;
      if (from == 0 && to == this.content.length) return this;
      return new Fragment(this.content.slice(from, to));
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) return this;
      var copy = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy[index] = node;
      return new Fragment(copy, size);
    }
  }, {
    key: "addToStart",
    value: function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
  }, {
    key: "addToEnd",
    value: function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this.content.length != other.content.length) return false;

      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) return false;
      }

      return true;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.length ? this.content[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.length;
    }
  }, {
    key: "child",
    value: function child(index) {
      var found = this.content[index];
      if (!found) throw new RangeError("Index " + index + " out of range for " + this);
      return found;
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content[index] || null;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
  }, {
    key: "findDiffStart",
    value: function findDiffStart(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return _findDiffStart(this, other, pos);
    }
  }, {
    key: "findDiffEnd",
    value: function findDiffEnd(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;
      return _findDiffEnd(this, other, pos, otherPos);
    }
  }, {
    key: "findIndex",
    value: function findIndex(pos) {
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0) throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));

      for (var i = 0, curPos = 0;; i++) {
        var cur = this.child(i),
            end = curPos + cur.nodeSize;

        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }

        curPos = end;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "<" + this.toStringInner() + ">";
    }
  }, {
    key: "toStringInner",
    value: function toStringInner() {
      return this.content.join(", ");
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.content.length ? this.content.map(function (n) {
        return n.toJSON();
      }) : null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, value) {
      if (!value) return Fragment.empty;
      if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      if (!array.length) return Fragment.empty;
      var joined,
          size = 0;

      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;

        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }

      return new Fragment(joined || array, size);
    }
  }, {
    key: "from",
    value: function from(nodes) {
      if (!nodes) return Fragment.empty;
      if (nodes instanceof Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }]);

  return Fragment;
}();

Fragment.empty = new Fragment([], 0);
var found = {
  index: 0,
  offset: 0
};

function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}

function compareDeep(a, b) {
  if (a === b) return true;
  if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) return false;

  if (array) {
    if (a.length != b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) return false;
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep(a[p], b[p])) return false;
    }

    for (var _p in b) {
      if (!(_p in a)) return false;
    }
  }

  return true;
}

var Mark = function () {
  function Mark(type, attrs) {
    _classCallCheck(this, Mark);

    this.type = type;
    this.attrs = attrs;
  }

  _createClass(Mark, [{
    key: "addToSet",
    value: function addToSet(set) {
      var copy,
          placed = false;

      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) return set;

        if (this.type.excludes(other.type)) {
          if (!copy) copy = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy) copy = set.slice(0, i);
            copy.push(this);
            placed = true;
          }

          if (copy) copy.push(other);
        }
      }

      if (!copy) copy = set.slice();
      if (!placed) copy.push(this);
      return copy;
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return true;
      }

      return false;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      var type = schema.marks[json.type];
      if (!type) throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
      return type.create(json.attrs);
    }
  }, {
    key: "sameSet",
    value: function sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) return false;
      }

      return true;
    }
  }, {
    key: "setFrom",
    value: function setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;
      if (marks instanceof Mark) return [marks];
      var copy = marks.slice();
      copy.sort(function (a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy;
    }
  }]);

  return Mark;
}();

Mark.none = [];

var ReplaceError = function (_Error) {
  _inherits(ReplaceError, _Error);

  var _super = _createSuper(ReplaceError);

  function ReplaceError() {
    _classCallCheck(this, ReplaceError);

    return _super.apply(this, arguments);
  }

  return _createClass(ReplaceError);
}(_wrapNativeSuper(Error));

var Slice = function () {
  function Slice(content, openStart, openEnd) {
    _classCallCheck(this, Slice);

    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }

  _createClass(Slice, [{
    key: "size",
    get: function get() {
      return this.content.size - this.openStart - this.openEnd;
    }
  }, {
    key: "insertAt",
    value: function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    }
  }, {
    key: "removeBetween",
    value: function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (!this.content.size) return null;
      var json = {
        content: this.content.toJSON()
      };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) return Slice.empty;
      var openStart = json.openStart || 0,
          openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
  }, {
    key: "maxOpen",
    value: function maxOpen(fragment) {
      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var openStart = 0,
          openEnd = 0;

      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }

      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) {
        openEnd++;
      }

      return new Slice(fragment, openStart, openEnd);
    }
  }]);

  return Slice;
}();

Slice.empty = new Slice(Fragment.empty, 0, 0);

function removeRange(content, from, to) {
  var _content$findIndex = content.findIndex(from),
      index = _content$findIndex.index,
      offset = _content$findIndex.offset,
      child = content.maybeChild(index);

  var _content$findIndex2 = content.findIndex(to),
      indexTo = _content$findIndex2.index,
      offsetTo = _content$findIndex2.offset;

  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }

  if (index != indexTo) throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}

function insertInto(content, dist, insert, parent) {
  var _content$findIndex3 = content.findIndex(dist),
      index = _content$findIndex3.index,
      offset = _content$findIndex3.offset,
      child = content.maybeChild(index);

  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }

  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}

function _replace($from, $to, slice) {
  if (slice.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth),
      node = $from.node(depth);

  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent,
        content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),
        start = _prepareSliceForRepla.start,
        end = _prepareSliceForRepla.end;

    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0,
      endIndex = $end ? $end.index(depth) : node.childCount;

  if ($start) {
    startIndex = $start.index(depth);

    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }

  for (var i = startIndex; i < endIndex; i++) {
    addNode(node.child(i), target);
  }

  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
}

function close(node, content) {
  if (!node.type.validContent(content)) throw new ReplaceError("Invalid content for node " + node.type.name);
  return node.copy(content);
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content = [];
  addRange(null, $from, depth, content);

  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);

  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart,
      parent = $along.node(extra);
  var node = parent.copy(slice.content);

  for (var i = extra - 1; i >= 0; i--) {
    node = $along.node(i).copy(Fragment.from(node));
  }

  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}

var ResolvedPos = function () {
  function ResolvedPos(pos, path, parentOffset) {
    _classCallCheck(this, ResolvedPos);

    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }

  _createClass(ResolvedPos, [{
    key: "resolveDepth",
    value: function resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.node(this.depth);
    }
  }, {
    key: "doc",
    get: function get() {
      return this.node(0);
    }
  }, {
    key: "node",
    value: function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
  }, {
    key: "index",
    value: function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
  }, {
    key: "indexAfter",
    value: function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
  }, {
    key: "start",
    value: function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
  }, {
    key: "end",
    value: function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
  }, {
    key: "before",
    value: function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
  }, {
    key: "after",
    value: function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
  }, {
    key: "textOffset",
    get: function get() {
      return this.pos - this.path[this.path.length - 1];
    }
  }, {
    key: "nodeAfter",
    get: function get() {
      var parent = this.parent,
          index = this.index(this.depth);
      if (index == parent.childCount) return null;
      var dOff = this.pos - this.path[this.path.length - 1],
          child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
  }, {
    key: "nodeBefore",
    get: function get() {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
  }, {
    key: "posAtIndex",
    value: function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3],
          pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;

      for (var i = 0; i < index; i++) {
        pos += node.child(i).nodeSize;
      }

      return pos;
    }
  }, {
    key: "marks",
    value: function marks() {
      var parent = this.parent,
          index = this.index();
      if (parent.content.size == 0) return Mark.none;
      if (this.textOffset) return parent.child(index).marks;
      var main = parent.maybeChild(index - 1),
          other = parent.maybeChild(index);

      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }

      var marks = main.marks;

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "marksAcross",
    value: function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      var marks = after.marks,
          next = $end.parent.maybeChild($end.index());

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "sharedDepth",
    value: function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      }

      return 0;
    }
  }, {
    key: "blockRange",
    value: function blockRange() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      var pred = arguments.length > 1 ? arguments[1] : undefined;
      if (other.pos < this.pos) return other.blockRange(this);

      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
      }

      return null;
    }
  }, {
    key: "sameParent",
    value: function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
  }, {
    key: "max",
    value: function max(other) {
      return other.pos > this.pos ? other : this;
    }
  }, {
    key: "min",
    value: function min(other) {
      return other.pos < this.pos ? other : this;
    }
  }, {
    key: "toString",
    value: function toString() {
      var str = "";

      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }

      return str + ":" + this.parentOffset;
    }
  }], [{
    key: "resolve",
    value: function resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError("Position " + pos + " out of range");
      var path = [];
      var start = 0,
          parentOffset = pos;

      for (var node = doc;;) {
        var _node$content$findInd = node.content.findIndex(parentOffset),
            index = _node$content$findInd.index,
            offset = _node$content$findInd.offset;

        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }

      return new ResolvedPos(pos, path, parentOffset);
    }
  }, {
    key: "resolveCached",
    value: function resolveCached(doc, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) return cached;
      }

      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  }]);

  return ResolvedPos;
}();

var resolveCache = [],
    resolveCachePos = 0,
    resolveCacheSize = 12;

var NodeRange = function () {
  function NodeRange($from, $to, depth) {
    _classCallCheck(this, NodeRange);

    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }

  _createClass(NodeRange, [{
    key: "start",
    get: function get() {
      return this.$from.before(this.depth + 1);
    }
  }, {
    key: "end",
    get: function get() {
      return this.$to.after(this.depth + 1);
    }
  }, {
    key: "parent",
    get: function get() {
      return this.$from.node(this.depth);
    }
  }, {
    key: "startIndex",
    get: function get() {
      return this.$from.index(this.depth);
    }
  }, {
    key: "endIndex",
    get: function get() {
      return this.$to.indexAfter(this.depth);
    }
  }]);

  return NodeRange;
}();

var emptyAttrs = Object.create(null);

var Node = function () {
  function Node(type, attrs, content) {
    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;

    _classCallCheck(this, Node);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }

  _createClass(Node, [{
    key: "nodeSize",
    get: function get() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.childCount;
    }
  }, {
    key: "child",
    value: function child(index) {
      return this.content.child(index);
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content.maybeChild(index);
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      this.content.forEach(f);
    }
  }, {
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.firstChild;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.lastChild;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
  }, {
    key: "sameMarkup",
    value: function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
  }, {
    key: "hasMarkup",
    value: function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
  }, {
    key: "copy",
    value: function copy() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (content == this.content) return this;
      return new Node(this.type, this.attrs, content, this.marks);
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      if (from == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from, to));
    }
  }, {
    key: "slice",
    value: function slice(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (from == to) return Slice.empty;
      var $from = this.resolve(from),
          $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth),
          node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
  }, {
    key: "replace",
    value: function replace(from, to, slice) {
      return _replace(this.resolve(from), this.resolve(to), slice);
    }
  }, {
    key: "nodeAt",
    value: function nodeAt(pos) {
      for (var node = this;;) {
        var _node$content$findInd2 = node.content.findIndex(pos),
            index = _node$content$findInd2.index,
            offset = _node$content$findInd2.offset;

        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    }
  }, {
    key: "childAfter",
    value: function childAfter(pos) {
      var _this$content$findInd = this.content.findIndex(pos),
          index = _this$content$findInd.index,
          offset = _this$content$findInd.offset;

      return {
        node: this.content.maybeChild(index),
        index: index,
        offset: offset
      };
    }
  }, {
    key: "childBefore",
    value: function childBefore(pos) {
      if (pos == 0) return {
        node: null,
        index: 0,
        offset: 0
      };

      var _this$content$findInd2 = this.content.findIndex(pos),
          index = _this$content$findInd2.index,
          offset = _this$content$findInd2.offset;

      if (offset < pos) return {
        node: this.content.child(index),
        index: index,
        offset: offset
      };
      var node = this.content.child(index - 1);
      return {
        node: node,
        index: index - 1,
        offset: offset - node.nodeSize
      };
    }
  }, {
    key: "resolve",
    value: function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
  }, {
    key: "resolveNoCache",
    value: function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
  }, {
    key: "rangeHasMark",
    value: function rangeHasMark(from, to, type) {
      var found = false;
      if (to > from) this.nodesBetween(from, to, function (node) {
        if (type.isInSet(node.marks)) found = true;
        return !found;
      });
      return found;
    }
  }, {
    key: "isBlock",
    get: function get() {
      return this.type.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.type.isTextblock;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.type.inlineContent;
    }
  }, {
    key: "isInline",
    get: function get() {
      return this.type.isInline;
    }
  }, {
    key: "isText",
    get: function get() {
      return this.type.isText;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.type.isLeaf;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.type.isAtom;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      var name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
  }, {
    key: "contentMatchAt",
    value: function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
  }, {
    key: "canReplace",
    value: function canReplace(from, to) {
      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;
      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;
      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;

      for (var i = start; i < end; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "canReplaceWith",
    value: function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
  }, {
    key: "canAppend",
    value: function canAppend(other) {
      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);
    }
  }, {
    key: "check",
    value: function check() {
      if (!this.type.validContent(this.content)) throw new RangeError("Invalid content for node ".concat(this.type.name, ": ").concat(this.content.toString().slice(0, 50)));
      var copy = Mark.none;

      for (var i = 0; i < this.marks.length; i++) {
        copy = this.marks[i].addToSet(copy);
      }

      if (!Mark.sameSet(copy, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function (m) {
        return m.type.name;
      })));
      this.content.forEach(function (node) {
        return node.check();
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map(function (n) {
        return n.toJSON();
      });
      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      var marks = null;

      if (json.marks) {
        if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }

      if (json.type == "text") {
        if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }

      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  }]);

  return Node;
}();

Node.prototype.text = undefined;

var TextNode = function (_Node) {
  _inherits(TextNode, _Node);

  var _super2 = _createSuper(TextNode);

  function TextNode(type, attrs, content, marks) {
    var _this;

    _classCallCheck(this, TextNode);

    _this = _super2.call(this, type, attrs, null, marks);
    if (!content) throw new RangeError("Empty text nodes are not allowed");
    _this.text = content;
    return _this;
  }

  _createClass(TextNode, [{
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.text;
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to) {
      return this.text.slice(from, to);
    }
  }, {
    key: "nodeSize",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
  }, {
    key: "withText",
    value: function withText(text) {
      if (text == this.text) return this;
      return new TextNode(this.type, this.attrs, text, this.marks);
    }
  }, {
    key: "cut",
    value: function cut() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;
      if (from == 0 && to == this.text.length) return this;
      return this.withText(this.text.slice(from, to));
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var base = _get(_getPrototypeOf(TextNode.prototype), "toJSON", this).call(this);

      base.text = this.text;
      return base;
    }
  }]);

  return TextNode;
}(Node);

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--) {
    str = marks[i].type.name + "(" + str + ")";
  }

  return str;
}

var ContentMatch = function () {
  function ContentMatch(validEnd) {
    _classCallCheck(this, ContentMatch);

    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }

  _createClass(ContentMatch, [{
    key: "matchType",
    value: function matchType(type) {
      for (var i = 0; i < this.next.length; i++) {
        if (this.next[i].type == type) return this.next[i].next;
      }

      return null;
    }
  }, {
    key: "matchFragment",
    value: function matchFragment(frag) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;
      var cur = this;

      for (var i = start; cur && i < end; i++) {
        cur = cur.matchType(frag.child(i).type);
      }

      return cur;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.next.length && this.next[0].type.isInline;
    }
  }, {
    key: "defaultType",
    get: function get() {
      for (var i = 0; i < this.next.length; i++) {
        var type = this.next[i].type;
        if (!(type.isText || type.hasRequiredAttrs())) return type;
      }

      return null;
    }
  }, {
    key: "compatible",
    value: function compatible(other) {
      for (var i = 0; i < this.next.length; i++) {
        for (var j = 0; j < other.next.length; j++) {
          if (this.next[i].type == other.next[j].type) return true;
        }
      }

      return false;
    }
  }, {
    key: "fillBefore",
    value: function fillBefore(after) {
      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seen = [this];

      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {
          return tp.createAndFill();
        }));

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i = match.next[i],
              type = _match$next$i.type,
              next = _match$next$i.next;

          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);

            var _found = search(next, types.concat(type));

            if (_found) return _found;
          }
        }

        return null;
      }

      return search(this, []);
    }
  }, {
    key: "findWrapping",
    value: function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
      }

      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
  }, {
    key: "computeWrapping",
    value: function computeWrapping(target) {
      var seen = Object.create(null),
          active = [{
        match: this,
        type: null,
        via: null
      }];

      while (active.length) {
        var current = active.shift(),
            match = current.match;

        if (match.matchType(target)) {
          var result = [];

          for (var obj = current; obj.type; obj = obj.via) {
            result.push(obj.type);
          }

          return result.reverse();
        }

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i2 = match.next[i],
              type = _match$next$i2.type,
              next = _match$next$i2.next;

          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({
              match: type.contentMatch,
              type: type,
              via: current
            });
            seen[type.name] = true;
          }
        }
      }

      return null;
    }
  }, {
    key: "edgeCount",
    get: function get() {
      return this.next.length;
    }
  }, {
    key: "edge",
    value: function edge(n) {
      if (n >= this.next.length) throw new RangeError("There's no ".concat(n, "th edge in this content match"));
      return this.next[n];
    }
  }, {
    key: "toString",
    value: function toString() {
      var seen = [];

      function scan(m) {
        seen.push(m);

        for (var i = 0; i < m.next.length; i++) {
          if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
        }
      }

      scan(this);
      return seen.map(function (m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";

        for (var _i = 0; _i < m.next.length; _i++) {
          out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
        }

        return out;
      }).join("\n");
    }
  }], [{
    key: "parse",
    value: function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return ContentMatch.empty;
      var expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
  }]);

  return ContentMatch;
}();

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function () {
  function TokenStream(string, nodeTypes) {
    _classCallCheck(this, TokenStream);

    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
    if (this.tokens[0] == "") this.tokens.shift();
  }

  _createClass(TokenStream, [{
    key: "next",
    get: function get() {
      return this.tokens[this.pos];
    }
  }, {
    key: "eat",
    value: function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
  }, {
    key: "err",
    value: function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }]);

  return TokenStream;
}();

function parseExpr(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));

  return exprs.length == 1 ? exprs[0] : {
    type: "choice",
    exprs: exprs
  };
}

function parseExprSeq(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");

  return exprs.length == 1 ? exprs[0] : {
    type: "seq",
    exprs: exprs
  };
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);

  for (;;) {
    if (stream.eat("+")) expr = {
      type: "plus",
      expr: expr
    };else if (stream.eat("*")) expr = {
      type: "star",
      expr: expr
    };else if (stream.eat("?")) expr = {
      type: "opt",
      expr: expr
    };else if (stream.eat("{")) expr = parseExprRange(stream, expr);else break;
  }

  return expr;
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
  var result = Number(stream.next);
  stream.pos++;
  return result;
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream),
      max = min;

  if (stream.eat(",")) {
    if (stream.next != "}") max = parseNum(stream);else max = -1;
  }

  if (!stream.eat("}")) stream.err("Unclosed braced range");
  return {
    type: "range",
    min: min,
    max: max,
    expr: expr
  };
}

function resolveName(stream, name) {
  var types = stream.nodeTypes,
      type = types[name];
  if (type) return [type];
  var result = [];

  for (var typeName in types) {
    var _type = types[typeName];
    if (_type.groups.indexOf(name) > -1) result.push(_type);
  }

  if (result.length == 0) stream.err("No node type or group '" + name + "' found");
  return result;
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
      return {
        type: "name",
        value: type
      };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {
      type: "choice",
      exprs: exprs
    };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa;

  function node() {
    return nfa.push([]) - 1;
  }

  function edge(from, to, term) {
    var edge = {
      term: term,
      to: to
    };
    nfa[from].push(edge);
    return edge;
  }

  function connect(edges, to) {
    edges.forEach(function (edge) {
      return edge.to = to;
    });
  }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) {
        return out.concat(compile(expr, from));
      }, []);
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) return next;
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)];
    } else if (expr.type == "plus") {
      var _loop = node();

      connect(compile(expr.expr, from), _loop);
      connect(compile(expr.expr, _loop), _loop);
      return [edge(_loop)];
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from));
    } else if (expr.type == "range") {
      var cur = from;

      for (var _i2 = 0; _i2 < expr.min; _i2++) {
        var _next = node();

        connect(compile(expr.expr, cur), _next);
        cur = _next;
      }

      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {
          var _next2 = node();

          edge(cur, _next2);
          connect(compile(expr.expr, cur), _next2);
          cur = _next2;
        }
      }

      return [edge(cur)];
    } else if (expr.type == "name") {
      return [edge(from, undefined, expr.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}

function cmp(a, b) {
  return b - a;
}

function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp);

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
    result.push(node);

    for (var i = 0; i < edges.length; i++) {
      var _edges$i = edges[i],
          term = _edges$i.term,
          to = _edges$i.to;
      if (!term && result.indexOf(to) == -1) scan(to);
    }
  }
}

function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0));

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (_ref) {
        var term = _ref.term,
            to = _ref.to;
        if (!term) return;
        var set;

        for (var i = 0; i < out.length; i++) {
          if (out[i][0] == term) set = out[i][1];
        }

        nullFrom(nfa, to).forEach(function (node) {
          if (!set) out.push([term, set = []]);
          if (set.indexOf(node) == -1) set.push(node);
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);

    for (var i = 0; i < out.length; i++) {
      var _states = out[i][1].sort(cmp);

      state.next.push({
        type: out[i][0],
        next: labeled[_states.join(",")] || explore(_states)
      });
    }

    return state;
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i],
        dead = !state.validEnd,
        nodes = [];

    for (var j = 0; j < state.next.length; j++) {
      var _state$next$j = state.next[j],
          type = _state$next$j.type,
          next = _state$next$j.next;
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
      if (work.indexOf(next) == -1) work.push(next);
    }

    if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}

function defaultAttrs(attrs) {
  var defaults = Object.create(null);

  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) return null;
    defaults[attrName] = attr["default"];
  }

  return defaults;
}

function _computeAttrs(attrs, value) {
  var built = Object.create(null);

  for (var name in attrs) {
    var given = value && value[name];

    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) given = attr["default"];else throw new RangeError("No value supplied for attribute " + name);
    }

    built[name] = given;
  }

  return built;
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) for (var name in attrs) {
    result[name] = new Attribute(attrs[name]);
  }
  return result;
}

var NodeType = function () {
  function NodeType(name, schema, spec) {
    _classCallCheck(this, NodeType);

    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }

  _createClass(NodeType, [{
    key: "isInline",
    get: function get() {
      return !this.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.isBlock && this.inlineContent;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.contentMatch == ContentMatch.empty;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.isLeaf || !!this.spec.atom;
    }
  }, {
    key: "whitespace",
    get: function get() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
  }, {
    key: "hasRequiredAttrs",
    value: function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) return true;
      }

      return false;
    }
  }, {
    key: "compatibleContent",
    value: function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
  }, {
    key: "computeAttrs",
    value: function computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);
    }
  }, {
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
  }, {
    key: "createChecked",
    value: function createChecked() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      content = Fragment.from(content);
      if (!this.validContent(content)) throw new RangeError("Invalid content for node " + this.name);
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
  }, {
    key: "createAndFill",
    value: function createAndFill() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);

      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) return null;
        content = before.append(content);
      }

      var matched = this.contentMatch.matchFragment(content);
      var after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after) return null;
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    }
  }, {
    key: "validContent",
    value: function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) return false;

      for (var i = 0; i < content.childCount; i++) {
        if (!this.allowsMarks(content.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "allowsMarkType",
    value: function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
  }, {
    key: "allowsMarks",
    value: function allowsMarks(marks) {
      if (this.markSet == null) return true;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) return false;
      }

      return true;
    }
  }, {
    key: "allowedMarks",
    value: function allowedMarks(marks) {
      if (this.markSet == null) return marks;
      var copy;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy) copy = marks.slice(0, i);
        } else if (copy) {
          copy.push(marks[i]);
        }
      }

      return !copy ? marks : copy.length ? copy : Mark.none;
    }
  }], [{
    key: "compile",
    value: function compile(nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function (name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text) throw new RangeError("Every schema needs a 'text' type");

      for (var _ in result.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }

      return result;
    }
  }]);

  return NodeType;
}();

var Attribute = function () {
  function Attribute(options) {
    _classCallCheck(this, Attribute);

    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this["default"] = options["default"];
  }

  _createClass(Attribute, [{
    key: "isRequired",
    get: function get() {
      return !this.hasDefault;
    }
  }]);

  return Attribute;
}();

var MarkType = function () {
  function MarkType(name, rank, schema, spec) {
    _classCallCheck(this, MarkType);

    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    var defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }

  _createClass(MarkType, [{
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!attrs && this.instance) return this.instance;
      return new Mark(this, _computeAttrs(this.attrs, attrs));
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) return set[i];
      }
    }
  }, {
    key: "excludes",
    value: function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }], [{
    key: "compile",
    value: function compile(marks, schema) {
      var result = Object.create(null),
          rank = 0;
      marks.forEach(function (name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    }
  }]);

  return MarkType;
}();

var Schema = function () {
  function Schema(spec) {
    _classCallCheck(this, Schema);

    this.cached = Object.create(null);
    this.spec = {
      nodes: OrderedMap__default["default"].from(spec.nodes),
      marks: OrderedMap__default["default"].from(spec.marks || {}),
      topNode: spec.topNode
    };
    this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = Object.create(null);

    for (var prop in this.nodes) {
      if (prop in this.marks) throw new RangeError(prop + " can not be both a node and a mark");
      var type = this.nodes[prop],
          contentExpr = type.spec.content || "",
          markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }

    for (var _prop in this.marks) {
      var _type2 = this.marks[_prop],
          excl = _type2.spec.excludes;
      _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = Object.create(null);
  }

  _createClass(Schema, [{
    key: "node",
    value: function node(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError("Invalid node type: " + type);else if (type.schema != this) throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
  }, {
    key: "text",
    value: function text(_text, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));
    }
  }, {
    key: "mark",
    value: function mark(type, attrs) {
      if (typeof type == "string") type = this.marks[type];
      return type.create(attrs);
    }
  }, {
    key: "nodeFromJSON",
    value: function nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    }
  }, {
    key: "markFromJSON",
    value: function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
  }, {
    key: "nodeType",
    value: function nodeType(name) {
      var found = this.nodes[name];
      if (!found) throw new RangeError("Unknown node type: " + name);
      return found;
    }
  }]);

  return Schema;
}();

function gatherMarks(schema, marks) {
  var found = [];

  for (var i = 0; i < marks.length; i++) {
    var name = marks[i],
        mark = schema.marks[name],
        ok = mark;

    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var _mark = schema.marks[prop];
        if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1) found.push(ok = _mark);
      }
    }

    if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }

  return found;
}

var DOMParser = function () {
  function DOMParser(schema, rules) {
    var _this2 = this;

    _classCallCheck(this, DOMParser);

    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach(function (rule) {
      if (rule.tag) _this2.tags.push(rule);else if (rule.style) _this2.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some(function (r) {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
      var node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }

  _createClass(DOMParser, [{
    key: "parse",
    value: function parse(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
  }, {
    key: "parseSlice",
    value: function parseSlice(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
  }, {
    key: "matchTag",
    value: function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];

        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || undefined;
          }

          return rule;
        }
      }
    }
  }, {
    key: "matchStyle",
    value: function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i],
            style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;

        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || undefined;
        }

        return rule;
      }
    }
  }], [{
    key: "schemaRules",
    value: function schemaRules(schema) {
      var result = [];

      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority,
            i = 0;

        for (; i < result.length; i++) {
          var next = result[i],
              nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }

        result.splice(i, 0, rule);
      }

      var _loop2 = function _loop2(name) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.mark = name;
        });
      };

      for (var name in schema.marks) {
        _loop2(name);
      }

      var _loop3 = function _loop3(_name) {
        var rules = schema.nodes[_name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.node = _name;
        });
      };

      for (var _name in schema.nodes) {
        _loop3(_name);
      }

      return result;
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    }
  }]);

  return DOMParser;
}();

var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = {
  ol: true,
  ul: true
};
var OPT_PRESERVE_WS = 1,
    OPT_PRESERVE_WS_FULL = 2,
    OPT_OPEN_LEFT = 4;

function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}

var NodeContext = function () {
  function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
    _classCallCheck(this, NodeContext);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }

  _createClass(NodeContext, [{
    key: "findWrapping",
    value: function findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));

        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch,
              wrap;

          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }

      return this.match.findWrapping(node.type);
    }
  }, {
    key: "finish",
    value: function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1],
            m;

        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          var text = last;
          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }

      var content = Fragment.from(this.content);
      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
  }, {
    key: "popFromStashMark",
    value: function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];
      }
    }
  }, {
    key: "applyPending",
    value: function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];

        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
  }, {
    key: "inlineContext",
    value: function inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  }]);

  return NodeContext;
}();

var ParseContext = function () {
  function ParseContext(parser, options, isOpen) {
    _classCallCheck(this, ParseContext);

    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    var topNode = options.topNode,
        topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }

  _createClass(ParseContext, [{
    key: "top",
    get: function get() {
      return this.nodes[this.open];
    }
  }, {
    key: "addDOM",
    value: function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks = style ? this.readStyles(parseStyles(style)) : null,
            top = this.top;
        if (marks != null) for (var i = 0; i < marks.length; i++) {
          this.addPendingMark(marks[i]);
        }
        this.addElement(dom);
        if (marks != null) for (var _i4 = 0; _i4 < marks.length; _i4++) {
          this.removePendingMark(marks[_i4], top);
        }
      }
    }
  }, {
    key: "addTextNode",
    value: function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;

      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");

          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }

        if (value) this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
  }, {
    key: "addElement",
    value: function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(),
          ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));

      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;
        var sync,
            top = this.top,
            oldNeedsBlock = this.needsBlock;

        if (blockTags.hasOwnProperty(name)) {
          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }

        this.addAll(dom);
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);
      }
    }
  }, {
    key: "leafFallback",
    value: function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
  }, {
    key: "ignoreFallback",
    value: function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"));
    }
  }, {
    key: "readStyles",
    value: function readStyles(styles) {
      var marks = Mark.none;

      style: for (var i = 0; i < styles.length; i += 2) {
        for (var after = undefined;;) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
          if (!rule) continue style;
          if (rule.ignore) return null;
          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
          if (rule.consuming === false) after = rule;else break;
        }
      }

      return marks;
    }
  }, {
    key: "addElementByRule",
    value: function addElementByRule(dom, rule, continueAfter) {
      var _this3 = this;

      var sync, nodeType, mark;

      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];

        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        var markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }

      var startIn = this.top;

      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) {
          return _this3.insertNode(node);
        });
      } else {
        var contentDOM = dom;
        if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }

      if (sync && this.sync(startIn)) this.open--;
      if (mark) this.removePendingMark(mark, startIn);
    }
  }, {
    key: "addAll",
    value: function addAll(parent, startIndex, endIndex) {
      var index = startIndex || 0;

      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }

      this.findAtPoint(parent, index);
    }
  }, {
    key: "findPlace",
    value: function findPlace(node) {
      var route, sync;

      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];

        var _found2 = cx.findWrapping(node);

        if (_found2 && (!route || route.length > _found2.length)) {
          route = _found2;
          sync = cx;
          if (!_found2.length) break;
        }

        if (cx.solid) break;
      }

      if (!route) return false;
      this.sync(sync);

      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }

      return true;
    }
  }, {
    key: "insertNode",
    value: function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) this.enterInner(block);
      }

      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) top.match = top.match.matchType(node.type);
        var marks = top.activeMarks;

        for (var i = 0; i < node.marks.length; i++) {
          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);
        }

        top.content.push(node.mark(marks));
        return true;
      }

      return false;
    }
  }, {
    key: "enter",
    value: function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
  }, {
    key: "enterInner",
    value: function enterInner(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var solid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var preserveWS = arguments.length > 3 ? arguments[3] : undefined;
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      var options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
  }, {
    key: "closeExtra",
    value: function closeExtra() {
      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var i = this.nodes.length - 1;

      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }

        this.nodes.length = this.open + 1;
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
  }, {
    key: "sync",
    value: function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      }

      return false;
    }
  }, {
    key: "currentPos",
    get: function get() {
      this.closeExtra();
      var pos = 0;

      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;

        for (var j = content.length - 1; j >= 0; j--) {
          pos += content[j].nodeSize;
        }

        if (i) pos++;
      }

      return pos;
    }
  }, {
    key: "findAtPoint",
    value: function findAtPoint(parent, offset) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findInside",
    value: function findInside(parent) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findAround",
    value: function findAround(parent, content, before) {
      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
        }
      }
    }
  }, {
    key: "findInText",
    value: function findInText(textNode) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }, {
    key: "matchesContext",
    value: function matchesContext(context) {
      var _this4 = this;

      if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);

      var match = function match(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];

          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;

            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) return true;
            }

            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? _this4.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;
            depth--;
          }
        }

        return true;
      };

      return match(parts.length - 1, this.open);
    }
  }, {
    key: "textblockFromContext",
    value: function textblockFromContext() {
      var $context = this.options.context;
      if ($context) for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
      }

      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    }
  }, {
    key: "addPendingMark",
    value: function addPendingMark(mark) {
      var found = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found) this.top.stashMarks.push(found);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
  }, {
    key: "removePendingMark",
    value: function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];

        var _found3 = level.pendingMarks.lastIndexOf(mark);

        if (_found3 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);
        }

        if (level == upto) break;
      }
    }
  }]);

  return ParseContext;
}();

function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;

    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}

function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
      m,
      result = [];

  while (m = re.exec(style)) {
    result.push(m[1], m[2].trim());
  }

  return result;
}

function copy(obj) {
  var copy = {};

  for (var prop in obj) {
    copy[prop] = obj[prop];
  }

  return copy;
}

function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;

  var _loop4 = function _loop4(name) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) return "continue";

    var seen = [],
        scan = function scan(match) {
      seen.push(match);

      for (var i = 0; i < match.edgeCount; i++) {
        var _match$edge = match.edge(i),
            type = _match$edge.type,
            next = _match$edge.next;

        if (type == nodeType) return true;
        if (seen.indexOf(next) < 0 && scan(next)) return true;
      }
    };

    if (scan(parent.contentMatch)) return {
      v: true
    };
  };

  for (var name in nodes) {
    var _ret = _loop4(name);

    if (_ret === "continue") continue;
    if (_typeof(_ret) === "object") return _ret.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) return set[i];
  }
}

var DOMSerializer = function () {
  function DOMSerializer(nodes, marks) {
    _classCallCheck(this, DOMSerializer);

    this.nodes = nodes;
    this.marks = marks;
  }

  _createClass(DOMSerializer, [{
    key: "serializeFragment",
    value: function serializeFragment(fragment) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 ? arguments[2] : undefined;
      if (!target) target = doc(options).createDocumentFragment();
      var top = target,
          active = [];
      fragment.forEach(function (node) {
        if (active.length || node.marks.length) {
          var keep = 0,
              rendered = 0;

          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];

            if (!_this5.marks[next.type.name]) {
              rendered++;
              continue;
            }

            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
            keep++;
            rendered++;
          }

          while (keep < active.length) {
            top = active.pop()[1];
          }

          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];

            var markDOM = _this5.serializeMark(add, node.isInline, options);

            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }

        top.appendChild(_this5.serializeNodeInner(node, options));
      });
      return target;
    }
  }, {
    key: "serializeNodeInner",
    value: function serializeNodeInner(node, options) {
      var _DOMSerializer$render = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node)),
          dom = _DOMSerializer$render.dom,
          contentDOM = _DOMSerializer$render.contentDOM;

      if (contentDOM) {
        if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }

      return dom;
    }
  }, {
    key: "serializeNode",
    value: function serializeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dom = this.serializeNodeInner(node, options);

      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);

        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }

      return dom;
    }
  }, {
    key: "serializeMark",
    value: function serializeMark(mark, inline) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    }
  }], [{
    key: "renderSpec",
    value: function renderSpec(doc, structure) {
      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof structure == "string") return {
        dom: doc.createTextNode(structure)
      };
      if (structure.nodeType != null) return {
        dom: structure
      };
      if (structure.dom && structure.dom.nodeType != null) return structure;
      var tagName = structure[0],
          space = tagName.indexOf(" ");

      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }

      var contentDOM;
      var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
      var attrs = structure[1],
          start = 1;

      if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;

        for (var name in attrs) {
          if (attrs[name] != null) {
            var _space = name.indexOf(" ");

            if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);
          }
        }
      }

      for (var i = start; i < structure.length; i++) {
        var child = structure[i];

        if (child === 0) {
          if (i < structure.length - 1 || i > start) throw new RangeError("Content hole must be the only child of its parent node");
          return {
            dom: dom,
            contentDOM: dom
          };
        } else {
          var _DOMSerializer$render2 = DOMSerializer.renderSpec(doc, child, xmlNS),
              inner = _DOMSerializer$render2.dom,
              innerContent = _DOMSerializer$render2.contentDOM;

          dom.appendChild(inner);

          if (innerContent) {
            if (contentDOM) throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }

      return {
        dom: dom,
        contentDOM: contentDOM
      };
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
  }, {
    key: "nodesFromSchema",
    value: function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) result.text = function (node) {
        return node.text;
      };
      return result;
    }
  }, {
    key: "marksFromSchema",
    value: function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }]);

  return DOMSerializer;
}();

function gatherToDOM(obj) {
  var result = {};

  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) result[name] = toDOM;
  }

  return result;
}

function doc(options) {
  return options.document || window.document;
}

exports.ContentMatch = ContentMatch;
exports.DOMParser = DOMParser;
exports.DOMSerializer = DOMSerializer;
exports.Fragment = Fragment;
exports.Mark = Mark;
exports.MarkType = MarkType;
exports.Node = Node;
exports.NodeRange = NodeRange;
exports.NodeType = NodeType;
exports.ReplaceError = ReplaceError;
exports.ResolvedPos = ResolvedPos;
exports.Schema = Schema;
exports.Slice = Slice;


/***/ }),

/***/ "./node_modules/prosemirror-schema-basic/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-schema-basic/dist/index.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var pDOM = ["p", 0],
    blockquoteDOM = ["blockquote", 0],
    hrDOM = ["hr"],
    preDOM = ["pre", ["code", 0]],
    brDOM = ["br"];
var nodes = {
  doc: {
    content: "block+"
  },
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{
      tag: "p"
    }],
    toDOM: function toDOM() {
      return pDOM;
    }
  },
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{
      tag: "blockquote"
    }],
    toDOM: function toDOM() {
      return blockquoteDOM;
    }
  },
  horizontal_rule: {
    group: "block",
    parseDOM: [{
      tag: "hr"
    }],
    toDOM: function toDOM() {
      return hrDOM;
    }
  },
  heading: {
    attrs: {
      level: {
        "default": 1
      }
    },
    content: "inline*",
    group: "block",
    defining: true,
    parseDOM: [{
      tag: "h1",
      attrs: {
        level: 1
      }
    }, {
      tag: "h2",
      attrs: {
        level: 2
      }
    }, {
      tag: "h3",
      attrs: {
        level: 3
      }
    }, {
      tag: "h4",
      attrs: {
        level: 4
      }
    }, {
      tag: "h5",
      attrs: {
        level: 5
      }
    }, {
      tag: "h6",
      attrs: {
        level: 6
      }
    }],
    toDOM: function toDOM(node) {
      return ["h" + node.attrs.level, 0];
    }
  },
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    parseDOM: [{
      tag: "pre",
      preserveWhitespace: "full"
    }],
    toDOM: function toDOM() {
      return preDOM;
    }
  },
  text: {
    group: "inline"
  },
  image: {
    inline: true,
    attrs: {
      src: {},
      alt: {
        "default": null
      },
      title: {
        "default": null
      }
    },
    group: "inline",
    draggable: true,
    parseDOM: [{
      tag: "img[src]",
      getAttrs: function getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      }
    }],
    toDOM: function toDOM(node) {
      var _node$attrs = node.attrs,
          src = _node$attrs.src,
          alt = _node$attrs.alt,
          title = _node$attrs.title;
      return ["img", {
        src: src,
        alt: alt,
        title: title
      }];
    }
  },
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{
      tag: "br"
    }],
    toDOM: function toDOM() {
      return brDOM;
    }
  }
};
var emDOM = ["em", 0],
    strongDOM = ["strong", 0],
    codeDOM = ["code", 0];
var marks = {
  link: {
    attrs: {
      href: {},
      title: {
        "default": null
      }
    },
    inclusive: false,
    parseDOM: [{
      tag: "a[href]",
      getAttrs: function getAttrs(dom) {
        return {
          href: dom.getAttribute("href"),
          title: dom.getAttribute("title")
        };
      }
    }],
    toDOM: function toDOM(node) {
      var _node$attrs2 = node.attrs,
          href = _node$attrs2.href,
          title = _node$attrs2.title;
      return ["a", {
        href: href,
        title: title
      }, 0];
    }
  },
  em: {
    parseDOM: [{
      tag: "i"
    }, {
      tag: "em"
    }, {
      style: "font-style=italic"
    }],
    toDOM: function toDOM() {
      return emDOM;
    }
  },
  strong: {
    parseDOM: [{
      tag: "strong"
    }, {
      tag: "b",
      getAttrs: function getAttrs(node) {
        return node.style.fontWeight != "normal" && null;
      }
    }, {
      style: "font-weight",
      getAttrs: function getAttrs(value) {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
      }
    }],
    toDOM: function toDOM() {
      return strongDOM;
    }
  },
  code: {
    parseDOM: [{
      tag: "code"
    }],
    toDOM: function toDOM() {
      return codeDOM;
    }
  }
};
var schema = new prosemirrorModel.Schema({
  nodes: nodes,
  marks: marks
});
exports.marks = marks;
exports.nodes = nodes;
exports.schema = schema;


/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var olDOM = ["ol", 0],
    ulDOM = ["ul", 0],
    liDOM = ["li", 0];
var orderedList = {
  attrs: {
    order: {
      "default": 1
    }
  },
  parseDOM: [{
    tag: "ol",
    getAttrs: function getAttrs(dom) {
      return {
        order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1
      };
    }
  }],
  toDOM: function toDOM(node) {
    return node.attrs.order == 1 ? olDOM : ["ol", {
      start: node.attrs.order
    }, 0];
  }
};
var bulletList = {
  parseDOM: [{
    tag: "ul"
  }],
  toDOM: function toDOM() {
    return ulDOM;
  }
};
var listItem = {
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM() {
    return liDOM;
  },
  defining: true
};

function add(obj, props) {
  var copy = {};

  for (var prop in obj) {
    copy[prop] = obj[prop];
  }

  for (var _prop in props) {
    copy[_prop] = props[_prop];
  }

  return copy;
}

function addListNodes(nodes, itemContent, listGroup) {
  return nodes.append({
    ordered_list: add(orderedList, {
      content: "list_item+",
      group: listGroup
    }),
    bullet_list: add(bulletList, {
      content: "list_item+",
      group: listGroup
    }),
    list_item: add(listItem, {
      content: itemContent
    })
  });
}

function wrapInList(listType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection = state.selection,
        $from = _state$selection.$from,
        $to = _state$selection.$to;
    var range = $from.blockRange($to),
        doJoin = false,
        outerRange = range;
    if (!range) return false;

    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0) return false;
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) range = new prosemirrorModel.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }

    var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);
    if (!wrap) return false;
    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
    return true;
  };
}

function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content = prosemirrorModel.Fragment.empty;

  for (var i = wrappers.length - 1; i >= 0; i--) {
    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
  var found = 0;

  for (var _i = 0; _i < wrappers.length; _i++) {
    if (wrappers[_i].type == listType) found = _i + 1;
  }

  var splitDepth = wrappers.length - found;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),
      parent = range.parent;

  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {
    if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }

    splitPos += parent.child(_i2).nodeSize;
  }

  return tr;
}

function splitListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection2 = state.selection,
        $from = _state$selection2.$from,
        $to = _state$selection2.$to,
        node = _state$selection2.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) return false;

    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;

      if (dispatch) {
        var wrap = prosemirrorModel.Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;

        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) {
          wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
        }

        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));
        var start = $from.before($from.depth - (depthBefore - 1));

        var _tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));

        var sel = -1;

        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {
          if (sel > -1) return false;
          if (node.isTextblock && node.content.size == 0) sel = pos + 1;
        });

        if (sel > -1) _tr.setSelection(prosemirrorState.Selection.near(_tr.doc.resolve(sel)));
        dispatch(_tr.scrollIntoView());
      }

      return true;
    }

    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr["delete"]($from.pos, $to.pos);
    var types = nextType ? [null, {
      type: nextType
    }] : undefined;
    if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types)) return false;
    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}

function liftListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection3 = state.selection,
        $from = _state$selection3.$from,
        $to = _state$selection3.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    if (!dispatch) return true;
    if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);else return liftOutOfList(state, dispatch, range);
  };
}

function liftToOuterList(state, dispatch, itemType, range) {
  var tr = state.tr,
      end = range.end,
      endOfList = range.$to.end(range.depth);

  if (end < endOfList) {
    tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }

  dispatch(tr.lift(range, prosemirrorTransform.liftTarget(range)).scrollIntoView());
  return true;
}

function liftOutOfList(state, dispatch, range) {
  var tr = state.tr,
      list = range.parent;

  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr["delete"](pos - 1, pos + 1);
  }

  var $start = tr.doc.resolve(range.start),
      item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;
  var atStart = range.startIndex == 0,
      atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1),
      indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) return false;
  var start = $start.pos,
      end = start + item.nodeSize;
  tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}

function sinkListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection4 = state.selection,
        $from = _state$selection4.$from,
        $to = _state$selection4.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    var startIndex = range.startIndex;
    if (startIndex == 0) return false;
    var parent = range.parent,
        nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) return false;

    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before = range.start,
          after = range.end;
      dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }

    return true;
  };
}

exports.addListNodes = addListNodes;
exports.bulletList = bulletList;
exports.liftListItem = liftListItem;
exports.listItem = listItem;
exports.orderedList = orderedList;
exports.sinkListItem = sinkListItem;
exports.splitListItem = splitListItem;
exports.wrapInList = wrapInList;


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var classesById = Object.create(null);

var Selection = function () {
  function Selection($anchor, $head, ranges) {
    _classCallCheck(this, Selection);

    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }

  _createClass(Selection, [{
    key: "anchor",
    get: function get() {
      return this.$anchor.pos;
    }
  }, {
    key: "head",
    get: function get() {
      return this.$head.pos;
    }
  }, {
    key: "from",
    get: function get() {
      return this.$from.pos;
    }
  }, {
    key: "to",
    get: function get() {
      return this.$to.pos;
    }
  }, {
    key: "$from",
    get: function get() {
      return this.ranges[0].$from;
    }
  }, {
    key: "$to",
    get: function get() {
      return this.ranges[0].$to;
    }
  }, {
    key: "empty",
    get: function get() {
      var ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
      }

      return true;
    }
  }, {
    key: "content",
    value: function content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;
      var lastNode = content.content.lastChild,
          lastParent = null;

      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }

      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var _i = 0; _i < ranges.length; _i++) {
        var _ranges$_i = ranges[_i],
            $from = _ranges$_i.$from,
            $to = _ranges$_i.$to,
            mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);
        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(tr, node) {
      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        var _ranges$i = ranges[i],
            $from = _ranges$i.$from,
            $to = _ranges$i.$to,
            mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos),
            to = mapping.map($to.pos);

        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }], [{
    key: "findFrom",
    value: function findFrom($pos, dir) {
      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) return inner;

      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) return found;
      }

      return null;
    }
  }, {
    key: "near",
    value: function near($pos) {
      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
  }, {
    key: "atStart",
    value: function atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
  }, {
    key: "atEnd",
    value: function atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
      var cls = classesById[json.type];
      if (!cls) throw new RangeError("No selection type ".concat(json.type, " defined"));
      return cls.fromJSON(doc, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, selectionClass) {
      if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
  }]);

  return Selection;
}();

Selection.prototype.visible = true;

var SelectionRange = _createClass(function SelectionRange($from, $to) {
  _classCallCheck(this, SelectionRange);

  this.$from = $from;
  this.$to = $to;
});

var warnedAboutTextSelection = false;

function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}

var TextSelection = function (_Selection) {
  _inherits(TextSelection, _Selection);

  var _super = _createSuper(TextSelection);

  function TextSelection($anchor) {
    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;

    _classCallCheck(this, TextSelection);

    checkTextSelection($anchor);
    checkTextSelection($head);
    return _super.call(this, $anchor, $head);
  }

  _createClass(TextSelection, [{
    key: "$cursor",
    get: function get() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
  }, {
    key: "map",
    value: function map(doc, mapping) {
      var $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      var $anchor = doc.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      _get(_getPrototypeOf(TextSelection.prototype), "replace", this).call(this, tr, content);

      if (content == prosemirrorModel.Slice.empty) {
        var marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
  }, {
    key: "create",
    value: function create(doc, anchor) {
      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;
      var $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
  }, {
    key: "between",
    value: function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;

      if (!$head.parent.inlineContent) {
        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found) $head = found.$head;else return Selection.near($head, bias);
      }

      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }

      return new TextSelection($anchor, $head);
    }
  }]);

  return TextSelection;
}(Selection);

Selection.jsonID("text", TextSelection);

var TextBookmark = function () {
  function TextBookmark(anchor, head) {
    _classCallCheck(this, TextBookmark);

    this.anchor = anchor;
    this.head = head;
  }

  _createClass(TextBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
  }]);

  return TextBookmark;
}();

var NodeSelection = function (_Selection2) {
  _inherits(NodeSelection, _Selection2);

  var _super2 = _createSuper(NodeSelection);

  function NodeSelection($pos) {
    var _this;

    _classCallCheck(this, NodeSelection);

    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    _this = _super2.call(this, $pos, $end);
    _this.node = node;
    return _this;
  }

  _createClass(NodeSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var _mapping$mapResult = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult.deleted,
          pos = _mapping$mapResult.pos;

      var $pos = doc.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new NodeSelection($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new NodeBookmark(this.anchor);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc.resolve(json.anchor));
    }
  }, {
    key: "create",
    value: function create(doc, from) {
      return new NodeSelection(doc.resolve(from));
    }
  }, {
    key: "isSelectable",
    value: function isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  }]);

  return NodeSelection;
}(Selection);

NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);

var NodeBookmark = function () {
  function NodeBookmark(anchor) {
    _classCallCheck(this, NodeBookmark);

    this.anchor = anchor;
  }

  _createClass(NodeBookmark, [{
    key: "map",
    value: function map(mapping) {
      var _mapping$mapResult2 = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult2.deleted,
          pos = _mapping$mapResult2.pos;

      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.anchor),
          node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }]);

  return NodeBookmark;
}();

var AllSelection = function (_Selection3) {
  _inherits(AllSelection, _Selection3);

  var _super3 = _createSuper(AllSelection);

  function AllSelection(doc) {
    _classCallCheck(this, AllSelection);

    return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  _createClass(AllSelection, [{
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      if (content == prosemirrorModel.Slice.empty) {
        tr["delete"](0, tr.doc.content.size);
        var sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        _get(_getPrototypeOf(AllSelection.prototype), "replace", this).call(this, tr, content);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "all"
      };
    }
  }, {
    key: "map",
    value: function map(doc) {
      return new AllSelection(doc);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof AllSelection;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return AllBookmark;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc) {
      return new AllSelection(doc);
    }
  }]);

  return AllSelection;
}(Selection);

Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map() {
    return this;
  },
  resolve: function resolve(doc) {
    return new AllSelection(doc);
  }
};

function findSelectionIn(doc, node, pos, index, dir) {
  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  if (node.inlineContent) return TextSelection.create(doc, pos);

  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);

    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
    }

    pos += child.nodeSize * dir;
  }

  return null;
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) return;
  var step = tr.steps[last];
  if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) return;
  var map = tr.mapping.maps[last],
      end;
  map.forEach(function (_from, _to, _newFrom, newTo) {
    if (end == null) end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1,
    UPDATED_MARKS = 2,
    UPDATED_SCROLL = 4;

var Transaction = function (_prosemirrorTransform) {
  _inherits(Transaction, _prosemirrorTransform);

  var _super4 = _createSuper(Transaction);

  function Transaction(state) {
    var _this2;

    _classCallCheck(this, Transaction);

    _this2 = _super4.call(this, state.doc);
    _this2.curSelectionFor = 0;
    _this2.updated = 0;
    _this2.meta = Object.create(null);
    _this2.time = Date.now();
    _this2.curSelection = state.selection;
    _this2.storedMarks = state.storedMarks;
    return _this2;
  }

  _createClass(Transaction, [{
    key: "selection",
    get: function get() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }

      return this.curSelection;
    }
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
  }, {
    key: "selectionSet",
    get: function get() {
      return (this.updated & UPDATED_SEL) > 0;
    }
  }, {
    key: "setStoredMarks",
    value: function setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
  }, {
    key: "ensureMarks",
    value: function ensureMarks(marks) {
      if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
      return this;
    }
  }, {
    key: "addStoredMark",
    value: function addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "removeStoredMark",
    value: function removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "storedMarksSet",
    get: function get() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      _get(_getPrototypeOf(Transaction.prototype), "addStep", this).call(this, step, doc);

      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = time;
      return this;
    }
  }, {
    key: "replaceSelection",
    value: function replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
  }, {
    key: "replaceSelectionWith",
    value: function replaceSelectionWith(node) {
      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var selection = this.selection;
      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.selection.replace(this);
      return this;
    }
  }, {
    key: "insertText",
    value: function insertText(text, from, to) {
      var schema = this.doc.type.schema;

      if (from == null) {
        if (!text) return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null) to = from;
        to = to == null ? from : to;
        if (!text) return this.deleteRange(from, to);
        var marks = this.storedMarks;

        if (!marks) {
          var $from = this.doc.resolve(from);
          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }

        this.replaceRangeWith(from, to, schema.text(text, marks));
        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
  }, {
    key: "setMeta",
    value: function setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
  }, {
    key: "getMeta",
    value: function getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
  }, {
    key: "isGeneric",
    get: function get() {
      for (var _ in this.meta) {
        return false;
      }

      return true;
    }
  }, {
    key: "scrollIntoView",
    value: function scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
  }, {
    key: "scrolledIntoView",
    get: function get() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  }]);

  return Transaction;
}(prosemirrorTransform.Transform);

function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}

var FieldDesc = _createClass(function FieldDesc(name, desc, self) {
  _classCallCheck(this, FieldDesc);

  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
});

var baseFields = [new FieldDesc("doc", {
  init: function init(config) {
    return config.doc || config.schema.topNodeType.createAndFill();
  },
  apply: function apply(tr) {
    return tr.doc;
  }
}), new FieldDesc("selection", {
  init: function init(config, instance) {
    return config.selection || Selection.atStart(instance.doc);
  },
  apply: function apply(tr) {
    return tr.selection;
  }
}), new FieldDesc("storedMarks", {
  init: function init(config) {
    return config.storedMarks || null;
  },
  apply: function apply(tr, _marks, _old, state) {
    return state.selection.$cursor ? tr.storedMarks : null;
  }
}), new FieldDesc("scrollToSelection", {
  init: function init() {
    return 0;
  },
  apply: function apply(tr, prev) {
    return tr.scrolledIntoView ? prev + 1 : prev;
  }
})];

var Configuration = _createClass(function Configuration(schema, plugins) {
  var _this3 = this;

  _classCallCheck(this, Configuration);

  this.schema = schema;
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  this.fields = baseFields.slice();
  if (plugins) plugins.forEach(function (plugin) {
    if (_this3.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");

    _this3.plugins.push(plugin);

    _this3.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
  });
});

var EditorState = function () {
  function EditorState(config) {
    _classCallCheck(this, EditorState);

    this.config = config;
  }

  _createClass(EditorState, [{
    key: "schema",
    get: function get() {
      return this.config.schema;
    }
  }, {
    key: "plugins",
    get: function get() {
      return this.config.plugins;
    }
  }, {
    key: "apply",
    value: function apply(tr) {
      return this.applyTransaction(tr).state;
    }
  }, {
    key: "filterTransaction",
    value: function filterTransaction(tr) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      for (var i = 0; i < this.config.plugins.length; i++) {
        if (i != ignore) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
        }
      }

      return true;
    }
  }, {
    key: "applyTransaction",
    value: function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) return {
        state: this,
        transactions: []
      };
      var trs = [rootTr],
          newState = this.applyInner(rootTr),
          seen = null;

      for (;;) {
        var haveNew = false;

        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];

          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0,
                oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);

            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);

              if (!seen) {
                seen = [];

                for (var j = 0; j < this.config.plugins.length; j++) {
                  seen.push(j < i ? {
                    state: newState,
                    n: trs.length
                  } : {
                    state: this,
                    n: 0
                  });
                }
              }

              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }

            if (seen) seen[i] = {
              state: newState,
              n: trs.length
            };
          }
        }

        if (!haveNew) return {
          state: newState,
          transactions: trs
        };
      }
    }
  }, {
    key: "applyInner",
    value: function applyInner(tr) {
      if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      var newInstance = new EditorState(this.config),
          fields = this.config.fields;

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }

      return newInstance;
    }
  }, {
    key: "tr",
    get: function get() {
      return new Transaction(this);
    }
  }, {
    key: "reconfigure",
    value: function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields,
          instance = new EditorState($config);

      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "toJSON",
    value: function toJSON(pluginFields) {
      var result = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {
        return m.toJSON();
      });
      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop],
            state = plugin.spec.state;
        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
      return result;
    }
  }], [{
    key: "create",
    value: function create(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);

      for (var i = 0; i < $config.fields.length; i++) {
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(config, json, pluginFields) {
      if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema) throw new RangeError("Required config field 'schema' missing");
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields) for (var prop in pluginFields) {
            var plugin = pluginFields[prop],
                state = plugin.spec.state;

            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }]);

  return EditorState;
}();

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) val = val.bind(self);else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
    target[prop] = val;
  }

  return target;
}

var Plugin = function () {
  function Plugin(spec) {
    _classCallCheck(this, Plugin);

    this.spec = spec;
    this.props = {};
    if (spec.props) bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }

  _createClass(Plugin, [{
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return Plugin;
}();

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}

var PluginKey = function () {
  function PluginKey() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "key";

    _classCallCheck(this, PluginKey);

    this.key = createKey(name);
  }

  _createClass(PluginKey, [{
    key: "get",
    value: function get(state) {
      return state.config.pluginsByKey[this.key];
    }
  }, {
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return PluginKey;
}();

exports.AllSelection = AllSelection;
exports.EditorState = EditorState;
exports.NodeSelection = NodeSelection;
exports.Plugin = Plugin;
exports.PluginKey = PluginKey;
exports.Selection = Selection;
exports.SelectionRange = SelectionRange;
exports.TextSelection = TextSelection;
exports.Transaction = Transaction;


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) {
  return index + offset * factor16;
}

function recoverIndex(value) {
  return value & lower16;
}

function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}

var DEL_BEFORE = 1,
    DEL_AFTER = 2,
    DEL_ACROSS = 4,
    DEL_SIDE = 8;

var MapResult = function () {
  function MapResult(pos, delInfo, recover) {
    _classCallCheck(this, MapResult);

    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }

  _createClass(MapResult, [{
    key: "deleted",
    get: function get() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
  }, {
    key: "deletedBefore",
    get: function get() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAfter",
    get: function get() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAcross",
    get: function get() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }]);

  return MapResult;
}();

var StepMap = function () {
  function StepMap(ranges) {
    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, StepMap);

    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty) return StepMap.empty;
  }

  _createClass(StepMap, [{
    key: "recover",
    value: function recover(value) {
      var diff = 0,
          index = recoverIndex(value);
      if (!this.inverted) for (var i = 0; i < index; i++) {
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      }
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, true);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var diff = 0,
          oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex],
            end = start + oldSize;

        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
          return new MapResult(result, del, recover);
        }

        diff += newSize - oldSize;
      }

      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
  }, {
    key: "touches",
    value: function touches(pos, recover) {
      var diff = 0,
          index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            end = start + oldSize;
        if (pos <= end && i == index * 3) return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }

      return false;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i],
            oldStart = start - (this.inverted ? diff : 0),
            newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
  }, {
    key: "toString",
    value: function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
  }], [{
    key: "offset",
    value: function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }]);

  return StepMap;
}();

StepMap.empty = new StepMap([]);

var Mapping = function () {
  function Mapping() {
    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var mirror = arguments.length > 1 ? arguments[1] : undefined;
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;

    _classCallCheck(this, Mapping);

    this.maps = maps;
    this.mirror = mirror;
    this.from = from;
    this.to = to;
  }

  _createClass(Mapping, [{
    key: "slice",
    value: function slice() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;
      return new Mapping(this.maps, this.mirror, from, to);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
  }, {
    key: "appendMap",
    value: function appendMap(map, mirrors) {
      this.to = this.maps.push(map);
      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
    }
  }, {
    key: "appendMapping",
    value: function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
      }
    }
  }, {
    key: "getMirror",
    value: function getMirror(n) {
      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) {
        if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }, {
    key: "setMirror",
    value: function setMirror(n, m) {
      if (!this.mirror) this.mirror = [];
      this.mirror.push(n, m);
    }
  }, {
    key: "appendMappingInverted",
    value: function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.mirror) return this._map(pos, assoc, true);

      for (var i = this.from; i < this.to; i++) {
        pos = this.maps[i].map(pos, assoc);
      }

      return pos;
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var delInfo = 0;

      for (var i = this.from; i < this.to; i++) {
        var map = this.maps[i],
            result = map.mapResult(pos, assoc);

        if (result.recover != null) {
          var corr = this.getMirror(i);

          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }

        delInfo |= result.delInfo;
        pos = result.pos;
      }

      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }]);

  return Mapping;
}();

var stepsByID = Object.create(null);

var Step = function () {
  function Step() {
    _classCallCheck(this, Step);
  }

  _createClass(Step, [{
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "merge",
    value: function merge(other) {
      return null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      var type = stepsByID[json.stepType];
      if (!type) throw new RangeError("No step type ".concat(json.stepType, " defined"));
      return type.fromJSON(schema, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, stepClass) {
      if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }]);

  return Step;
}();

var StepResult = function () {
  function StepResult(doc, failed) {
    _classCallCheck(this, StepResult);

    this.doc = doc;
    this.failed = failed;
  }

  _createClass(StepResult, null, [{
    key: "ok",
    value: function ok(doc) {
      return new StepResult(doc, null);
    }
  }, {
    key: "fail",
    value: function fail(message) {
      return new StepResult(null, message);
    }
  }, {
    key: "fromReplace",
    value: function fromReplace(doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof prosemirrorModel.ReplaceError) return StepResult.fail(e.message);
        throw e;
      }
    }
  }]);

  return StepResult;
}();

function mapFragment(fragment, f, parent) {
  var mapped = [];

  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline) child = f(child, parent, i);
    mapped.push(child);
  }

  return prosemirrorModel.Fragment.fromArray(mapped);
}

var AddMarkStep = function (_Step) {
  _inherits(AddMarkStep, _Step);

  var _super = _createSuper(AddMarkStep);

  function AddMarkStep(from, to, mark) {
    var _this;

    _classCallCheck(this, AddMarkStep);

    _this = _super.call(this);
    _this.from = from;
    _this.to = to;
    _this.mark = mark;
    return _this;
  }

  _createClass(AddMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this2 = this;

      var oldSlice = doc.slice(this.from, this.to),
          $from = doc.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {
        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;
        return node.mark(_this2.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new AddMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return AddMarkStep;
}(Step);

Step.jsonID("addMark", AddMarkStep);

var RemoveMarkStep = function (_Step2) {
  _inherits(RemoveMarkStep, _Step2);

  var _super2 = _createSuper(RemoveMarkStep);

  function RemoveMarkStep(from, to, mark) {
    var _this3;

    _classCallCheck(this, RemoveMarkStep);

    _this3 = _super2.call(this);
    _this3.from = from;
    _this3.to = to;
    _this3.mark = mark;
    return _this3;
  }

  _createClass(RemoveMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this4 = this;

      var oldSlice = doc.slice(this.from, this.to);
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {
        return node.mark(_this4.mark.removeFromSet(node.marks));
      }, doc), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return RemoveMarkStep;
}(Step);

Step.jsonID("removeMark", RemoveMarkStep);

var ReplaceStep = function (_Step3) {
  _inherits(ReplaceStep, _Step3);

  var _super3 = _createSuper(ReplaceStep);

  function ReplaceStep(from, to, slice) {
    var _this5;

    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, ReplaceStep);

    _this5 = _super3.call(this);
    _this5.from = from;
    _this5.to = to;
    _this5.slice = slice;
    _this5.structure = structure;
    return _this5;
  }

  _createClass(ReplaceStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross) return null;
      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;

      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);

        return new ReplaceStep(other.from, this.to, _slice, this.structure);
      } else {
        return null;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  }]);

  return ReplaceStep;
}(Step);

Step.jsonID("replace", ReplaceStep);

var ReplaceAroundStep = function (_Step4) {
  _inherits(ReplaceAroundStep, _Step4);

  var _super4 = _createSuper(ReplaceAroundStep);

  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert) {
    var _this6;

    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

    _classCallCheck(this, ReplaceAroundStep);

    _this6 = _super4.call(this);
    _this6.from = from;
    _this6.to = to;
    _this6.gapFrom = gapFrom;
    _this6.gapTo = gapTo;
    _this6.slice = slice;
    _this6.insert = insert;
    _this6.structure = structure;
    return _this6;
  }

  _createClass(ReplaceAroundStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
      var gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1),
          gapTo = mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;
      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  }]);

  return ReplaceAroundStep;
}(Step);

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from),
      dist = to - from,
      depth = $from.depth;

  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }

  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));

    while (dist > 0) {
      if (!next || next.isLeaf) return true;
      next = next.firstChild;
      dist--;
    }
  }

  return false;
}

function _addMark(tr, from, to, mark) {
  var removed = [],
      added = [];
  var removing, adding;
  tr.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) return;
    var marks = node.marks;

    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from),
          end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }

      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach(function (s) {
    return tr.step(s);
  });
  added.forEach(function (s) {
    return tr.step(s);
  });
}

function _removeMark(tr, from, to, mark) {
  var matched = [],
      step = 0;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) return;
    step++;
    var toRemove = null;

    if (mark instanceof prosemirrorModel.MarkType) {
      var set = node.marks,
          found;

      while (found = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) toRemove = [mark];
    } else {
      toRemove = node.marks;
    }

    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);

      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i],
            _found = void 0;

        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;
        }

        if (_found) {
          _found.to = end;
          _found.step = step;
        } else {
          matched.push({
            style: style,
            from: Math.max(pos, from),
            to: end,
            step: step
          });
        }
      }
    }
  });
  matched.forEach(function (m) {
    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
  });
}

function _clearIncompatible(tr, pos, parentType) {
  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;
  var node = tr.doc.nodeAt(pos);
  var delSteps = [],
      cur = pos + 1;

  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i),
        end = cur + child.nodeSize;
    var allowed = match.matchType(child.type);

    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
    } else {
      match = allowed;

      for (var j = 0; j < child.marks.length; j++) {
        if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      }
    }

    cur = end;
  }

  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
    tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
  }

  for (var _i = delSteps.length - 1; _i >= 0; _i--) {
    tr.step(delSteps[_i]);
  }
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}

function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);

  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth),
        endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
  }

  return null;
}

function _lift(tr, range, target) {
  var $from = range.$from,
      $to = range.$to,
      depth = range.depth;
  var gapStart = $from.before(depth + 1),
      gapEnd = $to.after(depth + 1);
  var start = gapStart,
      end = gapEnd;
  var before = prosemirrorModel.Fragment.empty,
      openStart = 0;

  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  }

  var after = prosemirrorModel.Fragment.empty,
      openEnd = 0;

  for (var _d = depth, _splitting = false; _d > target; _d--) {
    if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
      _splitting = true;
      after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  }

  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}

function findWrapping(range, nodeType) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;
  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) return null;
  return around.map(withAttrs).concat({
    type: nodeType,
    attrs: attrs
  }).concat(inner.map(withAttrs));
}

function withAttrs(type) {
  return {
    type: type,
    attrs: null
  };
}

function findWrappingOutside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) return null;
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}

function findWrappingInside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) return null;
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;

  for (var i = startIndex; innerMatch && i < endIndex; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }

  if (!innerMatch || !innerMatch.validEnd) return null;
  return inside;
}

function _wrap2(tr, range, wrappers) {
  var content = prosemirrorModel.Fragment.empty;

  for (var i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      var match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }

    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  var start = range.start,
      end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
}

function _setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
  var mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = tr.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1),
          endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}

function _setNodeMarkup(tr, pos, type, attrs, marks) {
  var node = tr.doc.nodeAt(pos);
  if (!node) throw new RangeError("No node at given position");
  if (!type) type = node.type;
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content)) throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
}

function canSplit(doc, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = doc.resolve(pos),
      base = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;

  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d),
        _index = $pos.index(d);

    if (node.type.spec.isolating) return false;
    var rest = node.content.cutByIndex(_index, node.childCount);
    var after = typesAfter && typesAfter[i] || node;
    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));
    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;
  }

  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}

function _split(tr, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = tr.doc.resolve(pos),
      before = prosemirrorModel.Fragment.empty,
      after = prosemirrorModel.Fragment.empty;

  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }

  tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
}

function canJoin(doc, pos) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}

function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}

function joinPoint(doc, pos) {
  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  var $pos = doc.resolve(pos);

  for (var d = $pos.depth;; d--) {
    var before = void 0,
        after = void 0,
        index = $pos.index(d);

    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }

    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
    if (d == 0) break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

function _join(tr, pos, depth) {
  var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);
  tr.step(step);
}

function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
    var index = $pos.index(d);
    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
    if (index > 0) return null;
  }
  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
    var _index2 = $pos.indexAfter(_d2);

    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);
    if (_index2 < $pos.node(_d2).childCount) return null;
  }
  return null;
}

function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) return pos;
  var content = slice.content;

  for (var i = 0; i < slice.openStart; i++) {
    content = content.firstChild.content;
  }

  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d),
          fits = false;

      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }

      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }

  return null;
}

function replaceStep(doc, from) {
  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;
  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirrorModel.Slice.empty;
  if (from == to && !slice.size) return null;
  var $from = doc.resolve(from),
      $to = doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}

var Fitter = function () {
  function Fitter($from, $to, unplaced) {
    _classCallCheck(this, Fitter);

    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = prosemirrorModel.Fragment.empty;

    for (var i = 0; i <= $from.depth; i++) {
      var node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }

    for (var _i2 = $from.depth; _i2 > 0; _i2--) {
      this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));
    }
  }

  _createClass(Fitter, [{
    key: "depth",
    get: function get() {
      return this.frontier.length - 1;
    }
  }, {
    key: "fit",
    value: function fit() {
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();
      }

      var moveInline = this.mustMoveInline(),
          placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from,
          $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) return null;
      var content = this.placed,
          openStart = $from.depth,
          openEnd = $to.depth;

      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }

      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
  }, {
    key: "findFittable",
    value: function findFittable() {
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0,
              parent = null;

          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }

          var first = fragment.firstChild;

          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var _this$frontier$fronti = this.frontier[frontierDepth],
                type = _this$frontier$fronti.type,
                match = _this$frontier$fronti.match,
                _wrap = void 0,
                inject = null;

            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              inject: inject
            };else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              wrap: _wrap
            };
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    }
  }, {
    key: "openMore",
    value: function openMore() {
      var _this$unplaced = this.unplaced,
          content = _this$unplaced.content,
          openStart = _this$unplaced.openStart,
          openEnd = _this$unplaced.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
  }, {
    key: "dropNode",
    value: function dropNode() {
      var _this$unplaced2 = this.unplaced,
          content = _this$unplaced2.content,
          openStart = _this$unplaced2.openStart,
          openEnd = _this$unplaced2.openEnd;
      var inner = contentAt(content, openStart);

      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
  }, {
    key: "placeNodes",
    value: function placeNodes(_ref) {
      var sliceDepth = _ref.sliceDepth,
          frontierDepth = _ref.frontierDepth,
          parent = _ref.parent,
          inject = _ref.inject,
          wrap = _ref.wrap;

      while (this.depth > frontierDepth) {
        this.closeFrontierNode();
      }

      if (wrap) for (var i = 0; i < wrap.length; i++) {
        this.openFrontierNode(wrap[i]);
      }
      var slice = this.unplaced,
          fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0,
          add = [];
      var _this$frontier$fronti2 = this.frontier[frontierDepth],
          match = _this$frontier$fronti2.match,
          type = _this$frontier$fronti2.type;

      if (inject) {
        for (var i = 0; i < inject.childCount; i++) {
          add.push(inject.child(i));
        }

        match = match.matchFragment(inject);
      }

      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);

      while (taken < fragment.childCount) {
        var next = fragment.child(taken),
            matches = match.matchType(next.type);
        if (!matches) break;
        taken++;

        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }

      var toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();

      for (var _i3 = 0, cur = fragment; _i3 < openEndCount; _i3++) {
        var node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount)
        });
        cur = node.content;
      }

      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
  }, {
    key: "mustMoveInline",
    value: function mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      var top = this.frontier[this.depth],
          level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
      var depth = this.$to.depth,
          after = this.$to.after(depth);

      while (depth > 1 && after == this.$to.end(--depth)) {
        ++after;
      }

      return after;
    }
  }, {
    key: "findCloseLevel",
    value: function findCloseLevel($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var _this$frontier$i = this.frontier[i],
            match = _this$frontier$i.match,
            type = _this$frontier$i.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) continue;

        for (var d = i - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d],
              _match = _this$frontier$d.match,
              _type = _this$frontier$d.type;
          var matches = contentAfterFits($to, d, _type, _match, true);
          if (!matches || matches.childCount) continue scan;
        }

        return {
          depth: i,
          fit: fit,
          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
        };
      }
    }
  }, {
    key: "close",
    value: function close($to) {
      var close = this.findCloseLevel($to);
      if (!close) return null;

      while (this.depth > close.depth) {
        this.closeFrontierNode();
      }

      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);
      $to = close.move;

      for (var d = close.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d),
            add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }

      return $to;
    }
  }, {
    key: "openFrontierNode",
    value: function openFrontierNode(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));
      this.frontier.push({
        type: type,
        match: type.contentMatch
      });
    }
  }, {
    key: "closeFrontierNode",
    value: function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  }]);

  return Fitter;
}();

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }

  return fragment;
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) return node;
  var frag = node.content;
  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));

  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return node.copy(frag);
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth),
      index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) return null;
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++) {
    if (!type.allowsMarks(fragment.child(i).marks)) return true;
  }

  return false;
}

function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}

function _replaceRange(tr, from, to, slice) {
  if (!slice.size) return tr.deleteRange(from, to);
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));
  var targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);

  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) break;
    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
  }

  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [],
      preferredDepth = slice.openStart;

  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) break;
    content = node.content;
  }

  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
    var type = leftNodes[_d3].type,
        def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = _d3;else if (def || !type.isTextblock) break;
  }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) continue;

    for (var _i4 = 0; _i4 < targetDepths.length; _i4++) {
      var targetDepth = targetDepths[(_i4 + preferredTargetIndex) % targetDepths.length],
          expand = true;

      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }

      var parent = $from.node(targetDepth - 1),
          index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }

  var startSteps = tr.steps.length;

  for (var _i5 = targetDepths.length - 1; _i5 >= 0; _i5--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps) break;
    var depth = targetDepths[_i5];
    if (depth < 0) continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }

  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return fragment;
}

function _replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    var point = insertPoint(tr.doc, from, node.type);
    if (point != null) from = to = point;
  }

  tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
}

function _deleteRange(tr, from, to) {
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  var covered = coveredDepths($from, $to);

  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i],
        last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr["delete"]($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr["delete"]($from.before(depth), $to.after(depth));
  }

  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr["delete"]($from.before(d), to);
  }

  tr["delete"](from, to);
}

function coveredDepths($from, $to) {
  var result = [],
      minDepth = Math.min($from.depth, $to.depth);

  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
  }

  return result;
}

exports.TransformError = function (_Error) {
  _inherits(_class, _Error);

  var _super5 = _createSuper(_class);

  function _class() {
    _classCallCheck(this, _class);

    return _super5.apply(this, arguments);
  }

  return _createClass(_class);
}(_wrapNativeSuper(Error));

exports.TransformError = function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err;
};

exports.TransformError.prototype = Object.create(Error.prototype);
exports.TransformError.prototype.constructor = exports.TransformError;
exports.TransformError.prototype.name = "TransformError";

var Transform = function () {
  function Transform(doc) {
    _classCallCheck(this, Transform);

    this.doc = doc;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }

  _createClass(Transform, [{
    key: "before",
    get: function get() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
  }, {
    key: "step",
    value: function step(_step) {
      var result = this.maybeStep(_step);
      if (result.failed) throw new exports.TransformError(result.failed);
      return this;
    }
  }, {
    key: "maybeStep",
    value: function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) this.addStep(step, result.doc);
      return result;
    }
  }, {
    key: "docChanged",
    get: function get() {
      return this.steps.length > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    }
  }, {
    key: "replace",
    value: function replace(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirrorModel.Slice.empty;
      var step = replaceStep(this.doc, from, to, slice);
      if (step) this.step(step);
      return this;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(from, to, content) {
      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
    }
  }, {
    key: "delete",
    value: function _delete(from, to) {
      return this.replace(from, to, prosemirrorModel.Slice.empty);
    }
  }, {
    key: "insert",
    value: function insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
  }, {
    key: "replaceRange",
    value: function replaceRange(from, to, slice) {
      _replaceRange(this, from, to, slice);

      return this;
    }
  }, {
    key: "replaceRangeWith",
    value: function replaceRangeWith(from, to, node) {
      _replaceRangeWith(this, from, to, node);

      return this;
    }
  }, {
    key: "deleteRange",
    value: function deleteRange(from, to) {
      _deleteRange(this, from, to);

      return this;
    }
  }, {
    key: "lift",
    value: function lift(range, target) {
      _lift(this, range, target);

      return this;
    }
  }, {
    key: "join",
    value: function join(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      _join(this, pos, depth);

      return this;
    }
  }, {
    key: "wrap",
    value: function wrap(range, wrappers) {
      _wrap2(this, range, wrappers);

      return this;
    }
  }, {
    key: "setBlockType",
    value: function setBlockType(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _setBlockType(this, from, to, type, attrs);

      return this;
    }
  }, {
    key: "setNodeMarkup",
    value: function setNodeMarkup(pos, type) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      _setNodeMarkup(this, pos, type, attrs, marks);

      return this;
    }
  }, {
    key: "split",
    value: function split(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;

      _split(this, pos, depth, typesAfter);

      return this;
    }
  }, {
    key: "addMark",
    value: function addMark(from, to, mark) {
      _addMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "removeMark",
    value: function removeMark(from, to, mark) {
      _removeMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "clearIncompatible",
    value: function clearIncompatible(pos, parentType, match) {
      _clearIncompatible(this, pos, parentType, match);

      return this;
    }
  }]);

  return Transform;
}();

exports.AddMarkStep = AddMarkStep;
exports.MapResult = MapResult;
exports.Mapping = Mapping;
exports.RemoveMarkStep = RemoveMarkStep;
exports.ReplaceAroundStep = ReplaceAroundStep;
exports.ReplaceStep = ReplaceStep;
exports.Step = Step;
exports.StepMap = StepMap;
exports.StepResult = StepResult;
exports.Transform = Transform;
exports.canJoin = canJoin;
exports.canSplit = canSplit;
exports.dropPoint = dropPoint;
exports.findWrapping = findWrapping;
exports.insertPoint = insertPoint;
exports.joinPoint = joinPoint;
exports.liftTarget = liftTarget;
exports.replaceStep = replaceStep;


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var nav = typeof navigator != "undefined" ? navigator : null;
var doc = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];

var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);

var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var android = /Android \d/.test(agent);
var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;

var domIndex = function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
};

var parentNode = function parentNode(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};

var reusedRange = null;

var textRange = function textRange(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};

var isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;

    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) return true;
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;

  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) break;
  }

  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}

var selectionCollapsed = function selectionCollapsed(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) collapsed = false;
  return collapsed;
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}

function windowRect(doc) {
  return {
    left: 0,
    right: doc.documentElement.clientWidth,
    top: 0,
    bottom: doc.documentElement.clientHeight
  };
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  var scaleX = rect.width / node.offsetWidth || 1;
  var scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0,
      scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;

  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) break;
    if (parent.nodeType != 1) continue;
    var elt = parent;
    var atTop = elt == doc.body;
    var bounding = atTop ? windowRect(doc) : clientRect(elt);
    var moveX = 0,
        moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");

    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = elt.scrollLeft,
            startY = elt.scrollTop;
        if (moveY) elt.scrollTop += moveY;
        if (moveX) elt.scrollLeft += moveX;
        var dX = elt.scrollLeft - startX,
            dY = elt.scrollTop - startY;
        rect = {
          left: rect.left - dX,
          top: rect.top - dY,
          right: rect.right - dX,
          bottom: rect.bottom - dY
        };
      }
    }

    if (atTop) break;
  }
}

function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(),
      startY = Math.max(0, rect.top);
  var refDOM, refTop;

  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
    var localRect = dom.getBoundingClientRect();

    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }

  return {
    refDOM: refDOM,
    refTop: refTop,
    stack: scrollStack(view.dom)
  };
}

function scrollStack(dom) {
  var stack = [],
      doc = dom.ownerDocument;

  for (var cur = dom; cur; cur = parentNode(cur)) {
    stack.push({
      dom: cur,
      top: cur.scrollTop,
      left: cur.scrollLeft
    });
    if (dom == doc) break;
  }

  return stack;
}

function resetScrollPos(_ref) {
  var refDOM = _ref.refDOM,
      refTop = _ref.refTop,
      stack = _ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var _stack$i = stack[i],
        dom = _stack$i.dom,
        top = _stack$i.top,
        left = _stack$i.left;
    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left) dom.scrollLeft = left;
  }
}

var preventScrollSupported = null;

function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive();
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }

  } : undefined);

  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest,
      dxClosest = 2e8,
      coordsClosest,
      offset = 0;
  var rowBot = coords.top,
      rowTop = coords.top;

  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];

      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;

        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      }

      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
    }
  }

  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1) return {
    node: node,
    offset: offset
  };
  return findOffsetInNode(closest, coordsClosest);
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();

  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) continue;
    if (inRect(coords, rect)) return {
      node: node,
      offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
    };
  }

  return {
    node: node,
    offset: 0
  };
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
  return dom;
}

function posFromElement(view, elt, coords) {
  var _findOffsetInNode = findOffsetInNode(elt, coords),
      node = _findOffsetInNode.node,
      offset = _findOffsetInNode.offset,
      bias = -1;

  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }

  return view.docView.posFromDOM(node, offset, bias);
}

function posFromCaret(view, node, offset, coords) {
  var outside = -1;

  for (var cur = node;;) {
    if (cur == view.dom) break;
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) return null;

    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore;else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter;else break;
    }

    cur = desc.dom.parentNode;
  }

  return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;

  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];

      if (child.nodeType == 1) {
        var rects = child.getClientRects();

        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
        }
      }

      if ((i = (i + 1) % len) == startI) break;
    }
  }

  return element;
}

function _posAtCoords(view, coords) {
  var doc = view.dom.ownerDocument,
      node,
      offset = 0;

  if (doc.caretPositionFromPoint) {
    try {
      var _pos = doc.caretPositionFromPoint(coords.left, coords.top);

      if (_pos) {
        node = _pos.offsetNode;
        offset = _pos.offset;
      }
    } catch (_) {}
  }

  if (!node && doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(coords.left, coords.top);

    if (range) {
      node = range.startContainer;
      offset = range.startOffset;
    }
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1);
  var pos;

  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) return null;
  }

  if (safari) {
    for (var p = elt; node && p; p = parentNode(p)) {
      if (p.draggable) node = undefined;
    }
  }

  elt = targetKludge(elt, coords);

  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);

      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset],
            _box;

        if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
      }
    }

    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
  }

  if (pos == null) pos = posFromElement(view, elt, coords);
  var desc = view.docView.nearestDesc(elt, true);
  return {
    pos: pos,
    inside: desc ? desc.posAtStart - desc.border : -1
  };
}

function singleRect(target, bias) {
  var rects = target.getClientRects();
  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

function _coordsAtPos(view, pos, side) {
  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),
      node = _view$docView$domFrom.node,
      offset = _view$docView$domFrom.offset;

  var supportEmptyRange = webkit || gecko;

  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);

      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);

        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }

      return rect;
    } else {
      var from = offset,
          to = offset,
          takeSide = side < 0 ? 1 : -1;

      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }

      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }

  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
    }

    if (offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
    }

    return flattenH(node.getBoundingClientRect(), side >= 0);
  }

  if (offset && (side < 0 || offset == nodeSize(node))) {
    var _before = node.childNodes[offset - 1];
    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
    if (target) return flattenV(singleRect(target, 1), false);
  }

  if (offset < nodeSize(node)) {
    var _after = node.childNodes[offset];

    while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) {
      _after = _after.nextSibling;
    }

    var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;

    if (_target) return flattenV(singleRect(_target, -1), true);
  }

  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}

function flattenV(rect, left) {
  if (rect.width == 0) return rect;
  var x = left ? rect.left : rect.right;
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: x,
    right: x
  };
}

function flattenH(rect, top) {
  if (rect.height == 0) return rect;
  var y = top ? rect.top : rect.bottom;
  return {
    top: y,
    bottom: y,
    left: rect.left,
    right: rect.right
  };
}

function withFlushedState(view, state, f) {
  var viewState = view.state,
      active = view.root.activeElement;
  if (viewState != state) view.updateState(state);
  if (active != view.dom) view.focus();

  try {
    return f();
  } finally {
    if (viewState != state) view.updateState(viewState);
    if (active != view.dom && active) active.focus();
  }
}

function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1),
        dom = _view$docView$domFrom2.node;

    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) break;

      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }

      dom = nearest.dom.parentNode;
    }

    var coords = _coordsAtPos(view, $pos.pos, 1);

    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;

      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
      }
    }

    return true;
  });
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var $head = state.selection.$head;
  if (!$head.parent.isTextblock) return false;
  var offset = $head.parentOffset,
      atStart = !offset,
      atEnd = offset == $head.parent.content.size;
  var sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, function () {
    var oldRange = sel.getRangeAt(0),
        oldNode = sel.focusNode,
        oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}

var cachedState = null;
var cachedDir = null;
var cachedResult = false;

function _endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}

var NOT_DIRTY = 0,
    CHILD_DIRTY = 1,
    CONTENT_DIRTY = 2,
    NODE_DIRTY = 3;

var ViewDesc = function () {
  function ViewDesc(parent, children, dom, contentDOM) {
    _classCallCheck(this, ViewDesc);

    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }

  _createClass(ViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return false;
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return false;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return false;
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return null;
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return false;
    }
  }, {
    key: "size",
    get: function get() {
      var size = 0;

      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }

      return size;
    }
  }, {
    key: "border",
    get: function get() {
      return 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.parent = undefined;
      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;

      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    }
  }, {
    key: "posBeforeChild",
    value: function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart;; i++) {
        var cur = this.children[i];
        if (cur == child) return pos;
        pos += cur.size;
      }
    }
  }, {
    key: "posBefore",
    get: function get() {
      return this.parent.posBeforeChild(this);
    }
  }, {
    key: "posAtStart",
    get: function get() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
  }, {
    key: "posAfter",
    get: function get() {
      return this.posBefore + this.size;
    }
  }, {
    key: "posAtEnd",
    get: function get() {
      return this.posAtStart + this.size - 2 * this.border;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;

          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domBefore = dom.previousSibling;
          }

          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }

          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, _desc;

          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domAfter = dom.nextSibling;
          }

          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) {
            domAfter = domAfter.nextSibling;
          }

          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
        }
      }

      var atEnd;

      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }

          if (search.previousSibling) break;
        }
        if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom;; _search = _search.parentNode) {
          if (_search == this.dom) {
            atEnd = true;
            break;
          }

          if (_search.nextSibling) break;
        }
      }

      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
  }, {
    key: "nearestDesc",
    value: function nearestDesc(dom) {
      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur),
            nodeDOM = void 0;

        if (desc && (!onlyNodes || desc.node)) {
          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;else return desc;
        }
      }
    }
  }, {
    key: "getDesc",
    value: function getDesc(dom) {
      var desc = dom.pmViewDesc;

      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) return desc;
      }
    }
  }, {
    key: "posFromDOM",
    value: function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) return desc.localPosFromDOM(dom, offset, bias);
      }

      return -1;
    }
  }, {
    key: "descAt",
    value: function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            child = child.children[0];
          }

          return child;
        }

        if (pos < end) return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos, side) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0
      };
      var i = 0,
          offset = 0;

      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = curPos + child.size;

        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }

        curPos = end;
      }

      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);

      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}

      if (side <= 0) {
        var _prev,
            enter = true;

        for (;; i--, enter = false) {
          _prev = i ? this.children[i - 1] : null;
          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
        }

        if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
        return {
          node: this.contentDOM,
          offset: _prev ? domIndex(_prev.dom) + 1 : 0
        };
      } else {
        var next,
            _enter = true;

        for (;; i++, _enter = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) break;
        }

        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
        return {
          node: this.contentDOM,
          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
        };
      }
    }
  }, {
    key: "parseRange",
    value: function parseRange(from, to) {
      var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      var fromOffset = -1,
          toOffset = -1;

      for (var offset = base, i = 0;; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);
          from = offset;

          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];

            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }

            from -= prev.size;
          }

          if (fromOffset == -1) fromOffset = 0;
        }

        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;

          for (var _j = i + 1; _j < this.children.length; _j++) {
            var next = this.children[_j];

            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }

            to += next.size;
          }

          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
          break;
        }

        offset = end;
      }

      return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: fromOffset,
        toOffset: toOffset
      };
    }
  }, {
    key: "emptyChildAt",
    value: function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
  }, {
    key: "domAfterPos",
    value: function domAfterPos(pos) {
      var _this$domFromPos = this.domFromPos(pos, 0),
          node = _this$domFromPos.node,
          offset = _this$domFromPos.offset;

      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset];
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var from = Math.min(anchor, head),
          to = Math.max(anchor, head);

      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;
        if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        offset = end;
      }

      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;

      if ((gecko || safari) && anchor == head) {
        var _anchorDOM = anchorDOM,
            node = _anchorDOM.node,
            _offset = _anchorDOM.offset;

        if (node.nodeType == 3) {
          brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");

          if (brKludge && _offset == node.nodeValue.length) {
            for (var scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR") anchorDOM = headDOM = {
                  node: after.parentNode,
                  offset: domIndex(after) + 1
                };
                break;
              }

              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) break;
            }
          }
        } else {
          var prev = node.childNodes[_offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }

      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var _after2 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (_after2 && _after2.contentEditable == "false") force = true;
      }

      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;
      var domSelExtended = false;

      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);

        try {
          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (err) {
          if (!(err instanceof DOMException)) throw err;
        }
      }

      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }

        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
  }, {
    key: "contentLost",
    get: function get() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border,
              endInside = end - child.border;

          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }

        offset = end;
      }

      this.dirty = CONTENT_DIRTY;
    }
  }, {
    key: "markParentsDirty",
    value: function markParentsDirty() {
      var level = 1;

      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) node.dirty = dirty;
      }
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return false;
    }
  }]);

  return ViewDesc;
}();

var WidgetViewDesc = function (_ViewDesc) {
  _inherits(WidgetViewDesc, _ViewDesc);

  var _super = _createSuper(WidgetViewDesc);

  function WidgetViewDesc(parent, widget, view, pos) {
    var _this;

    _classCallCheck(this, WidgetViewDesc);

    var self,
        dom = widget.type.toDOM;
    if (typeof dom == "function") dom = dom(view, function () {
      if (!self) return pos;
      if (self.parent) return self.parent.posBeforeChild(self);
    });

    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }

      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }

    _this = _super.call(this, parent, [], dom, null);
    _this.widget = widget;
    _this.widget = widget;
    self = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(WidgetViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      var stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.widget.type.destroy(this.dom);

      _get(_getPrototypeOf(WidgetViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "side",
    get: function get() {
      return this.widget.type.side;
    }
  }]);

  return WidgetViewDesc;
}(ViewDesc);

var CompositionViewDesc = function (_ViewDesc2) {
  _inherits(CompositionViewDesc, _ViewDesc2);

  var _super2 = _createSuper(CompositionViewDesc);

  function CompositionViewDesc(parent, dom, textDOM, text) {
    var _this2;

    _classCallCheck(this, CompositionViewDesc);

    _this2 = _super2.call(this, parent, [], dom, null);
    _this2.textDOM = textDOM;
    _this2.text = text;
    return _this2;
  }

  _createClass(CompositionViewDesc, [{
    key: "size",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset) {
      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.textDOM,
        offset: pos
      };
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mut) {
      return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;
    }
  }]);

  return CompositionViewDesc;
}(ViewDesc);

var MarkViewDesc = function (_ViewDesc3) {
  _inherits(MarkViewDesc, _ViewDesc3);

  var _super3 = _createSuper(MarkViewDesc);

  function MarkViewDesc(parent, mark, dom, contentDOM) {
    var _this3;

    _classCallCheck(this, MarkViewDesc);

    _this3 = _super3.call(this, parent, [], dom, contentDOM);
    _this3.mark = mark;
    return _this3;
  }

  _createClass(MarkViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM || undefined
      };
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(MarkViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;

        while (!parent.node) {
          parent = parent.parent;
        }

        if (parent.dirty < this.dirty) parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
      var nodes = this.children,
          size = this.size;
      if (to < size) nodes = replaceNodes(nodes, to, size, view);
      if (from > 0) nodes = replaceNodes(nodes, 0, from, view);

      for (var i = 0; i < nodes.length; i++) {
        nodes[i].parent = copy;
      }

      copy.children = nodes;
      return copy;
    }
  }], [{
    key: "create",
    value: function create(parent, mark, inline, view) {
      var custom = view.nodeViews[mark.type.name];
      var spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom) spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
  }]);

  return MarkViewDesc;
}(ViewDesc);

var NodeViewDesc = function (_ViewDesc4) {
  _inherits(NodeViewDesc, _ViewDesc4);

  var _super4 = _createSuper(NodeViewDesc);

  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    var _this4;

    _classCallCheck(this, NodeViewDesc);

    _this4 = _super4.call(this, parent, [], dom, contentDOM);
    _this4.node = node;
    _this4.outerDeco = outerDeco;
    _this4.innerDeco = innerDeco;
    _this4.nodeDOM = nodeDOM;
    if (contentDOM) _this4.updateChildren(view, pos);
    return _this4;
  }

  _createClass(NodeViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var _this5 = this;

      if (this.node.type.spec.reparseInView) return null;
      var rule = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";

      if (!this.contentDOM) {
        rule.getContent = function () {
          return _this5.node.content;
        };
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (var i = this.children.length - 1; i >= 0; i--) {
          var child = this.children[i];

          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }

        if (!rule.contentElement) rule.getContent = function () {
          return prosemirrorModel.Fragment.empty;
        };
      }

      return rule;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
  }, {
    key: "size",
    get: function get() {
      return this.node.nodeSize;
    }
  }, {
    key: "border",
    get: function get() {
      return this.node.isLeaf ? 0 : 1;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren(view, pos) {
      var _this6 = this;

      var inline = this.node.inlineContent,
          off = pos;
      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, function (child, outerDeco, innerDeco, i) {
        updater.syncToMarks(child.marks, inline, view);
        var compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ;else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock) updater.addTextblockHacks();
      updater.destroyRest();

      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition) this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios) iosHacks(this.dom);
      }
    }
  }, {
    key: "localCompositionInfo",
    value: function localCompositionInfo(view, pos) {
      var _view$state$selection = view.state.selection,
          from = _view$state$selection.from,
          to = _view$state$selection.to;
      if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) return null;
      var sel = view.domSelection();
      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;

      if (this.node.inlineContent) {
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
        return textPos < 0 ? null : {
          node: textNode,
          pos: textPos,
          text: text
        };
      } else {
        return {
          node: textNode,
          pos: -1,
          text: ""
        };
      }
    }
  }, {
    key: "protectLocalComposition",
    value: function protectLocalComposition(view, _ref2) {
      var node = _ref2.node,
          pos = _ref2.pos,
          text = _ref2.text;
      if (this.getDesc(node)) return;
      var topNode = node;

      for (;; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) break;

        while (topNode.previousSibling) {
          topNode.parentNode.removeChild(topNode.previousSibling);
        }

        while (topNode.nextSibling) {
          topNode.parentNode.removeChild(topNode.nextSibling);
        }

        if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;
      }

      var desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
  }, {
    key: "updateInner",
    value: function updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM) this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
  }, {
    key: "updateOuterDeco",
    value: function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) return;
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));

      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = undefined;
        this.dom.pmViewDesc = this;
      }

      this.outerDeco = outerDeco;
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute("draggable");
    }
  }, {
    key: "domAtom",
    get: function get() {
      return this.node.isAtom;
    }
  }], [{
    key: "create",
    value: function create(parent, node, outerDeco, innerDeco, view, pos) {
      var custom = view.nodeViews[node.type.name],
          descObj;
      var spec = custom && custom(node, view, function () {
        if (!descObj) return pos;
        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom,
          contentDOM = spec && spec.contentDOM;

      if (node.isText) {
        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        var _prosemirrorModel$DOM = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));

        dom = _prosemirrorModel$DOM.dom;
        contentDOM = _prosemirrorModel$DOM.contentDOM;
      }

      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
        if (node.type.spec.draggable) dom.draggable = true;
      }

      var nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
  }]);

  return NodeViewDesc;
}(ViewDesc);

function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
}

var TextViewDesc = function (_NodeViewDesc) {
  _inherits(TextViewDesc, _NodeViewDesc);

  var _super5 = _createSuper(TextViewDesc);

  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    _classCallCheck(this, TextViewDesc);

    return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }

  _createClass(TextViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var skip = this.nodeDOM.parentNode;

      while (skip && skip != this.dom && !skip.pmIsDeco) {
        skip = skip.parentNode;
      }

      return {
        skip: skip || true
      };
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
      this.updateOuterDeco(outerDeco);

      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
      }

      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
  }, {
    key: "inParent",
    value: function inParent() {
      var parentDOM = this.parent.contentDOM;

      for (var n = this.nodeDOM; n; n = n.parentNode) {
        if (n == parentDOM) return true;
      }

      return false;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.nodeDOM,
        offset: pos
      };
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
      return _get(_getPrototypeOf(TextViewDesc.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var node = this.node.cut(from, to),
          dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(TextViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }]);

  return TextViewDesc;
}(NodeViewDesc);

var TrailingHackViewDesc = function (_ViewDesc5) {
  _inherits(TrailingHackViewDesc, _ViewDesc5);

  var _super6 = _createSuper(TrailingHackViewDesc);

  function TrailingHackViewDesc() {
    _classCallCheck(this, TrailingHackViewDesc);

    return _super6.apply(this, arguments);
  }

  _createClass(TrailingHackViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return this.dom.nodeName == "IMG";
    }
  }]);

  return TrailingHackViewDesc;
}(ViewDesc);

var CustomNodeViewDesc = function (_NodeViewDesc2) {
  _inherits(CustomNodeViewDesc, _NodeViewDesc2);

  var _super7 = _createSuper(CustomNodeViewDesc);

  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    var _this7;

    _classCallCheck(this, CustomNodeViewDesc);

    _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    _this7.spec = spec;
    return _this7;
  }

  _createClass(CustomNodeViewDesc, [{
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) return false;

      if (this.spec.update) {
        var result = this.spec.update(node, outerDeco, innerDeco);
        if (result) this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "selectNode", this).call(this);
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "deselectNode", this).call(this);
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "setSelection", this).call(this, anchor, head, root, force);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.spec.destroy) this.spec.destroy();

      _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "ignoreMutation", this).call(this, mutation);
    }
  }]);

  return CustomNodeViewDesc;
}(NodeViewDesc);

function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild,
      written = false;

  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i],
        childDOM = desc.dom;

    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }

      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }

    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }

  while (dom) {
    dom = rm(dom);
    written = true;
  }

  if (written && view.trackWrites == parentDOM) view.trackWrites = null;
}

var OuterDecoLevel = function OuterDecoLevel(nodeName) {
  if (nodeName) this.nodeName = nodeName;
};

OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel()];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) return noDeco;
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
      result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) continue;
    if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) continue;
      if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class") top["class"] = (top["class"] ? top["class"] + " " : "") + val;else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;else if (name != "nodeName") top[name] = val;
    }
  }

  return result;
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
  var curDOM = nodeDOM;

  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i],
        prev = prevComputed[i];

    if (i) {
      var parent = void 0;

      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }

    patchAttributes(curDOM, prev || noDeco[0], deco);
  }

  return curDOM;
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
  }

  for (var _name in cur) {
    if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);
  }

  if (prev["class"] != cur["class"]) {
    var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
    var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];

    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);
    }

    for (var _i = 0; _i < curList.length; _i++) {
      if (prevList.indexOf(curList[_i]) == -1) dom.classList.add(curList[_i]);
    }

    if (dom.classList.length == 0) dom.removeAttribute("class");
  }

  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
          m;

      while (m = prop.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }

    if (cur.style) dom.style.cssText += cur.style;
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}

function sameOuterDeco(a, b) {
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) return false;
  }

  return true;
}

function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}

var ViewTreeUpdater = function () {
  function ViewTreeUpdater(top, lock) {
    _classCallCheck(this, ViewTreeUpdater);

    this.lock = lock;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }

  _createClass(ViewTreeUpdater, [{
    key: "destroyBetween",
    value: function destroyBetween(start, end) {
      if (start == end) return;

      for (var i = start; i < end; i++) {
        this.top.children[i].destroy();
      }

      this.top.children.splice(start, end - start);
      this.changed = true;
    }
  }, {
    key: "destroyRest",
    value: function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
  }, {
    key: "syncToMarks",
    value: function syncToMarks(marks, inline, view) {
      var keep = 0,
          depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);

      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
        keep++;
      }

      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }

      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;

        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks[depth])) {
            found = i;
            break;
          }
        }

        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }

          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }

        this.index = 0;
        depth++;
      }
    }
  }, {
    key: "findNodeMatch",
    value: function findNodeMatch(node, outerDeco, innerDeco, index) {
      var found = -1,
          targetDesc;

      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          var child = this.top.children[i];

          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i;
            break;
          }
        }
      }

      if (found < 0) return false;
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    }
  }, {
    key: "updateNodeAt",
    value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
      var child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view)) return false;
      this.destroyBetween(this.index, index);
      this.index = index + 1;
      return true;
    }
  }, {
    key: "findIndexWithChild",
    value: function findIndexWithChild(domNode) {
      for (;;) {
        var parent = domNode.parentNode;
        if (!parent) return -1;

        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) for (var i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc) return i;
          }
          return -1;
        }

        domNode = parent;
      }
    }
  }, {
    key: "updateNextNode",
    value: function updateNextNode(node, outerDeco, innerDeco, view, index) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];

        if (next instanceof NodeViewDesc) {
          var _preMatch = this.preMatch.matched.get(next);

          if (_preMatch != null && _preMatch != index) return false;
          var nextDOM = next.dom;
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));

          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) this.changed = true;
            this.index++;
            return true;
          }

          break;
        }
      }

      return false;
    }
  }, {
    key: "addNode",
    value: function addNode(node, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
      this.changed = true;
    }
  }, {
    key: "placeWidget",
    value: function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;

      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
  }, {
    key: "addTextblockHacks",
    value: function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1],
          parent = this.top;

      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }

      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
  }, {
    key: "addHackNode",
    value: function addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);

        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }

        if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
        var hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
  }]);

  return ViewTreeUpdater;
}();

function preMatch(frag, parentDesc) {
  var curDesc = parentDesc,
      descI = curDesc.children.length;
  var fI = frag.childCount,
      matched = new Map(),
      matches = [];

  outer: while (fI > 0) {
    var desc = void 0;

    for (;;) {
      if (descI) {
        var next = curDesc.children[descI - 1];

        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }

    var node = desc.node;
    if (!node) continue;
    if (node != frag.child(fI - 1)) break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }

  return {
    index: fI,
    matched: matched,
    matches: matches.reverse()
  };
}

function compareSide(a, b) {
  return a.type.side - b.type.side;
}

function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent),
      offset = 0;

  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }

    return;
  }

  var decoIndex = 0,
      active = [],
      restNode = null;

  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++],
          widgets = void 0;

      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      }

      if (widgets) {
        widgets.sort(compareSide);

        for (var _i2 = 0; _i2 < widgets.length; _i2++) {
          onWidget(widgets[_i2], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var _child = void 0,
        index = void 0;

    if (restNode) {
      index = -1;
      _child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      _child = parent.child(parentIndex++);
    } else {
      break;
    }

    for (var _i3 = 0; _i3 < active.length; _i3++) {
      if (active[_i3].to <= offset) active.splice(_i3--, 1);
    }

    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {
      active.push(locals[decoIndex++]);
    }

    var end = offset + _child.nodeSize;

    if (_child.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;

      for (var _i4 = 0; _i4 < active.length; _i4++) {
        if (active[_i4].to < cutAt) cutAt = active[_i4].to;
      }

      if (cutAt < end) {
        restNode = _child.cut(cutAt - offset);
        _child = _child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function (d) {
      return !d.inline;
    }) : active.slice();
    onNode(_child, outerDeco, deco.forChild(offset, _child), index);
    offset = end;
  }
}

function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) return node;

    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}

function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++),
        childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) continue;
    var str = child.text;

    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) break;
      str += next.text;
    }

    if (pos >= from) {
      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from) return childStart + found;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
    }
  }

  return -1;
}

function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];

  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i],
        start = off,
        end = off += child.size;

    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) result.push(child.slice(0, from - start, view));

      if (replacement) {
        result.push(replacement);
        replacement = undefined;
      }

      if (end > to) result.push(child.slice(to - start, child.size, view));
    }
  }

  return result;
}

function selectionFromDOM(view) {
  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var domSel = view.domSelection(),
      doc = view.state.doc;
  if (!domSel.focusNode) return null;
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode),
      inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0) return null;
  var $head = doc.resolve(head),
      $anchor,
      selection;

  if (selectionCollapsed(domSel)) {
    $anchor = $head;

    while (nearestDesc && !nearestDesc.node) {
      nearestDesc = nearestDesc.parent;
    }

    var nearestDescNode = nearestDesc.node;

    if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0) return null;
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }

  return selection;
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}

function selectionToDOM(view) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) return;

  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    var domSel = view.domSelection(),
        curSel = view.domObserver.currentSelection;

    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor,
        head = sel.head,
        resetEditableFrom,
        resetEditableTo;

    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
      if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
    }

    view.docView.setSelection(anchor, head, view.root, force);

    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) resetEditable(resetEditableFrom);
      if (resetEditableTo) resetEditable(resetEditableTo);
    }

    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) removeClassOnSelectionChange(view);
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),
      node = _view$docView$domFrom3.node,
      offset = _view$docView$domFrom3.offset;

  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false") return setEditable(after);

  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) return setEditable(after);else if (before) return setEditable(before);
  }
}

function setEditable(element) {
  element.contentEditable = "true";

  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }

  return element;
}

function resetEditable(element) {
  element.contentEditable = "false";

  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  var domSel = view.domSelection();
  var node = domSel.anchorNode,
      offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.input.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.domSelection(),
      range = document.createRange();
  var node = view.cursorWrapper.dom,
      img = node.nodeName == "IMG";
  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);else range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);

  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirrorState.NodeSelection) {
    var desc = view.docView.descAt(sel.from);

    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = undefined;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) {
    return f(view, $anchor, $head);
  }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) return false;
  return hasSelection(view);
}

function hasSelection(view) {
  var sel = view.domSelection();
  if (!sel.anchorNode) return false;

  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.domSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}

function moveSelectionBlock(state, dir) {
  var _state$selection = state.selection,
      $anchor = _state$selection.$anchor,
      $head = _state$selection.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirrorState.Selection.findFrom($start, dir);
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;

  if (sel instanceof prosemirrorState.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head,
          node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter,
          desc;
      if (!node || node.isText) return false;
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;

      if (prosemirrorState.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var _next = moveSelectionBlock(view.state, dir);

    if (_next) return apply(view, _next);
    return false;
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}

function skipIgnoredNodesLeft(view) {
  var sel = view.domSelection();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var moveNode,
      moveOffset,
      force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true;

  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        var before = node.childNodes[offset - 1];

        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      var prev = node.previousSibling;

      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }

      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }

  if (force) setSelFocus(view, sel, node, offset);else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

function skipIgnoredNodesRight(view) {
  var sel = view.domSelection();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var len = nodeLen(node);
  var moveNode, moveOffset;

  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) break;
      var after = node.childNodes[offset];

      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      } else break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      var next = node.nextSibling;

      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }

      if (!next) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }

  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }

  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function () {
    if (view.state == state) selectionToDOM(view);
  }, 50);
}

function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
  if (mac && mods.indexOf("m") > -1) return false;
  var $from = sel.$from,
      $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
  }

  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }

  return false;
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) return true;
  var _view$state$selection2 = view.state.selection,
      $head = _view$state$selection2.$head,
      $anchor = _view$state$selection2.$anchor,
      empty = _view$state$selection2.empty;
  if (!$head.sameParent($anchor)) return true;
  if (!empty) return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);

  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);else tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }

  return false;
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0) return false;

  var _view$domSelection = view.domSelection(),
      focusNode = _view$domSelection.focusNode,
      focusOffset = _view$domSelection.focusOffset;

  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(function () {
      return switchEditable(view, child, "false");
    }, 20);
  }

  return false;
}

function getMods(event) {
  var result = "";
  if (event.ctrlKey) result += "c";
  if (event.metaKey) result += "m";
  if (event.altKey) result += "a";
  if (event.shiftKey) result += "s";
  return result;
}

function captureKeyDown(view, event) {
  var code = event.keyCode,
      mods = getMods(event);

  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }

  return false;
}

function serializeForClipboard(view, slice) {
  var context = [],
      content = slice.content,
      openStart = slice.openStart,
      openEnd = slice.openEnd;

  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(),
      wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {
    document: doc
  }));
  var firstChild = wrap.firstChild,
      needsWrap,
      wrappers = 0;

  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);

      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }

      wrap.appendChild(wrapper);
      wrappers++;
    }

    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
  var text = view.someProp("clipboardTextSerializer", function (f) {
    return f(slice);
  }) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return {
    dom: wrap,
    text: text
  };
}

function parseFromClipboard(view, text, html, plainText, $context) {
  var inCode = $context.parent.type.spec.code;
  var dom, slice;
  if (!html && !text) return null;
  var asText = text && (plainText || inCode || !html);

  if (asText) {
    view.someProp("transformPastedText", function (f) {
      text = f(text, inCode || plainText);
    });
    if (inCode) return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirrorModel.Slice.empty;
    var parsed = view.someProp("clipboardTextParser", function (f) {
      return f(text, $context, plainText);
    });

    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var schema = view.state.schema,
          serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) {
      html = f(html);
    });
    dom = readHTML(html);
    if (webkit) restoreReplacedSpaces(dom);
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0 && dom.firstChild; i--) {
    dom = dom.firstChild;
  }

  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode(dom) {
        if (dom.nodeName == "BR" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {
          ignore: true
        };
        return null;
      }
    });
  }

  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);

    if (slice.openStart || slice.openEnd) {
      var openStart = 0,
          openEnd = 0;

      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}

      for (var _node = slice.content.lastChild; openEnd < slice.openEnd && !_node.type.spec.isolating; openEnd++, _node = _node.lastChild) {}

      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) {
    slice = f(slice);
  });
  return slice;
}

var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;

function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) return fragment;

  var _loop = function _loop(d) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = void 0,
        result = [];
    fragment.forEach(function (node) {
      if (!result) return;
      var wrap = match.findWrapping(node.type),
          inLast;
      if (!wrap) return result = null;

      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result) return {
      v: prosemirrorModel.Fragment.from(result)
    };
  };

  for (var d = $context.depth; d >= 0; d--) {
    var _ret = _loop(d);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return fragment;
}

function withWrappers(node, wrap) {
  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  for (var i = wrap.length - 1; i >= from; i--) {
    node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
  }

  return node;
}

function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}

function closeRight(node, depth) {
  if (depth == 0) return node;
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
  return node.copy(fragment.append(fill));
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild,
      inner = node.content;
  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart) slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd) slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}

var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;

function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) html = html.slice(metas[0].length);
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html),
      wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function (n) {
    return "<" + n + ">";
  }).join("") + html + wrap.map(function (n) {
    return "</" + n + ">";
  }).reverse().join("");
  elt.innerHTML = html;
  if (wrap) for (var i = 0; i < wrap.length; i++) {
    elt = elt.querySelector(wrap[i]) || elt;
  }
  return elt;
}

function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}

function addContext(slice, context) {
  if (!slice.size) return slice;
  var schema = slice.content.firstChild.type.schema,
      array;

  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }

  var content = slice.content,
      openStart = slice.openStart,
      openEnd = slice.openEnd;

  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) break;
    content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }

  return new prosemirrorModel.Slice(content, openStart, openEnd);
}

var handlers = {};
var editHandlers = {};

var InputState = _createClass(function InputState() {
  _classCallCheck(this, InputState);

  this.shiftKey = false;
  this.mouseDown = null;
  this.lastKeyCode = null;
  this.lastKeyCodeTime = 0;
  this.lastClick = {
    time: 0,
    x: 0,
    y: 0,
    type: ""
  };
  this.lastSelectionOrigin = null;
  this.lastSelectionTime = 0;
  this.lastIOSEnter = 0;
  this.lastIOSEnterFallbackTimeout = -1;
  this.lastAndroidDelete = 0;
  this.composing = false;
  this.composingTimeout = -1;
  this.compositionNodes = [];
  this.compositionEndedAt = -2e8;
  this.domChangeCount = 0;
  this.eventHandlers = Object.create(null);
  this.hideSelectionGuard = null;
});

function initInput(view) {
  var _loop2 = function _loop2(event) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);
    });
  };

  for (var event in handlers) {
    _loop2(event);
  }

  if (safari) view.dom.addEventListener("input", function () {
    return null;
  });
  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();

  for (var type in view.input.eventHandlers) {
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  }

  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {
        return runCustomHandler(view, event);
      });
    }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;

  for (var node = event.target; node != view.dom; node = node.parentNode) {
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
  }

  return true;
}

function _dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);
}

editHandlers.keydown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13) return;
  if (event.keyCode != 229) view.domObserver.forceFlush();

  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        });
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) {
    return f(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, event) {
  if (event.keyCode == 16) view.input.shiftKey = false;
};

editHandlers.keypress = function (view, _event) {
  var event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;

  if (view.someProp("handleKeyPress", function (f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }

  var sel = view.state.selection;

  if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function (f) {
      return f(view, sel.$from.pos, sel.$to.pos, text);
    })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};

function eventCoords(event) {
  return {
    left: event.clientX,
    top: event.clientY
  };
}

function isNear(event, click) {
  var dx = click.x - event.clientX,
      dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside);

  var _loop3 = function _loop3(i) {
    if (view.someProp(propName, function (f) {
      return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);
    })) return {
      v: true
    };
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var _ret2 = _loop3(i);

    if (_typeof(_ret2) === "object") return _ret2.v;
  }

  return false;
}

function updateSelection(view, selection, origin) {
  if (!view.focused) view.focus();
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") tr.setMeta("pointer", true);
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside),
      node = $pos.nodeAfter;

  if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
    return true;
  }

  return false;
}

function selectClickedNode(view, inside) {
  if (inside == -1) return false;
  var sel = view.state.selection,
      selectedNode,
      selectAt;
  if (sel instanceof prosemirrorState.NodeSelection) selectedNode = sel.node;
  var $pos = view.state.doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);

    if (prosemirrorState.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(i);
      break;
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
    return f(view, pos, event);
  });
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) return false;
  var doc = view.state.doc;

  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true;
    }

    return false;
  }

  var $pos = doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent) updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");else if (prosemirrorState.NodeSelection.isSelectable(node)) updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), "pointer");else continue;
    return true;
  }
}

function forceDOMFlush(view) {
  return endComposition(view);
}

var selectNodeModifier = mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(),
      type = "singleClick";

  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick") type = "doubleClick";else if (view.input.lastClick.type == "doubleClick") type = "tripleClick";
  }

  view.input.lastClick = {
    time: now,
    x: event.clientX,
    y: event.clientY,
    type: type
  };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) return;

  if (type == "singleClick") {
    if (view.input.mouseDown) view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function () {
  function MouseDown(view, pos, event, flushed) {
    var _this8 = this;

    _classCallCheck(this, MouseDown);

    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    var targetNode, targetPos;

    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }

    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var selection = view.state.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
    };

    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = true;
      if (this.mightDrag.setUneditable) setTimeout(function () {
        if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute("contentEditable", "false");
      }, 20);
      this.view.domObserver.start();
    }

    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }

  _createClass(MouseDown, [{
    key: "done",
    value: function done() {
      var _this9 = this;

      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);

      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }

      if (this.delayedSelectionSync) setTimeout(function () {
        return selectionToDOM(_this9.view);
      });
      this.view.input.mouseDown = null;
    }
  }, {
    key: "up",
    value: function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target)) return;
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));

      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !(this.view.state.selection instanceof prosemirrorState.TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
  }, {
    key: "move",
    value: function move(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) this.done();
    }
  }]);

  return MouseDown;
}();

handlers.touchdown = function (view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) {
  return forceDOMFlush(view);
};

function inOrNearComposition(view, event) {
  if (view.composing) return true;

  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }

  return false;
}

var timeoutComposition = android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state,
        $pos = state.selection.$from;

    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) {
      return m.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);

      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.domSelection();

        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) break;

          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }

    view.input.composing = true;
  }

  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1) view.input.composingTimeout = setTimeout(function () {
    return endComposition(view);
  }, delay);
}

function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }

  while (view.input.compositionNodes.length > 0) {
    view.input.compositionNodes.pop().markParentsDirty();
  }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}

function endComposition(view) {
  var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (android && view.domObserver.flushingSoon >= 0) return;
  view.domObserver.forceFlush();
  clearComposition(view);

  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else view.updateState(view.state);
    return true;
  }

  return false;
}

function captureCopy(view, dom) {
  if (!view.dom.parentNode) return;
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(),
      range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}

var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;

handlers.copy = editHandlers.cut = function (view, _event) {
  var event = _event;
  var sel = view.state.selection,
      cut = event.type == "cut";
  if (sel.empty) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;

  var slice = sel.content(),
      _serializeForClipboar = serializeForClipboard(view, slice),
      dom = _serializeForClipboar.dom,
      text = _serializeForClipboar.text;

  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }

  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}

function capturePaste(view, event) {
  if (!view.dom.parentNode) return;
  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) target.parentNode.removeChild(target);
    if (plainText) doPaste(view, target.value, null, event);else doPaste(view, target.textContent, target.innerHTML, event);
  }, 50);
}

function doPaste(view, text, html, event) {
  var slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty);
  })) return true;
  if (!slice) return false;
  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}

editHandlers.paste = function (view, _event) {
  var event = _event;
  if (view.composing && !android) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event)) event.preventDefault();else capturePaste(view, event);
};

var Dragging = _createClass(function Dragging(slice, move) {
  _classCallCheck(this, Dragging);

  this.slice = slice;
  this.move = move;
});

var dragCopyModifier = mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, _event) {
  var event = _event;
  var mouseDown = view.input.mouseDown;
  if (mouseDown) mouseDown.done();
  if (!event.dataTransfer) return;
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));
  }

  var slice = view.state.selection.content(),
      _serializeForClipboar2 = serializeForClipboard(view, slice),
      dom = _serializeForClipboar2.dom,
      text = _serializeForClipboar2.text;

  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !event[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging) view.dragging = null;
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) {
  return e.preventDefault();
};

editHandlers.drop = function (view, _event) {
  var event = _event;
  var dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer) return;
  var eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos) return;
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) return;
  var slice = dragging && dragging.slice;

  if (slice) {
    view.someProp("transformPasted", function (f) {
      slice = f(slice);
    });
  } else {
    slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }

  var move = !!(dragging && !event[dragCopyModifier]);

  if (view.someProp("handleDrop", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty, move);
  })) {
    event.preventDefault();
    return;
  }

  if (!slice) return;
  event.preventDefault();
  var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) insertPos = $mouse.pos;
  var tr = view.state.tr;
  if (move) tr.deleteSelection();
  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);else tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert)) return;
  var $pos = tr.doc.resolve(pos);

  if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirrorState.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {
      return end = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }

  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelection())) selectionToDOM(view);
    }, 20);
  }
};

handlers.blur = function (view, _event) {
  var event = _event;

  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};

handlers.beforeinput = function (view, _event) {
  var event = _event;

  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.input.domChangeCount;
    setTimeout(function () {
      if (view.input.domChangeCount != domChangeCount) return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(8, "Backspace"));
      })) return;
      var $cursor = view.state.selection.$cursor;
      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};

for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}

function compareObjs(a, b) {
  if (a == b) return true;

  for (var p in a) {
    if (a[p] !== b[p]) return false;
  }

  for (var _p in b) {
    if (!(_p in a)) return false;
  }

  return true;
}

var WidgetType = function () {
  function WidgetType(toDOM, spec) {
    _classCallCheck(this, WidgetType);

    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }

  _createClass(WidgetType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),
          pos = _mapping$mapResult.pos,
          deleted = _mapping$mapResult.deleted;

      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid() {
      return true;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
  }, {
    key: "destroy",
    value: function destroy(node) {
      if (this.spec.destroy) this.spec.destroy(node);
    }
  }]);

  return WidgetType;
}();

var InlineType = function () {
  function InlineType(attrs, spec) {
    _classCallCheck(this, InlineType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(InlineType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this);
    }
  }, {
    key: "valid",
    value: function valid(_, span) {
      return span.from < span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }], [{
    key: "is",
    value: function is(span) {
      return span.type instanceof InlineType;
    }
  }]);

  return InlineType;
}();

var NodeType = function () {
  function NodeType(attrs, spec) {
    _classCallCheck(this, NodeType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(NodeType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) return null;
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) return null;
      return new Decoration(from.pos - offset, to.pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid(node, span) {
      var _node$content$findInd = node.content.findIndex(span.from),
          index = _node$content$findInd.index,
          offset = _node$content$findInd.offset,
          child;

      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return NodeType;
}();

var Decoration = function () {
  function Decoration(from, to, type) {
    _classCallCheck(this, Decoration);

    this.from = from;
    this.to = to;
    this.type = type;
  }

  _createClass(Decoration, [{
    key: "copy",
    value: function copy(from, to) {
      return new Decoration(from, to, this.type);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
  }, {
    key: "map",
    value: function map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
  }, {
    key: "spec",
    get: function get() {
      return this.type.spec;
    }
  }, {
    key: "inline",
    get: function get() {
      return this.type instanceof InlineType;
    }
  }], [{
    key: "widget",
    value: function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
  }, {
    key: "inline",
    value: function inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    }
  }, {
    key: "node",
    value: function node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    }
  }]);

  return Decoration;
}();

var none = [],
    noSpec = {};

var DecorationSet = function () {
  function DecorationSet(local, children) {
    _classCallCheck(this, DecorationSet);

    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }

  _createClass(DecorationSet, [{
    key: "find",
    value: function find(start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
  }, {
    key: "findInner",
    value: function findInner(start, end, result, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
      }

      for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {
        if (this.children[_i5] < end && this.children[_i5 + 1] > start) {
          var childOff = this.children[_i5] + 1;

          this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
  }, {
    key: "map",
    value: function map(mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) return this;
      return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    }
  }, {
    key: "mapInner",
    value: function mapInner(mapping, node, offset, oldOffset, options) {
      var newLocal;

      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[i].spec);
      }

      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
  }, {
    key: "add",
    value: function add(doc, decorations) {
      if (!decorations.length) return this;
      if (this == empty) return DecorationSet.create(doc, decorations);
      return this.addInner(doc, decorations, 0);
    }
  }, {
    key: "addInner",
    value: function addInner(doc, decorations, offset) {
      var _this10 = this;

      var children,
          childIndex = 0;
      doc.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset,
            found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;
        if (!children) children = _this10.children.slice();

        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }

        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);

      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);
      }

      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
  }, {
    key: "remove",
    value: function remove(decorations) {
      if (decorations.length == 0 || this == empty) return this;
      return this.removeInner(decorations, 0);
    }
  }, {
    key: "removeInner",
    value: function removeInner(decorations, offset) {
      var children = this.children,
          local = this.local;

      for (var i = 0; i < children.length; i += 3) {
        var found = void 0;
        var from = children[i] + offset,
            to = children[i + 1] + offset;

        for (var j = 0, span; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from && span.to < to) {
              decorations[j] = null;
              (found || (found = [])).push(span);
            }
          }
        }

        if (!found) continue;
        if (children == this.children) children = this.children.slice();
        var removed = children[i + 2].removeInner(found, from + 1);

        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }

      if (local.length) for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) {
        if (_span = decorations[_i6]) {
          for (var _j2 = 0; _j2 < local.length; _j2++) {
            if (local[_j2].eq(_span, offset)) {
              if (local == this.local) local = this.local.slice();
              local.splice(_j2--, 1);
            }
          }
        }
      }
      if (children == this.children && local == this.local) return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
  }, {
    key: "forChild",
    value: function forChild(offset, node) {
      if (this == empty) return this;
      if (node.isLeaf) return DecorationSet.empty;
      var child, local;

      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset) {
          if (this.children[i] == offset) child = this.children[i + 2];
          break;
        }
      }

      var start = offset + 1,
          end = start + node.content.size;

      for (var _i7 = 0; _i7 < this.local.length; _i7++) {
        var dec = this.local[_i7];

        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var from = Math.max(start, dec.from) - start,
              to = Math.min(end, dec.to) - start;
          if (from < to) (local || (local = [])).push(dec.copy(from, to));
        }
      }

      if (local) {
        var localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }

      return child || empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this == other) return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;

      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) return false;
      }

      for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) {
        if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      return removeOverlap(this.localsInner(node));
    }
  }, {
    key: "localsInner",
    value: function localsInner(node) {
      if (this == empty) return none;
      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
      var result = [];

      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);
      }

      return result;
    }
  }], [{
    key: "create",
    value: function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    }
  }]);

  return DecorationSet;
}();

DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;

var DecorationGroup = function () {
  function DecorationGroup(members) {
    _classCallCheck(this, DecorationGroup);

    this.members = members;
  }

  _createClass(DecorationGroup, [{
    key: "map",
    value: function map(mapping, doc) {
      var mappedDecos = this.members.map(function (member) {
        return member.map(mapping, doc, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    }
  }, {
    key: "forChild",
    value: function forChild(offset, child) {
      if (child.isLeaf) return DecorationSet.empty;
      var found = [];

      for (var i = 0; i < this.members.length; i++) {
        var result = this.members[i].forChild(offset, child);
        if (result == empty) continue;
        if (result instanceof DecorationGroup) found = found.concat(result.members);else found.push(result);
      }

      return DecorationGroup.from(found);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;

      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      var result,
          sorted = true;

      for (var i = 0; i < this.members.length; i++) {
        var locals = this.members[i].localsInner(node);
        if (!locals.length) continue;

        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }

          for (var j = 0; j < locals.length; j++) {
            result.push(locals[j]);
          }
        }
      }

      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
  }], [{
    key: "from",
    value: function from(members) {
      switch (members.length) {
        case 0:
          return empty;

        case 1:
          return members[0];

        default:
          return new DecorationGroup(members);
      }
    }
  }]);

  return DecorationGroup;
}();

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  var shift = function shift(oldStart, oldEnd, newStart, newEnd) {
    for (var i = 0; i < children.length; i += 3) {
      var end = children[i + 1],
          dSize = void 0;
      if (end < 0 || oldStart > end + oldOffset) continue;
      var start = children[i] + oldOffset;

      if (oldEnd >= start) {
        children[i + 1] = oldStart <= start ? -2 : -1;
      } else if (newStart >= offset && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };

  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift);
  }

  var mustRebuild = false;

  for (var _i9 = 0; _i9 < children.length; _i9 += 3) {
    if (children[_i9 + 1] < 0) {
      if (children[_i9 + 1] == -2) {
        mustRebuild = true;
        children[_i9 + 1] = -1;
        continue;
      }

      var from = mapping.map(oldChildren[_i9] + oldOffset),
          fromLocal = from - offset;

      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }

      var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1),
          toLocal = to - offset;

      var _node$content$findInd2 = node.content.findIndex(fromLocal),
          index = _node$content$findInd2.index,
          childOffset = _node$content$findInd2.offset;

      var childNode = node.maybeChild(index);

      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);

        if (mapped != empty) {
          children[_i9] = fromLocal;
          children[_i9 + 1] = toLocal;
          children[_i9 + 2] = mapped;
        } else {
          children[_i9 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }

  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;

    for (var _i10 = 0; _i10 < children.length; _i10 += 3) {
      if (children[_i10 + 1] < 0) {
        children.splice(_i10, 3);
        _i10 -= 3;
      }
    }

    for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {
      var _from2 = built.children[_i11];

      while (j < children.length && children[j] < _from2) {
        j += 3;
      }

      children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);
    }
  }

  return new DecorationSet(newLocal.sort(byPos), children);
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) return spans;
  var result = [];

  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }

  return result;
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[i].spec);
    }

    for (var _i12 = 0; _i12 < set.children.length; _i12 += 3) {
      gather(set.children[_i12 + 2], set.children[_i12] + oldOffset + 1);
    }
  }

  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  }

  return decorations;
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) return null;
  var end = offset + node.nodeSize,
      found = null;

  for (var i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }

  return found;
}

function withoutNulls(array) {
  var result = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) result.push(array[i]);
  }

  return result;
}

function buildTree(spans, node, offset, options) {
  var children = [],
      hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);

    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);

  for (var i = 0; i < locals.length; i++) {
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove) options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  }

  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}

function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}

function removeOverlap(spans) {
  var working = spans;

  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {
      var next = working[j];

      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) working = spans.slice();
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }

        continue;
      } else {
        if (next.from < span.to) {
          if (working == spans) working = spans.slice();
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }

        break;
      }
    }
  }

  return working;
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }

  array.splice(i, 0, deco);
}

function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) found.push(result);
  });
  if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;

var SelectionState = function () {
  function SelectionState() {
    _classCallCheck(this, SelectionState);

    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }

  _createClass(SelectionState, [{
    key: "set",
    value: function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.anchorNode = this.focusNode = null;
    }
  }, {
    key: "eq",
    value: function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }]);

  return SelectionState;
}();

var DOMObserver = function () {
  function DOMObserver(view, handleDOMChange) {
    var _this11 = this;

    _classCallCheck(this, DOMObserver);

    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        _this11.queue.push(mutations[i]);
      }

      if (ie && ie_version <= 11 && mutations.some(function (m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      })) _this11.flushSoon();else _this11.flush();
    });

    if (useCharData) {
      this.onCharData = function (e) {
        _this11.queue.push({
          target: e.target,
          type: "characterData",
          oldValue: e.prevValue
        });

        _this11.flushSoon();
      };
    }

    this.onSelectionChange = this.onSelectionChange.bind(this);
  }

  _createClass(DOMObserver, [{
    key: "flushSoon",
    value: function flushSoon() {
      var _this12 = this;

      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {
        _this12.flushingSoon = -1;

        _this12.flush();
      }, 20);
    }
  }, {
    key: "forceFlush",
    value: function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.observer) this.observer.observe(this.view.dom, observeOptions);
      if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this13 = this;

      if (this.observer) {
        var take = this.observer.takeRecords();

        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }

          window.setTimeout(function () {
            return _this13.flush();
          }, 20);
        }

        this.observer.disconnect();
      }

      if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
  }, {
    key: "connectSelection",
    value: function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "disconnectSelection",
    value: function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "suppressSelectionUpdates",
    value: function suppressSelectionUpdates() {
      var _this14 = this;

      this.suppressingSelectionUpdates = true;
      setTimeout(function () {
        return _this14.suppressingSelectionUpdates = false;
      }, 50);
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) return;
      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);

      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.domSelection();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
      }

      this.flush();
    }
  }, {
    key: "setCurSelection",
    value: function setCurSelection() {
      this.currentSelection.set(this.view.domSelection());
    }
  }, {
    key: "ignoreSelectionChange",
    value: function ignoreSelectionChange(sel) {
      if (sel.rangeCount == 0) return true;
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);

      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      if (!this.view.docView || this.flushingSoon > -1) return;
      var mutations = this.observer ? this.observer.takeRecords() : [];

      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }

      var sel = this.view.domSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);
      var from = -1,
          to = -1,
          typeOver = false,
          added = [];

      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result = this.registerMutation(mutations[i], added);

          if (result) {
            from = from < 0 ? result.from : Math.min(result.from, from);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver) typeOver = true;
          }
        }
      }

      if (gecko && added.length > 1) {
        var brs = added.filter(function (n) {
          return n.nodeName == "BR";
        });

        if (brs.length == 2) {
          var a = brs[0],
              b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();
        }
      }

      if (from > -1 || newSel) {
        if (from > -1) {
          this.view.docView.markDirty(from, to);
          checkCSS(this.view);
        }

        this.handleDOMChange(from, to, typeOver, added);
        if (this.view.docView && this.view.docView.dirty) this.view.updateState(this.view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view);
        this.currentSelection.set(sel);
      }
    }
  }, {
    key: "registerMutation",
    value: function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) return null;
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
      if (!desc || desc.ignoreMutation(mut)) return null;

      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }

        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
          from: desc.posBefore,
          to: desc.posAfter
        };
        var prev = mut.previousSibling,
            next = mut.nextSibling;

        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (var _i13 = 0; _i13 < mut.addedNodes.length; _i13++) {
            var _mut$addedNodes$_i = mut.addedNodes[_i13],
                previousSibling = _mut$addedNodes$_i.previousSibling,
                nextSibling = _mut$addedNodes$_i.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
          }
        }

        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {
          from: from,
          to: to
        };
      } else if (mut.type == "attributes") {
        return {
          from: desc.posAtStart - desc.border,
          to: desc.posAtEnd + desc.border
        };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }]);

  return DOMObserver;
}();

var cssChecked = false;

function checkCSS(view) {
  if (cssChecked) return;
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
}

function parseBetween(view, from_, to_) {
  var _view$docView$parseRa = view.docView.parseRange(from_, to_),
      parent = _view$docView$parseRa.node,
      fromOffset = _view$docView$parseRa.fromOffset,
      toOffset = _view$docView$parseRa.toOffset,
      from = _view$docView$parseRa.from,
      to = _view$docView$parseRa.to;

  var domSel = view.domSelection();
  var find;
  var anchor = domSel.anchorNode;

  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{
      node: anchor,
      offset: domSel.anchorOffset
    }];
    if (!selectionCollapsed(domSel)) find.push({
      node: domSel.focusNode,
      offset: domSel.focusOffset
    });
  }

  if (chrome && view.input.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1],
          desc = node.pmViewDesc;

      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }

      if (!desc || desc.size) break;
    }
  }

  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);
  var sel = null,
      doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });

  if (find && find[0].pos != null) {
    var _anchor = find[0].pos,
        head = find[1] && find[1].pos;
    if (head == null) head = _anchor;
    sel = {
      anchor: _anchor + from,
      head: head + from
    };
  }

  return {
    doc: doc,
    sel: sel,
    from: from,
    to: to
  };
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;

  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {
        skip: skip
      };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {
        ignore: true
      };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {
      ignore: true
    };
  }

  return null;
}

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);

    if (newSel && !view.state.selection.eq(newSel)) {
      var _tr = view.state.tr.setSelection(newSel);

      if (origin == "pointer") _tr.setMeta("pointer", true);else if (origin == "key") _tr.scrollIntoView();
      view.dispatch(_tr);
    }

    return;
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);

  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = {
      anchor: parse.sel.anchor + size,
      head: parse.sel.anchor + size
    };
  }

  var doc = view.state.doc,
      compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;

  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }

  view.input.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (!change) {
    if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {
        start: sel.from,
        endA: sel.to,
        endB: sel.to
      };
    } else {
      if (parse.sel) {
        var _sel = resolveSelection(view, view.state.doc, parse.sel);

        if (_sel && !_sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(_sel));
      }

      return;
    }
  }

  view.input.domChangeCount++;

  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }

  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var $fromA = doc.resolve(change.start);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  var nextSel;

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (android && chrome) view.domObserver.suppressSelectionUpdates();
    return;
  }

  if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();

  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }

  var chFrom = change.start,
      chTo = change.endA;
  var tr, storedMarks, markChange;

  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () {
          return selectionToDOM(view);
        }, 20);
      }

      tr = view.state.tr["delete"](chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var _text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);

      if (view.someProp("handleTextInput", function (f) {
        return f(view, chFrom, chTo, _text);
      })) return;
      tr = view.state.tr.insertText(_text, chFrom, chTo);
    }
  }

  if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));

  if (parse.sel) {
    var _sel2 = resolveSelection(view, tr.doc, parse.sel);

    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom)) tr.setSelection(_sel2);
  }

  if (storedMarks) tr.ensureMarks(storedMarks);
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}

function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks,
      prevMarks = prev.firstChild.marks;
  var added = curMarks,
      removed = prevMarks,
      type,
      mark,
      update;

  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }

  for (var _i14 = 0; _i14 < curMarks.length; _i14++) {
    removed = curMarks[_i14].removeFromSet(removed);
  }

  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";

    update = function update(node) {
      return node.mark(mark.addToSet(node.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";

    update = function update(node) {
      return node.mark(mark.removeFromSet(node.marks));
    };
  } else {
    return null;
  }

  var updated = [];

  for (var _i15 = 0; _i15 < prev.childCount; _i15++) {
    updated.push(update(prev.child(_i15)));
  }

  if (prosemirrorModel.Fragment.from(updated).eq(cur)) return {
    mark: mark,
    type: type
  };
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
  var $start = old.resolve(start);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth,
      end = fromEnd ? $pos.end() : $pos.pos;

  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }

  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));

    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }

  return end;
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) return null;

  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),
      endA = _a$findDiffEnd.a,
      endB = _a$findDiffEnd.b;

  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }

  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;

    start -= _move;
    endA = start + (endA - endB);
    endB = start;
  }

  return {
    start: start,
    endA: endA,
    endB: endB
  };
}

var __serializeForClipboard = serializeForClipboard;
var __parseFromClipboard = parseFromClipboard;
var __endComposition = endComposition;

var EditorView = function () {
  function EditorView(place, props) {
    var _this15 = this;

    _classCallCheck(this, EditorView);

    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = undefined;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");

    if (place) {
      if (place.appendChild) place.appendChild(this.dom);else if (typeof place == "function") place(this.dom);else if (place.mount) this.mounted = true;
    }

    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, function (from, to, typeOver, added) {
      return readDOMChange(_this15, from, to, typeOver, added);
    });
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }

  _createClass(EditorView, [{
    key: "composing",
    get: function get() {
      return this.input.composing;
    }
  }, {
    key: "props",
    get: function get() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};

        for (var name in prev) {
          this._props[name] = prev[name];
        }

        this._props.state = this.state;
      }

      return this._props;
    }
  }, {
    key: "update",
    value: function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
      this._props = props;

      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }

      this.updateStateInner(props.state, true);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      var updated = {};

      for (var name in this._props) {
        updated[name] = this._props[name];
      }

      updated.state = this.state;

      for (var _name2 in props) {
        updated[_name2] = props[_name2];
      }

      this.update(updated);
    }
  }, {
    key: "updateState",
    value: function updateState(state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    }
  }, {
    key: "updateStateInner",
    value: function updateStateInner(state, reconfigured) {
      var _this16 = this;

      var prev = this.state,
          redraw = false,
          updateSel = false;

      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }

      this.state = state;

      if (reconfigured) {
        var nodeViews = buildNodeViews(this);

        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }

        ensureListeners(this);
      }

      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this),
          outerDeco = computeDocDeco(this);
      var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);

        if (updateDoc) {
          var chromeKludge = chrome ? this.trackWrites = this.domSelection().focusNode : null;

          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }

          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
        }

        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }

        this.domObserver.start();
      }

      this.updatePluginViews(prev);

      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.domSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function (f) {
          return f(_this16);
        })) ;else if (state.selection instanceof prosemirrorState.NodeSelection) {
          var target = this.docView.domAfterPos(state.selection.from);
          if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
        }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
  }, {
    key: "destroyPluginViews",
    value: function destroyPluginViews() {
      var view;

      while (view = this.pluginViews.pop()) {
        if (view.destroy) view.destroy();
      }
    }
  }, {
    key: "updatePluginViews",
    value: function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();

        for (var i = 0; i < this.directPlugins.length; i++) {
          var plugin = this.directPlugins[i];
          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
        }

        for (var _i16 = 0; _i16 < this.state.plugins.length; _i16++) {
          var _plugin = this.state.plugins[_i16];
          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
        }
      } else {
        for (var _i17 = 0; _i17 < this.pluginViews.length; _i17++) {
          var pluginView = this.pluginViews[_i17];
          if (pluginView.update) pluginView.update(this, prevState);
        }
      }
    }
  }, {
    key: "someProp",
    value: function someProp(propName, f) {
      var prop = this._props && this._props[propName],
          value;
      if (prop != null && (value = f ? f(prop) : prop)) return value;

      for (var i = 0; i < this.directPlugins.length; i++) {
        var _prop = this.directPlugins[i].props[propName];
        if (_prop != null && (value = f ? f(_prop) : _prop)) return value;
      }

      var plugins = this.state.plugins;
      if (plugins) for (var _i18 = 0; _i18 < plugins.length; _i18++) {
        var _prop2 = plugins[_i18].props[propName];
        if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;
      }
    }
  }, {
    key: "hasFocus",
    value: function hasFocus() {
      return this.root.activeElement == this.dom;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.domObserver.stop();
      if (this.editable) focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
  }, {
    key: "root",
    get: function get() {
      var _this17 = this;

      var cached = this._root;

      if (cached == null) {
        var _loop4 = function _loop4(search) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {
              return search.ownerDocument.getSelection();
            };
            return {
              v: _this17._root = search
            };
          }
        };

        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          var _ret3 = _loop4(search);

          if (_typeof(_ret3) === "object") return _ret3.v;
        }
      }

      return cached || document;
    }
  }, {
    key: "posAtCoords",
    value: function posAtCoords(coords) {
      return _posAtCoords(this, coords);
    }
  }, {
    key: "coordsAtPos",
    value: function coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return _coordsAtPos(this, pos, side);
    }
  }, {
    key: "domAtPos",
    value: function domAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.docView.domFromPos(pos, side);
    }
  }, {
    key: "nodeDOM",
    value: function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
  }, {
    key: "posAtDOM",
    value: function posAtDOM(node, offset) {
      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) throw new RangeError("DOM position not inside the editor");
      return pos;
    }
  }, {
    key: "endOfTextblock",
    value: function endOfTextblock(dir, state) {
      return _endOfTextblock(this, state || this.state, dir);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.docView) return;
      destroyInput(this);
      this.destroyPluginViews();

      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }

      this.docView.destroy();
      this.docView = null;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.docView == null;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      return _dispatchEvent(this, event);
    }
  }, {
    key: "dispatch",
    value: function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));
    }
  }, {
    key: "domSelection",
    value: function domSelection() {
      return this.root.getSelection();
    }
  }]);

  return EditorView;
}();

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs["class"] = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function (value) {
    if (typeof value == "function") value = value(view.state);
    if (value) for (var attr in value) {
      if (attr == "class") attrs["class"] += " " + value[attr];

      if (attr == "style") {
        attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
      } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = {
      dom: dom,
      deco: Decoration.widget(view.state.selection.head, dom, {
        raw: true,
        marks: view.markCursor
      })
    };
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) {
    return value(view.state) === false;
  });
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}

function buildNodeViews(view) {
  var result = Object.create(null);

  function add(obj) {
    for (var _prop3 in obj) {
      if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];
    }
  }

  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}

function changedNodeViews(a, b) {
  var nA = 0,
      nB = 0;

  for (var _prop4 in a) {
    if (a[_prop4] != b[_prop4]) return true;
    nA++;
  }

  for (var _ in b) {
    nB++;
  }

  return nA != nB;
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
}

exports.Decoration = Decoration;
exports.DecorationSet = DecorationSet;
exports.EditorView = EditorView;
exports.__endComposition = __endComposition;
exports.__parseFromClipboard = __parseFromClipboard;
exports.__serializeForClipboard = __serializeForClipboard;


/***/ }),

/***/ "./node_modules/w3c-keyname/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/w3c-keyname/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

exports.base = base;
exports.keyName = keyName;
exports.shift = shift;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
/* eslint-disable import/no-extraneous-dependencies */
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");
const prosemirror_model_1 = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");
const prosemirror_schema_basic_1 = __webpack_require__(/*! prosemirror-schema-basic */ "./node_modules/prosemirror-schema-basic/dist/index.cjs");
const prosemirror_example_setup_1 = __webpack_require__(/*! prosemirror-example-setup */ "./node_modules/prosemirror-example-setup/dist/index.cjs");
const src_1 = __webpack_require__(/*! ../src */ "./src/index.ts");
const reducer_1 = __webpack_require__(/*! ./reducer */ "./demo/reducer.ts");
const editor = document.querySelector('#editor');
const content = document.querySelector('#content');
const options = {
    reducer: reducer_1.reducer,
    triggers: [
        // For demo purposes, make the `#` and `@` easier to create
        { name: 'hashtag', trigger: /(#)$/ },
        { name: 'mention', trigger: /(@)$/ },
        { name: 'emoji', trigger: ':' },
        { name: 'link', trigger: '[[', cancelOnFirstSpace: false },
        { name: 'jinja', trigger: '{{', cancelOnFirstSpace: false },
        { name: 'command', trigger: '/', decorationAttrs: { class: 'command' } },
        { name: 'variable', trigger: /((?:^[a-zA-Z0-9_]+)\s?=)$/, cancelOnFirstSpace: false },
        { name: 'code', trigger: /((?:[a-zA-Z0-9_]+)\.)$/ },
    ],
};
window.view = new prosemirror_view_1.EditorView(editor, {
    state: prosemirror_state_1.EditorState.create({
        doc: prosemirror_model_1.DOMParser.fromSchema(prosemirror_schema_basic_1.schema).parse(content),
        plugins: [...(0, src_1.autocomplete)(options), ...(0, prosemirror_example_setup_1.exampleSetup)({ schema: prosemirror_schema_basic_1.schema, menuBar: false })],
    }),
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QixnQkFBZ0I7QUFDaEIsZ0JBQWdCOzs7Ozs7Ozs7OztBQy9zQkg7O0FBRWIsa0JBQWtCLHFEQUFxRCxzQkFBc0IsT0FBTyxtREFBbUQsNkNBQTZDLG1CQUFtQiw0REFBNEQsZ0JBQWdCLGtFQUFrRSx3QkFBd0I7O0FBRTdYLDRDQUE0QyxrRUFBa0Usa0NBQWtDLDhCQUE4Qjs7QUFFOUssMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHOztBQUU1WSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GOztBQUUxUCx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTCxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USx3QkFBd0IsMkJBQTJCLHNHQUFzRyxxQkFBcUIsbUJBQW1CLDhIQUE4SDs7QUFFL1QsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFVBQVU7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLDZEQUE2RDtBQUNyRztBQUNBOztBQUVBLHdDQUF3QyxnRUFBZ0U7QUFDeEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhGQUE4RixRQUFRO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixz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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLHdDQUF3QztBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FB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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0dBQWdHLFFBQVE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFVBQVU7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7O0FBRUEscUJBQXFCLHNEQUFzRDtBQUMzRSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyw0Q0FBNEM7QUFDNUMscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRkFBcUYsdUZBQXVGO0FBQzVLOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUlBQXlJO0FBQ3pJOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtNQUFrTTtBQUNsTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9FQUFvRSw0UEFBNFAsd0VBQXdFO0FBQ3hZO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0QsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUpBQW1KLHNHQUFzRztBQUN6UDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELDBEQUEwRDs7QUFFMUcsZ0RBQWdELHVEQUF1RDs7QUFFdkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFD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QUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0EsdUpBQXVKLGtKQUFrSjtBQUN6UztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQix1QkFB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sdUJBQXVCO0FBQzlCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhFQUE4RTtBQUM5RSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQscURBQXFEO0FBQzlHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztB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RTtRQUNwQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRTtRQUNwQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUMvQixFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxLQUFLLEVBQUU7UUFDMUQsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFO1FBQzNELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsRUFBRTtRQUN4RSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLDJCQUEyQixFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRTtRQUNyRixFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLHdCQUF3QixFQUFFO0tBQ3BEO0NBQ0YsQ0FBQztBQUVELE1BQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSw2QkFBVSxDQUFDLE1BQU0sRUFBRTtJQUM1QyxLQUFLLEVBQUUsK0JBQVcsQ0FBQyxNQUFNLENBQUM7UUFDeEIsR0FBRyxFQUFFLDZCQUFTLENBQUMsVUFBVSxDQUFDLGlDQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO1FBQ2hELE9BQU8sRUFBRSxDQUFDLEdBQUcsc0JBQVksRUFBQyxPQUFPLENBQUMsRUFBRSxHQUFHLDRDQUFZLEVBQUMsRUFBRSxNQUFNLEVBQU4saUNBQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUNqRixDQUFDO0NBQ0gsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3JvcGUtc2VxdWVuY2UvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9kZW1vL3JlZHVjZXIudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL2FjdGlvbnMudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL2RlY29yYXRpb24udHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL3NyYy9pbnB1dFJ1bGVzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL3NyYy9wbHVnaW4udHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL3R5cGVzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL3NyYy91dGlscy50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvY3JlbHQvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1leGFtcGxlLXNldHVwL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWlucHV0cnVsZXMvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWtleW1hcC9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbWVudS9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1iYXNpYy9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9kZW1vL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBHT09EX0xFQUZfU0laRSA9IDIwMDtcblxuLy8gOjogY2xhc3M8VD4gQSByb3BlIHNlcXVlbmNlIGlzIGEgcGVyc2lzdGVudCBzZXF1ZW5jZSBkYXRhIHN0cnVjdHVyZVxuLy8gdGhhdCBzdXBwb3J0cyBhcHBlbmRpbmcsIHByZXBlbmRpbmcsIGFuZCBzbGljaW5nIHdpdGhvdXQgZG9pbmcgYVxuLy8gZnVsbCBjb3B5LiBJdCBpcyByZXByZXNlbnRlZCBhcyBhIG1vc3RseS1iYWxhbmNlZCB0cmVlLlxudmFyIFJvcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIFJvcGVTZXF1ZW5jZSAoKSB7fTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgb3RoZXIgPSBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcik7XG5cbiAgcmV0dXJuICghdGhpcy5sZW5ndGggJiYgb3RoZXIpIHx8XG4gICAgKG90aGVyLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIHRoaXMubGVhZkFwcGVuZChvdGhlcikpIHx8XG4gICAgKHRoaXMubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgb3RoZXIubGVhZlByZXBlbmQodGhpcykpIHx8XG4gICAgdGhpcy5hcHBlbmRJbm5lcihvdGhlcilcbn07XG5cbi8vIDo6ICh1bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIFByZXBlbmQgYW4gYXJyYXkgb3Igb3RoZXIgcm9wZSB0byB0aGlzIG9uZSwgcmV0dXJuaW5nIGEgbmV3IHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcikuYXBwZW5kKHRoaXMpXG59O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxufTtcblxuLy8gOjogKD9udW1iZXIsID9udW1iZXIpIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwZXNlbnRpbmcgYSBzdWItc2VxdWVuY2Ugb2YgdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA+PSB0bykgeyByZXR1cm4gUm9wZVNlcXVlbmNlLmVtcHR5IH1cbiAgcmV0dXJuIHRoaXMuc2xpY2VJbm5lcihNYXRoLm1heCgwLCBmcm9tKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSlcbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiBUXG4vLyBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgcmV0dXJuIHRoaXMuZ2V0SW5uZXIoaSlcbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikg4oaSID9ib29sLCA/bnVtYmVyLCA/bnVtYmVyKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHRoZSBnaXZlblxuLy8gaW5kaWNlcy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGxvb3Bpbmcgb3ZlciB0aGVcbi8vIGluZGljZXMgYW5kIGNhbGxpbmcgYGdldGAsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIHRvIGRlc2NlbmQgdGhlXG4vLyB0cmVlIGZvciBldmVyeSBlbGVtZW50LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPD0gdG8pXG4gICAgeyB0aGlzLmZvckVhY2hJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikg4oaSIFUsID9udW1iZXIsID9udW1iZXIpIOKGkiBbVV1cbi8vIE1hcCB0aGUgZ2l2ZW4gZnVuY3Rpb25zIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3BlLCBwcm9kdWNpbmdcbi8vIGEgZmxhdCBhcnJheS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWx0LCBpKSB7IHJldHVybiByZXN1bHQucHVzaChmKGVsdCwgaSkpOyB9LCBmcm9tLCB0byk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6ICg/dW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVybiB0aGUgcm9wZVxuLy8gaXRzZWxmIGlmIGEgcm9wZSB3YXMgZ2l2ZW4uXG5Sb3BlU2VxdWVuY2UuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlcykge1xuICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUm9wZVNlcXVlbmNlKSB7IHJldHVybiB2YWx1ZXMgfVxuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPyBuZXcgTGVhZih2YWx1ZXMpIDogUm9wZVNlcXVlbmNlLmVtcHR5XG59O1xuXG52YXIgTGVhZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBMZWFmKHZhbHVlcykge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBMZWFmLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBMZWFmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlYWY7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+PSB0bzsgaS0tKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLmNvbmNhdChvdGhlci5mbGF0dGVuKCkpKSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZihvdGhlci5mbGF0dGVuKCkuY29uY2F0KHRoaXMudmFsdWVzKSkgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGVhZi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMZWFmO1xufShSb3BlU2VxdWVuY2UpKTtcblxuLy8gOjogUm9wZVNlcXVlbmNlXG4vLyBUaGUgZW1wdHkgcm9wZSBzZXF1ZW5jZS5cblJvcGVTZXF1ZW5jZS5lbXB0eSA9IG5ldyBMZWFmKFtdKTtcblxudmFyIEFwcGVuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBBcHBlbmQobGVmdCwgcmlnaHQpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoO1xuICAgIHRoaXMuZGVwdGggPSBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCkgKyAxO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBBcHBlbmQuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBBcHBlbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgQXBwZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFwcGVuZDtcblxuICBBcHBlbmQucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmZsYXR0ZW4oKS5jb25jYXQodGhpcy5yaWdodC5mbGF0dGVuKCkpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlZnQubGVuZ3RoID8gdGhpcy5sZWZ0LmdldChpKSA6IHRoaXMucmlnaHQuZ2V0KGkgLSB0aGlzLmxlZnQubGVuZ3RoKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgTWF0aC5taW4odG8sIGxlZnRMZW4pLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW5uZXIoZiwgTWF0aC5tYXgoZnJvbSAtIGxlZnRMZW4sIDApLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSAtIGxlZnRMZW4sIE1hdGgubWF4KHRvLCBsZWZ0TGVuKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIE1hdGgubWluKGZyb20sIGxlZnRMZW4pLCB0bywgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAodG8gPD0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIHRvKSB9XG4gICAgaWYgKGZyb20gPj0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5yaWdodC5zbGljZShmcm9tIC0gbGVmdExlbiwgdG8gLSBsZWZ0TGVuKSB9XG4gICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCBsZWZ0TGVuKS5hcHBlbmQodGhpcy5yaWdodC5zbGljZSgwLCB0byAtIGxlZnRMZW4pKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5yaWdodC5sZWFmQXBwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBpbm5lcikgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLmxlZnQubGVhZlByZXBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZChpbm5lciwgdGhpcy5yaWdodCkgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZWZ0LmRlcHRoID49IE1hdGgubWF4KHRoaXMucmlnaHQuZGVwdGgsIG90aGVyLmRlcHRoKSArIDEpXG4gICAgICB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgbmV3IEFwcGVuZCh0aGlzLnJpZ2h0LCBvdGhlcikpIH1cbiAgICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbiAgfTtcblxuICByZXR1cm4gQXBwZW5kO1xufShSb3BlU2VxdWVuY2UpKTtcblxudmFyIHJvcGVTZXF1ZW5jZSA9IFJvcGVTZXF1ZW5jZTtcblxuZXhwb3J0IGRlZmF1bHQgcm9wZVNlcXVlbmNlO1xuIiwiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgQWN0aW9uS2luZCwgQXV0b2NvbXBsZXRlQWN0aW9uLCBGcm9tVG8gfSBmcm9tICcuLi9zcmMnO1xuaW1wb3J0IHsgY2xvc2VBdXRvY29tcGxldGUgfSBmcm9tICcuLi9zcmMvYWN0aW9ucyc7XG5cbmNvbnN0IHN1Z2dlc3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3VnZ2VzdGlvbicpIGFzIEhUTUxEaXZFbGVtZW50O1xuY29uc3QgaW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmZvJykgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbmNvbnN0IHBpY2tlciA9IHtcbiAgdmlldzogbnVsbCBhcyBFZGl0b3JWaWV3IHwgbnVsbCxcbiAgb3BlbjogZmFsc2UsXG4gIGN1cnJlbnQ6IDAsXG4gIHJhbmdlOiBudWxsIGFzIEZyb21UbyB8IG51bGwsXG59O1xuXG5jb25zdCBOVU1fU1VHR0VTVElPTlMgPSBzdWdnZXN0aW9uLmNoaWxkcmVuLmxlbmd0aDtcblxuZnVuY3Rpb24gc2V0SW5mbyhhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbikge1xuICBpbmZvLmlubmVyVGV4dCA9IGBBY3Rpb246ICR7YWN0aW9uLmtpbmR9LCBSYW5nZTogJHthY3Rpb24ucmFuZ2UuZnJvbX0tJHthY3Rpb24ucmFuZ2UudG99LCBGaWx0ZXI6ICR7YWN0aW9uLmZpbHRlcn0sIFRyaWdnZXI6ICR7YWN0aW9uLnRyaWdnZXJ9LCBUeXBlOiAke2FjdGlvbi50eXBlPy5uYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHBsYWNlU3VnZ2VzdGlvbigpIHtcbiAgc3VnZ2VzdGlvbi5zdHlsZS5kaXNwbGF5ID0gcGlja2VyLm9wZW4gPyAnYmxvY2snIDogJ25vbmUnO1xuICBjb25zdCByZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXV0b2NvbXBsZXRlJylbMF0/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoIXJlY3QpIHJldHVybjtcbiAgc3VnZ2VzdGlvbi5zdHlsZS50b3AgPSBgJHtyZWN0LnRvcCArIHJlY3QuaGVpZ2h0fXB4YDtcbiAgc3VnZ2VzdGlvbi5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgW10uZm9yRWFjaC5jYWxsKHN1Z2dlc3Rpb24uY2hpbGRyZW4sIChpdGVtOiBIVE1MRGl2RWxlbWVudCwgaSkgPT4ge1xuICAgIGl0ZW0uY2xhc3NMaXN0W2kgPT09IHBpY2tlci5jdXJyZW50ID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ3NlbGVjdGVkJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlcihhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbik6IGJvb2xlYW4ge1xuICBwaWNrZXIudmlldyA9IGFjdGlvbi52aWV3O1xuICBzZXRJbmZvKGFjdGlvbik7XG4gIHN3aXRjaCAoYWN0aW9uLmtpbmQpIHtcbiAgICBjYXNlIEFjdGlvbktpbmQub3BlbjpcbiAgICAgIHBpY2tlci5jdXJyZW50ID0gMDtcbiAgICAgIHBpY2tlci5vcGVuID0gdHJ1ZTtcbiAgICAgIHBpY2tlci5yYW5nZSA9IGFjdGlvbi5yYW5nZTtcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLmNsb3NlOlxuICAgICAgcGlja2VyLm9wZW4gPSBmYWxzZTtcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLnVwOlxuICAgICAgcGlja2VyLmN1cnJlbnQgLT0gMTtcbiAgICAgIHBpY2tlci5jdXJyZW50ICs9IE5VTV9TVUdHRVNUSU9OUzsgLy8gbmVnYXRpdmUgbW9kdWx1cyBkb2Vzbid0IHdvcmtcbiAgICAgIHBpY2tlci5jdXJyZW50ICU9IE5VTV9TVUdHRVNUSU9OUztcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLmRvd246XG4gICAgICBwaWNrZXIuY3VycmVudCArPSAxO1xuICAgICAgcGlja2VyLmN1cnJlbnQgJT0gTlVNX1NVR0dFU1RJT05TO1xuICAgICAgcGxhY2VTdWdnZXN0aW9uKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIEFjdGlvbktpbmQuZW50ZXI6IHtcbiAgICAgIGNvbnN0IHRyID0gYWN0aW9uLnZpZXcuc3RhdGUudHJcbiAgICAgICAgLmRlbGV0ZVJhbmdlKGFjdGlvbi5yYW5nZS5mcm9tLCBhY3Rpb24ucmFuZ2UudG8pXG4gICAgICAgIC5pbnNlcnRUZXh0KGBZb3UgY2FuIGRlZmluZSB0aGlzICR7YWN0aW9uLnR5cGUgPyBgJHthY3Rpb24udHlwZT8ubmFtZX0gYCA6ICcnfWFjdGlvbiFgKTtcbiAgICAgIGFjdGlvbi52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbltdLmZvckVhY2guY2FsbChzdWdnZXN0aW9uLmNoaWxkcmVuLCAoaXRlbTogSFRNTERpdkVsZW1lbnQsIGkpID0+IHtcbiAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBpZiAoIXBpY2tlci52aWV3KSByZXR1cm47XG4gICAgY2xvc2VBdXRvY29tcGxldGUocGlja2VyLnZpZXcpO1xuICAgIHBpY2tlci5vcGVuID0gZmFsc2U7XG4gICAgcGxhY2VTdWdnZXN0aW9uKCk7XG4gICAgaWYgKCFwaWNrZXIucmFuZ2UpIHJldHVybjtcbiAgICBjb25zdCB0ciA9IHBpY2tlci52aWV3LnN0YXRlLnRyXG4gICAgICAuZGVsZXRlUmFuZ2UocGlja2VyLnJhbmdlLmZyb20sIHBpY2tlci5yYW5nZS50bylcbiAgICAgIC5pbnNlcnRUZXh0KGBDbGlja2VkIG9uICR7aSArIDF9YCk7XG4gICAgcGlja2VyLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHBpY2tlci52aWV3LmZvY3VzKCk7XG4gIH0pO1xufSk7XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBBdXRvY29tcGxldGVUck1ldGEgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHBsdWdpbktleSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkF1dG9jb21wbGV0ZSh2aWV3OiBFZGl0b3JWaWV3LCB0cmlnZ2VyOiBzdHJpbmcsIGZpbHRlcj86IHN0cmluZykge1xuICAvLyBUT0RPOiBDYW4gYWN0aXZhdGUgYSB0eXBlP1xuICBjb25zdCBwbHVnaW4gPSBwbHVnaW5LZXkuZ2V0KHZpZXcuc3RhdGUpIGFzIFBsdWdpbjtcbiAgY29uc3QgbWV0YTogQXV0b2NvbXBsZXRlVHJNZXRhID0geyBhY3Rpb246ICdhZGQnLCB0cmlnZ2VyLCBmaWx0ZXIsIHR5cGU6IG51bGwgfTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgLmluc2VydFRleHQoYCR7dHJpZ2dlcn0ke2ZpbHRlciA/PyAnJ31gKVxuICAgIC5zY3JvbGxJbnRvVmlldygpXG4gICAgLnNldE1ldGEocGx1Z2luLCBtZXRhKTtcbiAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3OiBFZGl0b3JWaWV3KSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbktleS5nZXQodmlldy5zdGF0ZSkgYXMgUGx1Z2luO1xuICBjb25zdCBtZXRhOiBBdXRvY29tcGxldGVUck1ldGEgPSB7IGFjdGlvbjogJ3JlbW92ZScgfTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldE1ldGEocGx1Z2luLCBtZXRhKTtcbiAgdmlldy5kaXNwYXRjaCh0cik7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgdW5kb0lucHV0UnVsZSB9IGZyb20gJ3Byb3NlbWlycm9yLWlucHV0cnVsZXMnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgY2xvc2VBdXRvY29tcGxldGUgfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHtcbiAgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGUsXG4gIEF1dG9jb21wbGV0ZVRyTWV0YSxcbiAgRnJvbVRvLFxuICBLRUVQX09QRU4sXG4gIE9wdGlvbnMsXG4gIEF1dG9jb21wbGV0ZUFjdGlvbixcbiAgQWN0aW9uS2luZCxcbiAgQXV0b2NvbXBsZXRlU3RhdGUsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgaW5TdWdnZXN0aW9uLCBwbHVnaW5LZXkgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgaW5hY3RpdmVBdXRvY29tcGxldGVTdGF0ZTogQXV0b2NvbXBsZXRlU3RhdGUgPSB7XG4gIGFjdGl2ZTogZmFsc2UsXG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0LmVtcHR5LFxufTtcblxuZnVuY3Rpb24gYWN0aW9uRnJvbUV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogQWN0aW9uS2luZCB8IG51bGwge1xuICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgIHJldHVybiBldmVudC5rZXkgYXMgQWN0aW9uS2luZDtcbiAgICBjYXNlICdUYWInOlxuICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgIHJldHVybiBBY3Rpb25LaW5kLmVudGVyO1xuICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICByZXR1cm4gQWN0aW9uS2luZC5jbG9zZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsSWZJbnNpZGVBbmRQYXNzKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luS2V5LmdldCh2aWV3LnN0YXRlKSBhcyBQbHVnaW47XG4gIGNvbnN0IHsgZGVjb3JhdGlvbnMgfSA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKGluU3VnZ2VzdGlvbih2aWV3LnN0YXRlLnNlbGVjdGlvbiwgZGVjb3JhdGlvbnMpKSB7XG4gICAgY2xvc2VBdXRvY29tcGxldGUodmlldyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb3JhdGlvblBsdWdpbihyZWR1Y2VyOiBSZXF1aXJlZDxPcHRpb25zPlsncmVkdWNlciddKSB7XG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luPEF1dG9jb21wbGV0ZVN0YXRlPiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogcGx1Z2luS2V5LFxuICAgIHZpZXcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6ICh2aWV3LCBwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gcGx1Z2luLmdldFN0YXRlKHByZXZTdGF0ZSkgYXMgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGU7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKSBhcyBBY3RpdmVBdXRvY29tcGxldGVTdGF0ZTtcblxuICAgICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSAhcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmU7XG4gICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gbmV4dC5hY3RpdmUgJiYgIXN0YXJ0ZWQgJiYgIXN0b3BwZWQgJiYgcHJldi5maWx0ZXIgIT09IG5leHQuZmlsdGVyO1xuXG4gICAgICAgICAgY29uc3QgYWN0aW9uOiBPbWl0PEF1dG9jb21wbGV0ZUFjdGlvbiwgJ2tpbmQnPiA9IHtcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICB0cmlnZ2VyOiBuZXh0LnRyaWdnZXIgPz8gKHByZXYudHJpZ2dlciBhcyBzdHJpbmcpLFxuICAgICAgICAgICAgZmlsdGVyOiBuZXh0LmZpbHRlciA/PyBwcmV2LmZpbHRlcixcbiAgICAgICAgICAgIHJhbmdlOiBuZXh0LnJhbmdlID8/IChwcmV2LnJhbmdlIGFzIEZyb21UbyksXG4gICAgICAgICAgICB0eXBlOiBuZXh0LnR5cGUgPz8gcHJldi50eXBlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHN0YXJ0ZWQpIHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQ6IEFjdGlvbktpbmQub3BlbiB9KTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkgcmVkdWNlcih7IC4uLmFjdGlvbiwga2luZDogQWN0aW9uS2luZC5maWx0ZXIgfSk7XG4gICAgICAgICAgaWYgKHN0b3BwZWQpIHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQ6IEFjdGlvbktpbmQuY2xvc2UgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQ6ICgpID0+IGluYWN0aXZlQXV0b2NvbXBsZXRlU3RhdGUsXG4gICAgICBhcHBseSh0ciwgc3RhdGUpOiBBdXRvY29tcGxldGVTdGF0ZSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0ci5nZXRNZXRhKHBsdWdpbikgYXMgQXV0b2NvbXBsZXRlVHJNZXRhO1xuICAgICAgICBpZiAobWV0YT8uYWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlciwgZmlsdGVyLCB0eXBlIH0gPSBtZXRhO1xuICAgICAgICAgIGNvbnN0IGZyb20gPSB0ci5zZWxlY3Rpb24uZnJvbSAtIHRyaWdnZXIubGVuZ3RoIC0gKGZpbHRlcj8ubGVuZ3RoID8/IDApO1xuICAgICAgICAgIGNvbnN0IHRvID0gdHIuc2VsZWN0aW9uLmZyb207XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdHlwZT8uZGVjb3JhdGlvbkF0dHJzPy5jbGFzc1xuICAgICAgICAgICAgPyBbJ2F1dG9jb21wbGV0ZScsIHR5cGU/LmRlY29yYXRpb25BdHRycz8uY2xhc3NdLmpvaW4oJyAnKVxuICAgICAgICAgICAgOiAnYXV0b2NvbXBsZXRlJztcbiAgICAgICAgICBjb25zdCBhdHRycyA9IHsgLi4udHlwZT8uZGVjb3JhdGlvbkF0dHJzLCBjbGFzczogY2xhc3NOYW1lIH07XG4gICAgICAgICAgY29uc3QgZGVjbyA9IERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCBhdHRycywge1xuICAgICAgICAgICAgaW5jbHVzaXZlU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5jbHVzaXZlRW5kOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiBtZXRhLnRyaWdnZXIsXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldC5jcmVhdGUodHIuZG9jLCBbZGVjb10pLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIgPz8gJycsXG4gICAgICAgICAgICByYW5nZTogeyBmcm9tLCB0byB9LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVjb3JhdGlvbnMgfSA9IHN0YXRlIGFzIEF1dG9jb21wbGV0ZVN0YXRlO1xuICAgICAgICBjb25zdCBuZXh0RGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5tYXAodHIubWFwcGluZywgdHIuZG9jKTtcbiAgICAgICAgY29uc3QgaGFzRGVjb3JhdGlvbiA9IG5leHREZWNvcmF0aW9ucy5maW5kKCkubGVuZ3RoID4gMDtcbiAgICAgICAgLy8gSWYgbm8gZGVjb3JhdGlvbiwgZXhwbGljaXRseSByZW1vdmUsIG9yIGNsaWNrIHNvbWV3aGVyZSBlbHNlIGluIHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1ldGE/LmFjdGlvbiA9PT0gJ3JlbW92ZScgfHxcbiAgICAgICAgICAhaW5TdWdnZXN0aW9uKHRyLnNlbGVjdGlvbiwgbmV4dERlY29yYXRpb25zKSB8fFxuICAgICAgICAgICFoYXNEZWNvcmF0aW9uXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gaW5hY3RpdmVBdXRvY29tcGxldGVTdGF0ZTtcblxuICAgICAgICBjb25zdCB7IGFjdGl2ZSwgdHJpZ2dlciwgdHlwZSB9ID0gc3RhdGUgYXMgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGU7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGluIHRoZSBkZWNvcmF0aW9uXG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IG5leHREZWNvcmF0aW9ucy5maW5kKClbMF07XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ci5kb2MudGV4dEJldHdlZW4oZnJvbSwgdG8pO1xuICAgICAgICBpZiAoIXRleHQuc3RhcnRzV2l0aCh0cmlnZ2VyKSkgcmV0dXJuIGluYWN0aXZlQXV0b2NvbXBsZXRlU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBkZWNvcmF0aW9uczogbmV4dERlY29yYXRpb25zLFxuICAgICAgICAgIGZpbHRlcjogdGV4dC5zbGljZSh0cmlnZ2VyLmxlbmd0aCksXG4gICAgICAgICAgcmFuZ2U6IHsgZnJvbSwgdG8gfSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpPy5kZWNvcmF0aW9ucyxcbiAgICAgIGhhbmRsZVBhc3RlOiAodmlldykgPT4gY2FuY2VsSWZJbnNpZGVBbmRQYXNzKHZpZXcpLFxuICAgICAgaGFuZGxlRHJvcDogKHZpZXcpID0+IGNhbmNlbElmSW5zaWRlQW5kUGFzcyh2aWV3KSxcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB0cmlnZ2VyLCBhY3RpdmUsIGRlY29yYXRpb25zLCB0eXBlIH0gPSBwbHVnaW4uZ2V0U3RhdGUoXG4gICAgICAgICAgdmlldy5zdGF0ZSxcbiAgICAgICAgKSBhcyBBY3RpdmVBdXRvY29tcGxldGVTdGF0ZTtcblxuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAhaW5TdWdnZXN0aW9uKHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBkZWNvcmF0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBkZWNvcmF0aW9ucy5maW5kKClbMF07XG4gICAgICAgIGNvbnN0IHRleHQgPSB2aWV3LnN0YXRlLmRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0byk7XG5cbiAgICAgICAgLy8gQmUgZGVmZW5zaXZlLCBqdXN0IGluIGNhc2UgdGhlIHRyaWdnZXIgZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0ZXh0LnNsaWNlKHRyaWdnZXI/Lmxlbmd0aCA/PyAxKTtcblxuICAgICAgICBjb25zdCBjaGVja0NhbmNlbE9uU3BhY2UgPSB0eXBlPy5jYW5jZWxPbkZpcnN0U3BhY2UgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoZWNrQ2FuY2VsT25TcGFjZSAmJlxuICAgICAgICAgIGZpbHRlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAoZXZlbnQua2V5ID09PSAnICcgfHwgZXZlbnQua2V5ID09PSAnU3BhY2ViYXInKVxuICAgICAgICApIHtcbiAgICAgICAgICBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3KTtcbiAgICAgICAgICAvLyBUYWtlIG92ZXIgdGhlIHNwYWNlIGNyZWF0aW9uIHNvIG5vIG90aGVyIGlucHV0IHJ1bGVzIGFyZSBmaXJlZFxuICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KCcgJykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci5sZW5ndGggPT09IDAgJiYgZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgIHVuZG9JbnB1dFJ1bGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgY2xvc2VBdXRvY29tcGxldGUodmlldyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBraW5kID0gYWN0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgYWN0aW9uOiBPbWl0PEF1dG9jb21wbGV0ZUFjdGlvbiwgJ2tpbmQnPiA9IHtcbiAgICAgICAgICB2aWV3LFxuICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgIHJhbmdlOiB7IGZyb20sIHRvIH0sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLmNsb3NlOlxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgYWN0aW9uIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgdmlldyBjb2RlIGFib3ZlXG4gICAgICAgICAgICAvLyBBbGxvd3MgY2xpY2tpbmcgb2ZmIHRvIGJlIGhhbmRsZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgICByZXR1cm4gY2xvc2VBdXRvY29tcGxldGUodmlldyk7XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLmVudGVyOiB7XG4gICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgdGhlIGNhbmNlbCBpZiBpdCBpcyBub3QgZXhwbGl0aWNseSBoYW5kbGVkIGluIHRoZSBzZWxlY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQ6IEFjdGlvbktpbmQuZW50ZXIgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBLRUVQX09QRU4pIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLnVwOlxuICAgICAgICAgIGNhc2UgQWN0aW9uS2luZC5kb3duOlxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ocmVkdWNlcih7IC4uLmFjdGlvbiwga2luZCB9KSk7XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLmxlZnQ6XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLnJpZ2h0OlxuICAgICAgICAgICAgaWYgKCF0eXBlPy5hbGxBcnJvd0tleXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQgfSkpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcGx1Z2luO1xufVxuIiwiaW1wb3J0IHsgYXV0b2NvbXBsZXRlIH0gZnJvbSAnLi9wbHVnaW4nO1xuXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbHVnaW4nO1xuZXhwb3J0ICogZnJvbSAnLi9hY3Rpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgYXV0b2NvbXBsZXRlO1xuIiwiaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAncHJvc2VtaXJyb3ItaW5wdXRydWxlcyc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBPcGVuQXV0b2NvbXBsZXRlLCBUcmlnZ2VyIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpblN1Z2dlc3Rpb24gfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0UnVsZShwbHVnaW46IFBsdWdpbiwgdHlwZTogVHJpZ2dlcikge1xuICBjb25zdCB0cmlnZ2VyID1cbiAgICB0eXBlb2YgdHlwZS50cmlnZ2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBSZWdFeHAoYCg/Ol58XFxcXHN8XFxcXG58W15cXFxcZFxcXFx3XSkoJHt0eXBlLnRyaWdnZXIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKX0pJGApXG4gICAgICA6IHR5cGUudHJpZ2dlcjtcblxuICByZXR1cm4gbmV3IElucHV0UnVsZSh0cmlnZ2VyLCAoc3RhdGUsIG1hdGNoKSA9PiB7XG4gICAgY29uc3QgeyBkZWNvcmF0aW9ucyB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKTtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHN1Z2dlc3RpbmcsIGRvbid0IGFjdGl2YXRlXG4gICAgaWYgKGluU3VnZ2VzdGlvbihzdGF0ZS5zZWxlY3Rpb24sIGRlY29yYXRpb25zKSkgcmV0dXJuIG51bGw7XG4gICAgLy8gV2UgYXJlIHRha2luZyBvdmVyIHRoZSB0ZXh0IGlucHV0IGhlcmVcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmluc2VydFRleHQobWF0Y2hbMV1bbWF0Y2hbMV0ubGVuZ3RoIC0gMV0pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgY29uc3QgbWV0YTogT3BlbkF1dG9jb21wbGV0ZSA9IHsgYWN0aW9uOiAnYWRkJywgdHJpZ2dlcjogbWF0Y2hbMV0sIHR5cGUgfTtcbiAgICB0ci5zZXRNZXRhKHBsdWdpbiwgbWV0YSk7XG4gICAgcmV0dXJuIHRyO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGlucHV0UnVsZXMgfSBmcm9tICdwcm9zZW1pcnJvci1pbnB1dHJ1bGVzJztcbmltcG9ydCB7IE9wdGlvbnMsIEFjdGlvbktpbmQsIEF1dG9jb21wbGV0ZUFjdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0RGVjb3JhdGlvblBsdWdpbiB9IGZyb20gJy4vZGVjb3JhdGlvbic7XG5pbXBvcnQgeyBjcmVhdGVJbnB1dFJ1bGUgfSBmcm9tICcuL2lucHV0UnVsZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlZHVjZXIob3B0aW9uczogUGFydGlhbDxPcHRpb25zPikge1xuICByZXR1cm4gKGFjdGlvbjogQXV0b2NvbXBsZXRlQWN0aW9uKTogYm9vbGVhbiA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24ua2luZCkge1xuICAgICAgY2FzZSBBY3Rpb25LaW5kLm9wZW46XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9uT3Blbj8uKGFjdGlvbikgPz8gZmFsc2U7XG4gICAgICBjYXNlIEFjdGlvbktpbmQuY2xvc2U6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9uQ2xvc2U/LihhY3Rpb24pID8/IGZhbHNlO1xuICAgICAgY2FzZSBBY3Rpb25LaW5kLnVwOlxuICAgICAgY2FzZSBBY3Rpb25LaW5kLmRvd246XG4gICAgICBjYXNlIEFjdGlvbktpbmQubGVmdDpcbiAgICAgIGNhc2UgQWN0aW9uS2luZC5yaWdodDpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMub25BcnJvdz8uKGFjdGlvbikgPz8gZmFsc2U7XG4gICAgICBjYXNlIEFjdGlvbktpbmQuZmlsdGVyOlxuICAgICAgICByZXR1cm4gb3B0aW9ucy5vbkZpbHRlcj8uKGFjdGlvbikgPz8gZmFsc2U7XG4gICAgICBjYXNlIEFjdGlvbktpbmQuZW50ZXI6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9uRW50ZXI/LihhY3Rpb24pID8/IGZhbHNlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9jb21wbGV0ZShvcHRzOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgY29uc3Qgb3B0aW9uczogT3B0aW9ucyA9IHtcbiAgICB0cmlnZ2VyczogW10sXG4gICAgcmVkdWNlcjogZGVmYXVsdFJlZHVjZXIob3B0cyksXG4gICAgLi4ub3B0cyxcbiAgfTtcbiAgY29uc3QgeyByZWR1Y2VyLCB0cmlnZ2VycyB9ID0gb3B0aW9ucztcblxuICBjb25zdCBwbHVnaW4gPSBnZXREZWNvcmF0aW9uUGx1Z2luKHJlZHVjZXIpO1xuXG4gIGNvbnN0IHJ1bGVzOiBQbHVnaW5bXSA9IFtcbiAgICBwbHVnaW4sXG4gICAgaW5wdXRSdWxlcyh7XG4gICAgICAvLyBDcmVhdGUgYW4gaW5wdXQgcnVsZSBmb3IgZWFjaCB0cmlnZ2VyXG4gICAgICBydWxlczogdHJpZ2dlcnMubWFwKCh0eXBlKSA9PiBjcmVhdGVJbnB1dFJ1bGUocGx1Z2luLCB0eXBlKSksXG4gICAgfSksXG4gIF07XG4gIHJldHVybiBydWxlcztcbn1cbiIsImltcG9ydCB7IERlY29yYXRpb25BdHRycywgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG5leHBvcnQgY29uc3QgS0VFUF9PUEVOID0gJ0tFRVBfT1BFTic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJvbVRvIHtcbiAgZnJvbTogbnVtYmVyO1xuICB0bzogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBJbmFjdGl2ZUF1dG9jb21wbGV0ZVN0YXRlID0ge1xuICBhY3RpdmU6IGZhbHNlO1xuICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcbn07XG5cbmV4cG9ydCB0eXBlIEFjdGl2ZUF1dG9jb21wbGV0ZVN0YXRlID0ge1xuICBhY3RpdmU6IHRydWU7XG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xuICB0cmlnZ2VyOiBzdHJpbmc7XG4gIGZpbHRlcjogc3RyaW5nO1xuICByYW5nZTogRnJvbVRvO1xuICB0eXBlOiBUcmlnZ2VyIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIEF1dG9jb21wbGV0ZVN0YXRlID0gSW5hY3RpdmVBdXRvY29tcGxldGVTdGF0ZSB8IEFjdGl2ZUF1dG9jb21wbGV0ZVN0YXRlO1xuXG5leHBvcnQgZW51bSBBY3Rpb25LaW5kIHtcbiAgJ29wZW4nID0gJ29wZW4nLFxuICAnY2xvc2UnID0gJ2Nsb3NlJyxcbiAgJ2ZpbHRlcicgPSAnZmlsdGVyJyxcbiAgJ3VwJyA9ICdBcnJvd1VwJyxcbiAgJ2Rvd24nID0gJ0Fycm93RG93bicsXG4gICdsZWZ0JyA9ICdBcnJvd0xlZnQnLFxuICAncmlnaHQnID0gJ0Fycm93UmlnaHQnLFxuICAnZW50ZXInID0gJ2VudGVyJyxcbn1cblxuZXhwb3J0IHR5cGUgQXV0b2NvbXBsZXRlQWN0aW9uID0ge1xuICBraW5kOiBBY3Rpb25LaW5kO1xuICB2aWV3OiBFZGl0b3JWaWV3O1xuICB0cmlnZ2VyOiBzdHJpbmc7XG4gIGZpbHRlcj86IHN0cmluZztcbiAgcmFuZ2U6IEZyb21UbztcbiAgdHlwZTogVHJpZ2dlciB8IG51bGw7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5BdXRvY29tcGxldGUge1xuICBhY3Rpb246ICdhZGQnO1xuICB0cmlnZ2VyOiBzdHJpbmc7XG4gIGZpbHRlcj86IHN0cmluZztcbiAgdHlwZTogVHJpZ2dlciB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvc2VBdXRvY29tcGxldGUge1xuICBhY3Rpb246ICdyZW1vdmUnO1xufVxuXG5leHBvcnQgdHlwZSBBdXRvY29tcGxldGVUck1ldGEgPSBPcGVuQXV0b2NvbXBsZXRlIHwgQ2xvc2VBdXRvY29tcGxldGU7XG5cbmV4cG9ydCB0eXBlIFRyaWdnZXIgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHJpZ2dlcjogc3RyaW5nIHwgUmVnRXhwO1xuICBjYW5jZWxPbkZpcnN0U3BhY2U/OiBib29sZWFuOyAvLyBEZWZhdWx0IGlzIHRydWVcbiAgYWxsQXJyb3dLZXlzPzogYm9vbGVhbjsgLy8gRGVmYXVsdCBpcyBmYWxzZVxuICBkZWNvcmF0aW9uQXR0cnM/OiBEZWNvcmF0aW9uQXR0cnM7XG59O1xuXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBvbk9wZW4/OiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW47XG4gIG9uQ2xvc2U/OiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW47XG4gIG9uRmlsdGVyPzogKGFjdGlvbjogQXV0b2NvbXBsZXRlQWN0aW9uKSA9PiBib29sZWFuO1xuICBvbkFycm93PzogKGFjdGlvbjogQXV0b2NvbXBsZXRlQWN0aW9uKSA9PiBib29sZWFuO1xuICBvbkVudGVyPzogKGFjdGlvbjogQXV0b2NvbXBsZXRlQWN0aW9uKSA9PiBib29sZWFuO1xuICByZWR1Y2VyOiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW4gfCB0eXBlb2YgS0VFUF9PUEVOO1xuICB0cmlnZ2VyczogVHJpZ2dlcltdO1xufTtcbiIsImltcG9ydCB7IFBsdWdpbktleSwgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG5leHBvcnQgY29uc3QgcGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgnYXV0b2NvbXBsZXRlJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpblN1Z2dlc3Rpb24oc2VsZWN0aW9uOiBTZWxlY3Rpb24sIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0KSB7XG4gIHJldHVybiBkZWNvcmF0aW9ucy5maW5kKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pLmxlbmd0aCA+IDA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNyZWx0KCkge1xuICB2YXIgZWx0ID0gYXJndW1lbnRzWzBdO1xuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdCk7XG4gIHZhciBpID0gMSwgbmV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgaWYgKG5leHQgJiYgdHlwZW9mIG5leHQgPT0gXCJvYmplY3RcIiAmJiBuZXh0Lm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5leHQpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dCwgbmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5leHRbbmFtZV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkgZWx0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIGVsdFxufVxuXG5mdW5jdGlvbiBhZGQoZWx0LCBjaGlsZCkge1xuICBpZiAodHlwZW9mIGNoaWxkID09IFwic3RyaW5nXCIpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgfSBlbHNlIGlmIChjaGlsZCA9PSBudWxsKSA7IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKykgYWRkKGVsdCwgY2hpbGRbaV0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5zdXBwb3J0ZWQgY2hpbGQgbm9kZTogXCIgKyBjaGlsZClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWx0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyA6Oi0gUGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYW4gb3JkZXJlZCBtYXBwaW5nIGZyb21cbi8vIHN0cmluZ3MgdG8gdmFsdWVzLCB3aXRoIHNvbWUgY29udmVuaWVudCB1cGRhdGUgbWV0aG9kcy5cbmZ1bmN0aW9uIE9yZGVyZWRNYXAoY29udGVudCkge1xuICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xufVxuXG5PcmRlcmVkTWFwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE9yZGVyZWRNYXAsXG5cbiAgZmluZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBpZiAodGhpcy5jb250ZW50W2ldID09PSBrZXkpIHJldHVybiBpXG4gICAgcmV0dXJuIC0xXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykg4oaSID9hbnlcbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlIHN0b3JlZCB1bmRlciBga2V5YCwgb3IgcmV0dXJuIHVuZGVmaW5lZCB3aGVuXG4gIC8vIG5vIHN1Y2gga2V5IGV4aXN0cy5cbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICByZXR1cm4gZm91bmQgPT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLmNvbnRlbnRbZm91bmQgKyAxXVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSwgP3N0cmluZykg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSByZXBsYWNpbmcgdGhlIHZhbHVlIG9mIGBrZXlgIHdpdGggYSBuZXdcbiAgLy8gdmFsdWUsIG9yIGFkZGluZyBhIGJpbmRpbmcgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLiBJZiBgbmV3S2V5YCBpc1xuICAvLyBnaXZlbiwgdGhlIGtleSBvZiB0aGUgYmluZGluZyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhhdCBrZXkuXG4gIHVwZGF0ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgbmV3S2V5KSB7XG4gICAgdmFyIHNlbGYgPSBuZXdLZXkgJiYgbmV3S2V5ICE9IGtleSA/IHRoaXMucmVtb3ZlKG5ld0tleSkgOiB0aGlzO1xuICAgIHZhciBmb3VuZCA9IHNlbGYuZmluZChrZXkpLCBjb250ZW50ID0gc2VsZi5jb250ZW50LnNsaWNlKCk7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICBjb250ZW50LnB1c2gobmV3S2V5IHx8IGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50W2ZvdW5kICsgMV0gPSB2YWx1ZTtcbiAgICAgIGlmIChuZXdLZXkpIGNvbnRlbnRbZm91bmRdID0gbmV3S2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSDihpIgT3JkZXJlZE1hcFxuICAvLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4ga2V5IHJlbW92ZWQsIGlmIGl0IGV4aXN0ZWQuXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgaWYgKGZvdW5kID09IC0xKSByZXR1cm4gdGhpc1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQsIDIpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgc3RhcnQgb2YgdGhlIG1hcC5cbiAgYWRkVG9TdGFydDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChba2V5LCB2YWx1ZV0uY29uY2F0KHRoaXMucmVtb3ZlKGtleSkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBlbmQgb2YgdGhlIG1hcC5cbiAgYWRkVG9FbmQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMucmVtb3ZlKGtleSkuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQucHVzaChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBzdHJpbmcsIGFueSkg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEga2V5IGFmdGVyIHRoZSBnaXZlbiBrZXkuIElmIGBwbGFjZWAgaXMgbm90IGZvdW5kLCB0aGUgbmV3XG4gIC8vIGtleSBpcyBhZGRlZCB0byB0aGUgZW5kLlxuICBhZGRCZWZvcmU6IGZ1bmN0aW9uKHBsYWNlLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHdpdGhvdXQgPSB0aGlzLnJlbW92ZShrZXkpLCBjb250ZW50ID0gd2l0aG91dC5jb250ZW50LnNsaWNlKCk7XG4gICAgdmFyIGZvdW5kID0gd2l0aG91dC5maW5kKHBsYWNlKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCA9PSAtMSA/IGNvbnRlbnQubGVuZ3RoIDogZm91bmQsIDAsIGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpKVxuICAvLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgbWFwLCBpblxuICAvLyBvcmRlci5cbiAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgZih0aGlzLmNvbnRlbnRbaV0sIHRoaXMuY29udGVudFtpICsgMV0pO1xuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHByZXBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYmVmb3JlIHRoZSBrZXlzIGluIGBtYXBgLlxuICBwcmVwZW5kOiBmdW5jdGlvbihtYXApIHtcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBpZiAoIW1hcC5zaXplKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChtYXAuY29udGVudC5jb25jYXQodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IGFwcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBhZnRlciB0aGUga2V5cyBpbiBgbWFwYC5cbiAgYXBwZW5kOiBmdW5jdGlvbihtYXApIHtcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBpZiAoIW1hcC5zaXplKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudC5jb25jYXQobWFwLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAuXG4gIHN1YnRyYWN0OiBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlbW92ZShtYXAuY29udGVudFtpXSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgYW1vdW50IG9mIGtleXMgaW4gdGhpcyBtYXAuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID4+IDFcbiAgfVxufTtcblxuLy8gOjogKD91bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSDihpIgT3JkZXJlZE1hcFxuLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuIElmIG51bGwsIGNyZWF0ZSBhbiBlbXB0eVxuLy8gbWFwLiBJZiBnaXZlbiBhbiBvcmRlcmVkIG1hcCwgcmV0dXJuIHRoYXQgbWFwIGl0c2VsZi4gSWYgZ2l2ZW4gYW5cbi8vIG9iamVjdCwgY3JlYXRlIGEgbWFwIGZyb20gdGhlIG9iamVjdCdzIHByb3BlcnRpZXMuXG5PcmRlcmVkTWFwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcmRlcmVkTWFwKSByZXR1cm4gdmFsdWVcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgaWYgKHZhbHVlKSBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSBjb250ZW50LnB1c2gocHJvcCwgdmFsdWVbcHJvcF0pO1xuICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3JkZXJlZE1hcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gZGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGpvaW5CYWNrd2FyZCA9IGZ1bmN0aW9uIGpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcblxuICBpZiAoISRjdXQpIHtcbiAgICB2YXIgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSxcbiAgICAgICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZTtcbiAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHJldHVybiB0cnVlO1xuXG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgdmFyIGRlbFN0ZXAgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5yZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSk7XG5cbiAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgPyBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpIDogcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50cltcImRlbGV0ZVwiXSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSkge1xuICB2YXIgb25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgZm9yICh2YXIgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSBzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSB7XG4gICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spIHJldHVybiB0cnVlO1xuICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBzZWxlY3ROb2RlQmFja3dhcmQgPSBmdW5jdGlvbiBzZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciBfc3RhdGUkc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uLiRoZWFkLFxuICAgICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uLmVtcHR5LFxuICAgICAgJGN1dCA9ICRoZWFkO1xuICBpZiAoIWVtcHR5KSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICB9XG5cbiAgdmFyIG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgaWYgKCFub2RlIHx8ICFwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKSByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBqb2luRm9yd2FyZCA9IGZ1bmN0aW9uIGpvaW5Gb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgJGN1cnNvciA9IHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yO1xuICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICBpZiAoISRjdXQpIHJldHVybiBmYWxzZTtcbiAgdmFyIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHJldHVybiB0cnVlO1xuXG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgdmFyIGRlbFN0ZXAgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5yZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSk7XG5cbiAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSkgOiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyW1wiZGVsZXRlXCJdKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBzZWxlY3ROb2RlRm9yd2FyZCA9IGZ1bmN0aW9uIHNlbGVjdE5vZGVGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjIgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkaGVhZCA9IF9zdGF0ZSRzZWxlY3Rpb24yLiRoZWFkLFxuICAgICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uMi5lbXB0eSxcbiAgICAgICRjdXQgPSAkaGVhZDtcbiAgaWYgKCFlbXB0eSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gIH1cblxuICB2YXIgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgIGlmICgkcG9zLmluZGV4KGkpICsgMSA8IHBhcmVudC5jaGlsZENvdW50KSByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW5VcCA9IGZ1bmN0aW9uIGpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24sXG4gICAgICBwb2ludDtcblxuICBpZiAobm9kZVNlbCkge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvaW50ID0gc2VsLmZyb207XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5qb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICBpZiAobm9kZVNlbCkgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBqb2luRG93biA9IGZ1bmN0aW9uIGpvaW5Eb3duKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgcG9pbnQ7XG5cbiAgaWYgKHNlbCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbikge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpIHJldHVybiBmYWxzZTtcbiAgICBwb2ludCA9IHNlbC50bztcbiAgfSBlbHNlIHtcbiAgICBwb2ludCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGxpZnQgPSBmdW5jdGlvbiBsaWZ0KHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjMgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb24zLiRmcm9tLFxuICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjMuJHRvO1xuICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksXG4gICAgICB0YXJnZXQgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5saWZ0VGFyZ2V0KHJhbmdlKTtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgbmV3bGluZUluQ29kZSA9IGZ1bmN0aW9uIG5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBfc3RhdGUkc2VsZWN0aW9uNCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjQuJGhlYWQsXG4gICAgICAkYW5jaG9yID0gX3N0YXRlJHNlbGVjdGlvbjQuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICB2YXIgX21hdGNoJGVkZ2UgPSBtYXRjaC5lZGdlKGkpLFxuICAgICAgICB0eXBlID0gX21hdGNoJGVkZ2UudHlwZTtcblxuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgcmV0dXJuIHR5cGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGV4aXRDb2RlID0gZnVuY3Rpb24gZXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBfc3RhdGUkc2VsZWN0aW9uNSA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjUuJGhlYWQsXG4gICAgICAkYW5jaG9yID0gX3N0YXRlJHNlbGVjdGlvbjUuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHJldHVybiBmYWxzZTtcbiAgdmFyIGFib3ZlID0gJGhlYWQubm9kZSgtMSksXG4gICAgICBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLFxuICAgICAgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBwb3MgPSAkaGVhZC5hZnRlcigpLFxuICAgICAgICB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY3JlYXRlUGFyYWdyYXBoTmVhciA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IHNlbC4kZnJvbSxcbiAgICAgICR0byA9IHNlbC4kdG87XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgdmFyIHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBsaWZ0RW1wdHlCbG9jayA9IGZ1bmN0aW9uIGxpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgJGN1cnNvciA9IHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yO1xuICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICB2YXIgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcblxuICAgIGlmIChwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLFxuICAgICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNwbGl0QmxvY2sgPSBmdW5jdGlvbiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjYgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb242LiRmcm9tLFxuICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjYuJHRvO1xuXG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICB2YXIgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuQWxsU2VsZWN0aW9uKSB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB2YXIgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgdmFyIHR5cGVzID0gYXRFbmQgJiYgZGVmbHQgPyBbe1xuICAgICAgdHlwZTogZGVmbHRcbiAgICB9XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2FuID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG5cbiAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7XG4gICAgICB0eXBlOiBkZWZsdFxuICAgIH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgaWYgKGRlZmx0KSB0eXBlcyA9IFt7XG4gICAgICAgIHR5cGU6IGRlZmx0XG4gICAgICB9XTtcbiAgICAgIGNhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNhbikge1xuICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuXG4gICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLFxuICAgICAgICAgICAgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IGZ1bmN0aW9uIHNwbGl0QmxvY2tLZWVwTWFya3Moc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiBmdW5jdGlvbiAodHIpIHtcbiAgICB2YXIgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICBpZiAobWFya3MpIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICBkaXNwYXRjaCh0cik7XG4gIH0pO1xufTtcblxudmFyIHNlbGVjdFBhcmVudE5vZGUgPSBmdW5jdGlvbiBzZWxlY3RQYXJlbnROb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjcgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb243LiRmcm9tLFxuICAgICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uNy50byxcbiAgICAgIHBvcztcbiAgdmFyIHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gIGlmIChzYW1lID09IDApIHJldHVybiBmYWxzZTtcbiAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzZWxlY3RBbGwgPSBmdW5jdGlvbiBzZWxlY3RBbGwoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gIHZhciBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsXG4gICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLFxuICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IHByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5qb2luKCRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gIHZhciBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsXG4gICAgICBhZnRlciA9ICRjdXQubm9kZUFmdGVyLFxuICAgICAgY29ubixcbiAgICAgIG1hdGNoO1xuICBpZiAoYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIGZhbHNlO1xuICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSkgcmV0dXJuIHRydWU7XG4gIHZhciBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcblxuICBpZiAoY2FuRGVsQWZ0ZXIgJiYgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSxcbiAgICAgICAgICB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgd3JhcCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShjb25uW2ldLmNyZWF0ZShudWxsLCB3cmFwKSk7XG4gICAgICB9XG5cbiAgICAgIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgdmFyIGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgIGlmIChwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHRyLmRvYywgam9pbkF0KSkgdHIuam9pbihqb2luQXQpO1xuICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc2VsQWZ0ZXIgPSBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgdmFyIHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLFxuICAgICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG5cbiAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldCA+PSAkY3V0LmRlcHRoKSB7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICB2YXIgYXQgPSBiZWZvcmUsXG4gICAgICAgIF93cmFwID0gW107XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBfd3JhcC5wdXNoKGF0KTtcblxuICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKSBicmVhaztcbiAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBhZnRlclRleHQgPSBhZnRlcixcbiAgICAgICAgYWZ0ZXJEZXB0aCA9IDE7XG5cbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGFmdGVyRGVwdGgrKztcbiAgICB9XG5cbiAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgX2VuZCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSBfd3JhcC5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgICAgX2VuZCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShfd3JhcFtfaV0uY29weShfZW5kKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RyID0gc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSBfd3JhcC5sZW5ndGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsICRjdXQucG9zICsgYWZ0ZXJEZXB0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSAtIGFmdGVyRGVwdGgsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKF9lbmQsIF93cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcblxuICAgICAgICBkaXNwYXRjaChfdHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0VGV4dGJsb2NrU2lkZShzaWRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICB2YXIgZGVwdGggPSAkcG9zLmRlcHRoO1xuXG4gICAgd2hpbGUgKCRwb3Mubm9kZShkZXB0aCkuaXNJbmxpbmUpIHtcbiAgICAgIGlmICghZGVwdGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGRlcHRoLS07XG4gICAgfVxuXG4gICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHNpZGUgPCAwID8gJHBvcy5zdGFydChkZXB0aCkgOiAkcG9zLmVuZChkZXB0aCkpKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xudmFyIHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG5cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSkge1xuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb244ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb244LiRmcm9tLFxuICAgICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uOC4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLFxuICAgICAgICB3cmFwcGluZyA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICBpZiAoIXdyYXBwaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSkge1xuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb245ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICBmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjkuZnJvbSxcbiAgICAgICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uOS50bztcbiAgICB2YXIgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgIGlmIChhcHBsaWNhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSkgcmV0dXJuO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLFxuICAgICAgICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhcHBsaWNhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlKSB7XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgX3JhbmdlcyRpID0gcmFuZ2VzW2ldLFxuICAgICAgICAkZnJvbSA9IF9yYW5nZXMkaS4kZnJvbSxcbiAgICAgICAgJHRvID0gX3JhbmdlcyRpLiR0bztcbiAgICB2YXIgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoY2FuKSByZXR1cm4gZmFsc2U7XG4gICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgIH0pO1xuICAgIGlmIChjYW4pIHJldHVybiB7XG4gICAgICB2OiB0cnVlXG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XG5cbiAgICBpZiAoX3R5cGVvZihfcmV0KSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSkge1xuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24xMCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uMTAuZW1wdHksXG4gICAgICAgICRjdXJzb3IgPSBfc3RhdGUkc2VsZWN0aW9uMTAuJGN1cnNvcixcbiAgICAgICAgcmFuZ2VzID0gX3N0YXRlJHNlbGVjdGlvbjEwLnJhbmdlcztcbiAgICBpZiAoZW1wdHkgJiYgISRjdXJzb3IgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSkgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO2Vsc2UgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGFzID0gZmFsc2UsXG4gICAgICAgICAgICB0ciA9IHN0YXRlLnRyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAhaGFzICYmIGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX3JhbmdlcyRpMiA9IHJhbmdlc1tpXSxcbiAgICAgICAgICAgICAgJGZyb20gPSBfcmFuZ2VzJGkyLiRmcm9tLFxuICAgICAgICAgICAgICAkdG8gPSBfcmFuZ2VzJGkyLiR0bztcbiAgICAgICAgICBoYXMgPSBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcmFuZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX3JhbmdlcyRfaSA9IHJhbmdlc1tfaTJdLFxuICAgICAgICAgICAgICBfJGZyb20gPSBfcmFuZ2VzJF9pLiRmcm9tLFxuICAgICAgICAgICAgICBfJHRvID0gX3JhbmdlcyRfaS4kdG87XG5cbiAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICB0ci5yZW1vdmVNYXJrKF8kZnJvbS5wb3MsIF8kdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gXyRmcm9tLnBvcyxcbiAgICAgICAgICAgICAgICB0byA9IF8kdG8ucG9zLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gXyRmcm9tLm5vZGVBZnRlcixcbiAgICAgICAgICAgICAgICBlbmQgPSBfJHRvLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICB2YXIgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgIGZyb20gKz0gc3BhY2VTdGFydDtcbiAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodHIpIHtcbiAgICBpZiAoIXRyLmlzR2VuZXJpYykgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICB2YXIgcmFuZ2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgfVxuXG4gICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX3MsIF9lLCBmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5hYmxlID0gW107XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByYW5nZXMubGVuZ3RoOyBfaTMgKz0gMikge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbX2kzXSxcbiAgICAgICAgICB0byA9IHJhbmdlc1tfaTMgKyAxXTtcbiAgICAgIHZhciAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLFxuICAgICAgICAgIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLFxuICAgICAgICAgIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICBpZiAoIWFmdGVyKSBicmVhaztcblxuICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpIGpvaW5hYmxlLnB1c2gocG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBqb2luYWJsZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBfaTQgPSBqb2luYWJsZS5sZW5ndGggLSAxOyBfaTQgPj0gMDsgX2k0LS0pIHtcbiAgICAgIGlmIChwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHRyLmRvYywgam9pbmFibGVbX2k0XSkpIHRyLmpvaW4oam9pbmFibGVbX2k0XSk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2godHIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gIHZhciBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMTtcbiAgfSA6IGlzSm9pbmFibGU7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgcmV0dXJuIGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hhaW5Db21tYW5kcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbW1hbmRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNvbW1hbmRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG52YXIgYmFja3NwYWNlID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5CYWNrd2FyZCwgc2VsZWN0Tm9kZUJhY2t3YXJkKTtcbnZhciBkZWwgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkZvcndhcmQsIHNlbGVjdE5vZGVGb3J3YXJkKTtcbnZhciBwY0Jhc2VLZXltYXAgPSB7XG4gIFwiRW50ZXJcIjogY2hhaW5Db21tYW5kcyhuZXdsaW5lSW5Db2RlLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBsaWZ0RW1wdHlCbG9jaywgc3BsaXRCbG9jayksXG4gIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiTW9kLUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgXCJEZWxldGVcIjogZGVsLFxuICBcIk1vZC1EZWxldGVcIjogZGVsLFxuICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbnZhciBtYWNCYXNlS2V5bWFwID0ge1xuICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBcIkN0cmwtZVwiOiBzZWxlY3RUZXh0YmxvY2tFbmRcbn07XG5cbmZvciAodmFyIGtleSBpbiBwY0Jhc2VLZXltYXApIHtcbiAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xudmFyIGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuZXhwb3J0cy5hdXRvSm9pbiA9IGF1dG9Kb2luO1xuZXhwb3J0cy5iYXNlS2V5bWFwID0gYmFzZUtleW1hcDtcbmV4cG9ydHMuY2hhaW5Db21tYW5kcyA9IGNoYWluQ29tbWFuZHM7XG5leHBvcnRzLmNyZWF0ZVBhcmFncmFwaE5lYXIgPSBjcmVhdGVQYXJhZ3JhcGhOZWFyO1xuZXhwb3J0cy5kZWxldGVTZWxlY3Rpb24gPSBkZWxldGVTZWxlY3Rpb247XG5leHBvcnRzLmV4aXRDb2RlID0gZXhpdENvZGU7XG5leHBvcnRzLmpvaW5CYWNrd2FyZCA9IGpvaW5CYWNrd2FyZDtcbmV4cG9ydHMuam9pbkRvd24gPSBqb2luRG93bjtcbmV4cG9ydHMuam9pbkZvcndhcmQgPSBqb2luRm9yd2FyZDtcbmV4cG9ydHMuam9pblVwID0gam9pblVwO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMubGlmdEVtcHR5QmxvY2sgPSBsaWZ0RW1wdHlCbG9jaztcbmV4cG9ydHMubWFjQmFzZUtleW1hcCA9IG1hY0Jhc2VLZXltYXA7XG5leHBvcnRzLm5ld2xpbmVJbkNvZGUgPSBuZXdsaW5lSW5Db2RlO1xuZXhwb3J0cy5wY0Jhc2VLZXltYXAgPSBwY0Jhc2VLZXltYXA7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0Tm9kZUJhY2t3YXJkID0gc2VsZWN0Tm9kZUJhY2t3YXJkO1xuZXhwb3J0cy5zZWxlY3ROb2RlRm9yd2FyZCA9IHNlbGVjdE5vZGVGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RQYXJlbnROb2RlID0gc2VsZWN0UGFyZW50Tm9kZTtcbmV4cG9ydHMuc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrRW5kO1xuZXhwb3J0cy5zZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1N0YXJ0O1xuZXhwb3J0cy5zZXRCbG9ja1R5cGUgPSBzZXRCbG9ja1R5cGU7XG5leHBvcnRzLnNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrO1xuZXhwb3J0cy5zcGxpdEJsb2NrS2VlcE1hcmtzID0gc3BsaXRCbG9ja0tlZXBNYXJrcztcbmV4cG9ydHMudG9nZ2xlTWFyayA9IHRvZ2dsZU1hcms7XG5leHBvcnRzLndyYXBJbiA9IHdyYXBJbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgcHJvc2VtaXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCdwcm9zZW1pcnJvci10cmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICB2aWV3OiBmdW5jdGlvbiB2aWV3KGVkaXRvclZpZXcpIHtcbiAgICAgIHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIERyb3BDdXJzb3JWaWV3ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wQ3Vyc29yVmlldyk7XG5cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBlZGl0b3JWaWV3O1xuICAgIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDE7XG4gICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgXCJibGFja1wiO1xuICAgIHRoaXNbXCJjbGFzc1wiXSA9IG9wdGlvbnNbXCJjbGFzc1wiXTtcbiAgICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgIF90aGlzW25hbWVdKGUpO1xuICAgICAgfTtcblxuICAgICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJvcEN1cnNvclZpZXcsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyO1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVkaXRvclZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShlZGl0b3JWaWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvclBvcyAhPSBudWxsICYmIHByZXZTdGF0ZS5kb2MgIT0gZWRpdG9yVmlldy5zdGF0ZS5kb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKSB0aGlzLnNldEN1cnNvcihudWxsKTtlbHNlIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3Vyc29yKHBvcykge1xuICAgICAgaWYgKHBvcyA9PSB0aGlzLmN1cnNvclBvcykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3M7XG5cbiAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT3ZlcmxheSgpIHtcbiAgICAgIHZhciAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKSxcbiAgICAgICAgICByZWN0O1xuXG4gICAgICBpZiAoISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSxcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG5cbiAgICAgICAgaWYgKGJlZm9yZSB8fCBhZnRlcikge1xuICAgICAgICAgIHZhciBub2RlUmVjdCA9IHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zIC0gKGJlZm9yZSA/IGJlZm9yZS5ub2RlU2l6ZSA6IDApKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgdG9wID0gYmVmb3JlID8gbm9kZVJlY3QuYm90dG9tIDogbm9kZVJlY3QudG9wO1xuICAgICAgICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIpIHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7XG4gICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG5vZGVSZWN0LmxlZnQsXG4gICAgICAgICAgICByaWdodDogbm9kZVJlY3QucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHRvcCAtIHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgICAgYm90dG9tOiB0b3AgKyB0aGlzLndpZHRoIC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmVkaXRvclZpZXcuY29vcmRzQXRQb3ModGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgcmlnaHQ6IGNvb3Jkcy5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgdG9wOiBjb29yZHMudG9wLFxuICAgICAgICAgIGJvdHRvbTogY29vcmRzLmJvdHRvbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5lZGl0b3JWaWV3LmRvbS5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgaWYgKHRoaXNbXCJjbGFzc1wiXSkgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXNbXCJjbGFzc1wiXTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lOyBiYWNrZ3JvdW5kLWNvbG9yOiBcIiArIHRoaXMuY29sb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG5cbiAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PSBkb2N1bWVudC5ib2R5ICYmIGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PSBcInN0YXRpY1wiKSB7XG4gICAgICAgIHBhcmVudExlZnQgPSAtcGFnZVhPZmZzZXQ7XG4gICAgICAgIHBhcmVudFRvcCA9IC1wYWdlWU9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBwYXJlbnRMZWZ0ID0gX3JlY3QubGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICBwYXJlbnRUb3AgPSBfcmVjdC50b3AgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IHJlY3QubGVmdCAtIHBhcmVudExlZnQgKyBcInB4XCI7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gcmVjdC50b3AgLSBwYXJlbnRUb3AgKyBcInB4XCI7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgKyBcInB4XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVtb3ZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlbW92YWwodGltZW91dCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuc2V0Q3Vyc29yKG51bGwpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7XG4gICAgICAgIGxlZnQ6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHRvcDogZXZlbnQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyAmJiBwb3MuaW5zaWRlID49IDAgJiYgdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICB2YXIgZGlzYWJsZURyb3BDdXJzb3IgPSBub2RlICYmIG5vZGUudHlwZS5zcGVjLmRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgdmFyIGRpc2FibGVkID0gdHlwZW9mIGRpc2FibGVEcm9wQ3Vyc29yID09IFwiZnVuY3Rpb25cIiA/IGRpc2FibGVEcm9wQ3Vyc29yKHRoaXMuZWRpdG9yVmlldywgcG9zKSA6IGRpc2FibGVEcm9wQ3Vyc29yO1xuXG4gICAgICBpZiAocG9zICYmICFkaXNhYmxlZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcG9zLnBvcztcblxuICAgICAgICBpZiAodGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nICYmIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSkge1xuICAgICAgICAgIHRhcmdldCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmRyb3BQb2ludCh0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLCB0YXJnZXQsIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSk7XG4gICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCg1MDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnZW5kKCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdsZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy5lZGl0b3JWaWV3LmRvbSB8fCAhdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyb3BDdXJzb3JWaWV3O1xufSgpO1xuXG5leHBvcnRzLmRyb3BDdXJzb3IgPSBkcm9wQ3Vyc29yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yS2V5bWFwID0gcmVxdWlyZSgncHJvc2VtaXJyb3Ita2V5bWFwJyk7XG5cbnZhciBwcm9zZW1pcnJvckhpc3RvcnkgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1oaXN0b3J5Jyk7XG5cbnZhciBwcm9zZW1pcnJvckNvbW1hbmRzID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItY29tbWFuZHMnKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgcHJvc2VtaXJyb3JEcm9wY3Vyc29yID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItZHJvcGN1cnNvcicpO1xuXG52YXIgcHJvc2VtaXJyb3JHYXBjdXJzb3IgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1nYXBjdXJzb3InKTtcblxudmFyIHByb3NlbWlycm9yTWVudSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1lbnUnKTtcblxudmFyIHByb3NlbWlycm9yU2NoZW1hTGlzdCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXNjaGVtYS1saXN0Jyk7XG5cbnZhciBwcm9zZW1pcnJvcklucHV0cnVsZXMgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1pbnB1dHJ1bGVzJyk7XG5cbnZhciBwcmVmaXggPSBcIlByb3NlTWlycm9yLXByb21wdFwiO1xuXG5mdW5jdGlvbiBvcGVuUHJvbXB0KG9wdGlvbnMpIHtcbiAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICB3cmFwcGVyLmNsYXNzTmFtZSA9IHByZWZpeDtcblxuICB2YXIgbW91c2VPdXRzaWRlID0gZnVuY3Rpb24gbW91c2VPdXRzaWRlKGUpIHtcbiAgICBpZiAoIXdyYXBwZXIuY29udGFpbnMoZS50YXJnZXQpKSBjbG9zZSgpO1xuICB9O1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZU91dHNpZGUpO1xuICB9LCA1MCk7XG5cbiAgdmFyIGNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTtcbiAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB3cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gIH07XG5cbiAgdmFyIGRvbUZpZWxkcyA9IFtdO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucy5maWVsZHMpIHtcbiAgICBkb21GaWVsZHMucHVzaChvcHRpb25zLmZpZWxkc1tuYW1lXS5yZW5kZXIoKSk7XG4gIH1cblxuICB2YXIgc3VibWl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgc3VibWl0QnV0dG9uLnR5cGUgPSBcInN1Ym1pdFwiO1xuICBzdWJtaXRCdXR0b24uY2xhc3NOYW1lID0gcHJlZml4ICsgXCItc3VibWl0XCI7XG4gIHN1Ym1pdEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiT0tcIjtcbiAgdmFyIGNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIGNhbmNlbEJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcbiAgY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSBcIkNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsb3NlKTtcbiAgdmFyIGZvcm0gPSB3cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpKTtcbiAgaWYgKG9wdGlvbnMudGl0bGUpIGZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImg1XCIpKS50ZXh0Q29udGVudCA9IG9wdGlvbnMudGl0bGU7XG4gIGRvbUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYXBwZW5kQ2hpbGQoZmllbGQpO1xuICB9KTtcbiAgdmFyIGJ1dHRvbnMgPSBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICBidXR0b25zLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWJ1dHRvbnNcIjtcbiAgYnV0dG9ucy5hcHBlbmRDaGlsZChzdWJtaXRCdXR0b24pO1xuICBidXR0b25zLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcbiAgdmFyIGJveCA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHdyYXBwZXIuc3R5bGUudG9wID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGJveC5oZWlnaHQpIC8gMiArIFwicHhcIjtcbiAgd3JhcHBlci5zdHlsZS5sZWZ0ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gYm94LndpZHRoKSAvIDIgKyBcInB4XCI7XG5cbiAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uIHN1Ym1pdCgpIHtcbiAgICB2YXIgcGFyYW1zID0gZ2V0VmFsdWVzKG9wdGlvbnMuZmllbGRzLCBkb21GaWVsZHMpO1xuXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgY2xvc2UoKTtcbiAgICAgIG9wdGlvbnMuY2FsbGJhY2socGFyYW1zKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN1Ym1pdCgpO1xuICB9KTtcbiAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgIShlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdWJtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSA5KSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghd3JhcHBlci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgY2xvc2UoKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgaWYgKGlucHV0KSBpbnB1dC5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZmllbGRzLCBkb21GaWVsZHMpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBpID0gMDtcblxuICBmb3IgKHZhciBuYW1lIGluIGZpZWxkcykge1xuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tuYW1lXSxcbiAgICAgICAgZG9tID0gZG9tRmllbGRzW2krK107XG4gICAgdmFyIHZhbHVlID0gZmllbGQucmVhZChkb20pLFxuICAgICAgICBiYWQgPSBmaWVsZC52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoYmFkKSB7XG4gICAgICByZXBvcnRJbnZhbGlkKGRvbSwgYmFkKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlc3VsdFtuYW1lXSA9IGZpZWxkLmNsZWFuKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcG9ydEludmFsaWQoZG9tLCBtZXNzYWdlKSB7XG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgdmFyIG1zZyA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgbXNnLnN0eWxlLmxlZnQgPSBkb20ub2Zmc2V0TGVmdCArIGRvbS5vZmZzZXRXaWR0aCArIDIgKyBcInB4XCI7XG4gIG1zZy5zdHlsZS50b3AgPSBkb20ub2Zmc2V0VG9wIC0gNSArIFwicHhcIjtcbiAgbXNnLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItaW52YWxpZFwiO1xuICBtc2cudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyZW50LnJlbW92ZUNoaWxkKG1zZyk7XG4gIH0sIDE1MDApO1xufVxuXG52YXIgRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpZWxkKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmllbGQpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWVsZCwgW3tcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkKGRvbSkge1xuICAgICAgcmV0dXJuIGRvbS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlICYmIHRoaXMub3B0aW9ucy5yZXF1aXJlZCkgcmV0dXJuIFwiUmVxdWlyZWQgZmllbGRcIjtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSkgfHwgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSA/IHRoaXMub3B0aW9ucy52YWxpZGF0ZSh2YWx1ZSkgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW4gPyB0aGlzLm9wdGlvbnMuY2xlYW4odmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpZWxkO1xufSgpO1xuXG52YXIgVGV4dEZpZWxkID0gZnVuY3Rpb24gKF9GaWVsZCkge1xuICBfaW5oZXJpdHMoVGV4dEZpZWxkLCBfRmllbGQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dEZpZWxkKTtcblxuICBmdW5jdGlvbiBUZXh0RmllbGQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRGaWVsZCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dEZpZWxkLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMubGFiZWw7XG4gICAgICBpbnB1dC52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSB8fCBcIlwiO1xuICAgICAgaW5wdXQuYXV0b2NvbXBsZXRlID0gXCJvZmZcIjtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEZpZWxkO1xufShGaWVsZCk7XG5cbmZ1bmN0aW9uIGNhbkluc2VydChzdGF0ZSwgbm9kZVR5cGUpIHtcbiAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuXG4gIGZvciAodmFyIGQgPSAkZnJvbS5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkZnJvbS5pbmRleChkKTtcbiAgICBpZiAoJGZyb20ubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGluc2VydEltYWdlSXRlbShub2RlVHlwZSkge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yTWVudS5NZW51SXRlbSh7XG4gICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgbGFiZWw6IFwiSW1hZ2VcIixcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIGNhbkluc2VydChzdGF0ZSwgbm9kZVR5cGUpO1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiBydW4oc3RhdGUsIF8sIHZpZXcpIHtcbiAgICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgIGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uLmZyb20sXG4gICAgICAgICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uLnRvLFxuICAgICAgICAgIGF0dHJzID0gbnVsbDtcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUudHlwZSA9PSBub2RlVHlwZSkgYXR0cnMgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5hdHRycztcbiAgICAgIG9wZW5Qcm9tcHQoe1xuICAgICAgICB0aXRsZTogXCJJbnNlcnQgaW1hZ2VcIixcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgc3JjOiBuZXcgVGV4dEZpZWxkKHtcbiAgICAgICAgICAgIGxhYmVsOiBcIkxvY2F0aW9uXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBhdHRycyAmJiBhdHRycy5zcmNcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJUaXRsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGF0dHJzICYmIGF0dHJzLnRpdGxlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYWx0OiBuZXcgVGV4dEZpZWxkKHtcbiAgICAgICAgICAgIGxhYmVsOiBcIkRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogYXR0cnMgPyBhdHRycy5hbHQgOiBzdGF0ZS5kb2MudGV4dEJldHdlZW4oZnJvbSwgdG8sIFwiIFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhhdHRycykge1xuICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlVHlwZS5jcmVhdGVBbmRGaWxsKGF0dHJzKSkpO1xuICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY21kSXRlbShjbWQsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgbGFiZWw6IG9wdGlvbnMudGl0bGUsXG4gICAgcnVuOiBjbWRcbiAgfTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBwYXNzZWRPcHRpb25zW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5lbmFibGUgJiYgIW9wdGlvbnMuc2VsZWN0KSBwYXNzZWRPcHRpb25zW29wdGlvbnMuZW5hYmxlID8gXCJlbmFibGVcIiA6IFwic2VsZWN0XCJdID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIGNtZChzdGF0ZSk7XG4gIH07XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JNZW51Lk1lbnVJdGVtKHBhc3NlZE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBtYXJrQWN0aXZlKHN0YXRlLCB0eXBlKSB7XG4gIHZhciBfc3RhdGUkc2VsZWN0aW9uMiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgIGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMi5mcm9tLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMi4kZnJvbSxcbiAgICAgIHRvID0gX3N0YXRlJHNlbGVjdGlvbjIudG8sXG4gICAgICBlbXB0eSA9IF9zdGF0ZSRzZWxlY3Rpb24yLmVtcHR5O1xuICBpZiAoZW1wdHkpIHJldHVybiAhIXR5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkZnJvbS5tYXJrcygpKTtlbHNlIHJldHVybiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gbWFya0l0ZW0obWFya1R5cGUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoc3RhdGUpIHtcbiAgICAgIHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIGNtZEl0ZW0ocHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKG1hcmtUeXBlKSwgcGFzc2VkT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGxpbmtJdGVtKG1hcmtUeXBlKSB7XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JNZW51Lk1lbnVJdGVtKHtcbiAgICB0aXRsZTogXCJBZGQgb3IgcmVtb3ZlIGxpbmtcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMubGluayxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIG1hcmtBY3RpdmUoc3RhdGUsIG1hcmtUeXBlKTtcbiAgICB9LFxuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gIXN0YXRlLnNlbGVjdGlvbi5lbXB0eTtcbiAgICB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgaWYgKG1hcmtBY3RpdmUoc3RhdGUsIG1hcmtUeXBlKSkge1xuICAgICAgICBwcm9zZW1pcnJvckNvbW1hbmRzLnRvZ2dsZU1hcmsobWFya1R5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBvcGVuUHJvbXB0KHtcbiAgICAgICAgdGl0bGU6IFwiQ3JlYXRlIGEgbGlua1wiLFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICBocmVmOiBuZXcgVGV4dEZpZWxkKHtcbiAgICAgICAgICAgIGxhYmVsOiBcIkxpbmsgdGFyZ2V0XCIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRpdGxlOiBuZXcgVGV4dEZpZWxkKHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlRpdGxlXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soYXR0cnMpIHtcbiAgICAgICAgICBwcm9zZW1pcnJvckNvbW1hbmRzLnRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzKSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBMaXN0SXRlbShub2RlVHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gY21kSXRlbShwcm9zZW1pcnJvclNjaGVtYUxpc3Qud3JhcEluTGlzdChub2RlVHlwZSwgb3B0aW9ucy5hdHRycyksIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBidWlsZE1lbnVJdGVtcyhzY2hlbWEpIHtcbiAgdmFyIHIgPSB7fTtcbiAgdmFyIG1hcms7XG4gIGlmIChtYXJrID0gc2NoZW1hLm1hcmtzLnN0cm9uZykgci50b2dnbGVTdHJvbmcgPSBtYXJrSXRlbShtYXJrLCB7XG4gICAgdGl0bGU6IFwiVG9nZ2xlIHN0cm9uZyBzdHlsZVwiLFxuICAgIGljb246IHByb3NlbWlycm9yTWVudS5pY29ucy5zdHJvbmdcbiAgfSk7XG4gIGlmIChtYXJrID0gc2NoZW1hLm1hcmtzLmVtKSByLnRvZ2dsZUVtID0gbWFya0l0ZW0obWFyaywge1xuICAgIHRpdGxlOiBcIlRvZ2dsZSBlbXBoYXNpc1wiLFxuICAgIGljb246IHByb3NlbWlycm9yTWVudS5pY29ucy5lbVxuICB9KTtcbiAgaWYgKG1hcmsgPSBzY2hlbWEubWFya3MuY29kZSkgci50b2dnbGVDb2RlID0gbWFya0l0ZW0obWFyaywge1xuICAgIHRpdGxlOiBcIlRvZ2dsZSBjb2RlIGZvbnRcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMuY29kZVxuICB9KTtcbiAgaWYgKG1hcmsgPSBzY2hlbWEubWFya3MubGluaykgci50b2dnbGVMaW5rID0gbGlua0l0ZW0obWFyayk7XG4gIHZhciBub2RlO1xuICBpZiAobm9kZSA9IHNjaGVtYS5ub2Rlcy5pbWFnZSkgci5pbnNlcnRJbWFnZSA9IGluc2VydEltYWdlSXRlbShub2RlKTtcbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMuYnVsbGV0X2xpc3QpIHIud3JhcEJ1bGxldExpc3QgPSB3cmFwTGlzdEl0ZW0obm9kZSwge1xuICAgIHRpdGxlOiBcIldyYXAgaW4gYnVsbGV0IGxpc3RcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMuYnVsbGV0TGlzdFxuICB9KTtcbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMub3JkZXJlZF9saXN0KSByLndyYXBPcmRlcmVkTGlzdCA9IHdyYXBMaXN0SXRlbShub2RlLCB7XG4gICAgdGl0bGU6IFwiV3JhcCBpbiBvcmRlcmVkIGxpc3RcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMub3JkZXJlZExpc3RcbiAgfSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLmJsb2NrcXVvdGUpIHIud3JhcEJsb2NrUXVvdGUgPSBwcm9zZW1pcnJvck1lbnUud3JhcEl0ZW0obm9kZSwge1xuICAgIHRpdGxlOiBcIldyYXAgaW4gYmxvY2sgcXVvdGVcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMuYmxvY2txdW90ZVxuICB9KTtcbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoKSByLm1ha2VQYXJhZ3JhcGggPSBwcm9zZW1pcnJvck1lbnUuYmxvY2tUeXBlSXRlbShub2RlLCB7XG4gICAgdGl0bGU6IFwiQ2hhbmdlIHRvIHBhcmFncmFwaFwiLFxuICAgIGxhYmVsOiBcIlBsYWluXCJcbiAgfSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLmNvZGVfYmxvY2spIHIubWFrZUNvZGVCbG9jayA9IHByb3NlbWlycm9yTWVudS5ibG9ja1R5cGVJdGVtKG5vZGUsIHtcbiAgICB0aXRsZTogXCJDaGFuZ2UgdG8gY29kZSBibG9ja1wiLFxuICAgIGxhYmVsOiBcIkNvZGVcIlxuICB9KTtcbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMuaGVhZGluZykgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTA7IGkrKykge1xuICAgIHJbXCJtYWtlSGVhZFwiICsgaV0gPSBwcm9zZW1pcnJvck1lbnUuYmxvY2tUeXBlSXRlbShub2RlLCB7XG4gICAgICB0aXRsZTogXCJDaGFuZ2UgdG8gaGVhZGluZyBcIiArIGksXG4gICAgICBsYWJlbDogXCJMZXZlbCBcIiArIGksXG4gICAgICBhdHRyczoge1xuICAgICAgICBsZXZlbDogaVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMuaG9yaXpvbnRhbF9ydWxlKSB7XG4gICAgdmFyIGhyID0gbm9kZTtcbiAgICByLmluc2VydEhvcml6b250YWxSdWxlID0gbmV3IHByb3NlbWlycm9yTWVudS5NZW51SXRlbSh7XG4gICAgICB0aXRsZTogXCJJbnNlcnQgaG9yaXpvbnRhbCBydWxlXCIsXG4gICAgICBsYWJlbDogXCJIb3Jpem9udGFsIHJ1bGVcIixcbiAgICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjYW5JbnNlcnQoc3RhdGUsIGhyKTtcbiAgICAgIH0sXG4gICAgICBydW46IGZ1bmN0aW9uIHJ1bihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoaHIuY3JlYXRlKCkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjdXQgPSBmdW5jdGlvbiBjdXQoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0pO1xuICB9O1xuXG4gIHIuaW5zZXJ0TWVudSA9IG5ldyBwcm9zZW1pcnJvck1lbnUuRHJvcGRvd24oY3V0KFtyLmluc2VydEltYWdlLCByLmluc2VydEhvcml6b250YWxSdWxlXSksIHtcbiAgICBsYWJlbDogXCJJbnNlcnRcIlxuICB9KTtcbiAgci50eXBlTWVudSA9IG5ldyBwcm9zZW1pcnJvck1lbnUuRHJvcGRvd24oY3V0KFtyLm1ha2VQYXJhZ3JhcGgsIHIubWFrZUNvZGVCbG9jaywgci5tYWtlSGVhZDEgJiYgbmV3IHByb3NlbWlycm9yTWVudS5Ecm9wZG93blN1Ym1lbnUoY3V0KFtyLm1ha2VIZWFkMSwgci5tYWtlSGVhZDIsIHIubWFrZUhlYWQzLCByLm1ha2VIZWFkNCwgci5tYWtlSGVhZDUsIHIubWFrZUhlYWQ2XSksIHtcbiAgICBsYWJlbDogXCJIZWFkaW5nXCJcbiAgfSldKSwge1xuICAgIGxhYmVsOiBcIlR5cGUuLi5cIlxuICB9KTtcbiAgci5pbmxpbmVNZW51ID0gW2N1dChbci50b2dnbGVTdHJvbmcsIHIudG9nZ2xlRW0sIHIudG9nZ2xlQ29kZSwgci50b2dnbGVMaW5rXSldO1xuICByLmJsb2NrTWVudSA9IFtjdXQoW3Iud3JhcEJ1bGxldExpc3QsIHIud3JhcE9yZGVyZWRMaXN0LCByLndyYXBCbG9ja1F1b3RlLCBwcm9zZW1pcnJvck1lbnUuam9pblVwSXRlbSwgcHJvc2VtaXJyb3JNZW51LmxpZnRJdGVtLCBwcm9zZW1pcnJvck1lbnUuc2VsZWN0UGFyZW50Tm9kZUl0ZW1dKV07XG4gIHIuZnVsbE1lbnUgPSByLmlubGluZU1lbnUuY29uY2F0KFtbci5pbnNlcnRNZW51LCByLnR5cGVNZW51XV0sIFtbcHJvc2VtaXJyb3JNZW51LnVuZG9JdGVtLCBwcm9zZW1pcnJvck1lbnUucmVkb0l0ZW1dXSwgci5ibG9ja01lbnUpO1xuICByZXR1cm4gcjtcbn1cblxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBidWlsZEtleW1hcChzY2hlbWEsIG1hcEtleXMpIHtcbiAgdmFyIGtleXMgPSB7fSxcbiAgICAgIHR5cGU7XG5cbiAgZnVuY3Rpb24gYmluZChrZXksIGNtZCkge1xuICAgIGlmIChtYXBLZXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gbWFwS2V5c1trZXldO1xuICAgICAgaWYgKG1hcHBlZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgIGlmIChtYXBwZWQpIGtleSA9IG1hcHBlZDtcbiAgICB9XG5cbiAgICBrZXlzW2tleV0gPSBjbWQ7XG4gIH1cblxuICBiaW5kKFwiTW9kLXpcIiwgcHJvc2VtaXJyb3JIaXN0b3J5LnVuZG8pO1xuICBiaW5kKFwiU2hpZnQtTW9kLXpcIiwgcHJvc2VtaXJyb3JIaXN0b3J5LnJlZG8pO1xuICBiaW5kKFwiQmFja3NwYWNlXCIsIHByb3NlbWlycm9ySW5wdXRydWxlcy51bmRvSW5wdXRSdWxlKTtcbiAgaWYgKCFtYWMpIGJpbmQoXCJNb2QteVwiLCBwcm9zZW1pcnJvckhpc3RvcnkucmVkbyk7XG4gIGJpbmQoXCJBbHQtQXJyb3dVcFwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLmpvaW5VcCk7XG4gIGJpbmQoXCJBbHQtQXJyb3dEb3duXCIsIHByb3NlbWlycm9yQ29tbWFuZHMuam9pbkRvd24pO1xuICBiaW5kKFwiTW9kLUJyYWNrZXRMZWZ0XCIsIHByb3NlbWlycm9yQ29tbWFuZHMubGlmdCk7XG4gIGJpbmQoXCJFc2NhcGVcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy5zZWxlY3RQYXJlbnROb2RlKTtcblxuICBpZiAodHlwZSA9IHNjaGVtYS5tYXJrcy5zdHJvbmcpIHtcbiAgICBiaW5kKFwiTW9kLWJcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLUJcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKHR5cGUpKTtcbiAgfVxuXG4gIGlmICh0eXBlID0gc2NoZW1hLm1hcmtzLmVtKSB7XG4gICAgYmluZChcIk1vZC1pXCIsIHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayh0eXBlKSk7XG4gICAgYmluZChcIk1vZC1JXCIsIHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayh0eXBlKSk7XG4gIH1cblxuICBpZiAodHlwZSA9IHNjaGVtYS5tYXJrcy5jb2RlKSBiaW5kKFwiTW9kLWBcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYnVsbGV0X2xpc3QpIGJpbmQoXCJTaGlmdC1DdHJsLThcIiwgcHJvc2VtaXJyb3JTY2hlbWFMaXN0LndyYXBJbkxpc3QodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5vcmRlcmVkX2xpc3QpIGJpbmQoXCJTaGlmdC1DdHJsLTlcIiwgcHJvc2VtaXJyb3JTY2hlbWFMaXN0LndyYXBJbkxpc3QodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ibG9ja3F1b3RlKSBiaW5kKFwiQ3RybC0+XCIsIHByb3NlbWlycm9yQ29tbWFuZHMud3JhcEluKHR5cGUpKTtcblxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5oYXJkX2JyZWFrKSB7XG4gICAgdmFyIGJyID0gdHlwZSxcbiAgICAgICAgY21kID0gcHJvc2VtaXJyb3JDb21tYW5kcy5jaGFpbkNvbW1hbmRzKHByb3NlbWlycm9yQ29tbWFuZHMuZXhpdENvZGUsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoYnIuY3JlYXRlKCkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgYmluZChcIk1vZC1FbnRlclwiLCBjbWQpO1xuICAgIGJpbmQoXCJTaGlmdC1FbnRlclwiLCBjbWQpO1xuICAgIGlmIChtYWMpIGJpbmQoXCJDdHJsLUVudGVyXCIsIGNtZCk7XG4gIH1cblxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5saXN0X2l0ZW0pIHtcbiAgICBiaW5kKFwiRW50ZXJcIiwgcHJvc2VtaXJyb3JTY2hlbWFMaXN0LnNwbGl0TGlzdEl0ZW0odHlwZSkpO1xuICAgIGJpbmQoXCJNb2QtW1wiLCBwcm9zZW1pcnJvclNjaGVtYUxpc3QubGlmdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLV1cIiwgcHJvc2VtaXJyb3JTY2hlbWFMaXN0LnNpbmtMaXN0SXRlbSh0eXBlKSk7XG4gIH1cblxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGgpIGJpbmQoXCJTaGlmdC1DdHJsLTBcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy5zZXRCbG9ja1R5cGUodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5jb2RlX2Jsb2NrKSBiaW5kKFwiU2hpZnQtQ3RybC1cXFxcXCIsIHByb3NlbWlycm9yQ29tbWFuZHMuc2V0QmxvY2tUeXBlKHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaGVhZGluZykgZm9yICh2YXIgaSA9IDE7IGkgPD0gNjsgaSsrKSB7XG4gICAgYmluZChcIlNoaWZ0LUN0cmwtXCIgKyBpLCBwcm9zZW1pcnJvckNvbW1hbmRzLnNldEJsb2NrVHlwZSh0eXBlLCB7XG4gICAgICBsZXZlbDogaVxuICAgIH0pKTtcbiAgfVxuXG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhvcml6b250YWxfcnVsZSkge1xuICAgIHZhciBociA9IHR5cGU7XG4gICAgYmluZChcIk1vZC1fXCIsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoaHIuY3JlYXRlKCkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYmxvY2tRdW90ZVJ1bGUobm9kZVR5cGUpIHtcbiAgcmV0dXJuIHByb3NlbWlycm9ySW5wdXRydWxlcy53cmFwcGluZ0lucHV0UnVsZSgvXlxccyo+XFxzJC8sIG5vZGVUeXBlKTtcbn1cblxuZnVuY3Rpb24gb3JkZXJlZExpc3RSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiBwcm9zZW1pcnJvcklucHV0cnVsZXMud3JhcHBpbmdJbnB1dFJ1bGUoL14oXFxkKylcXC5cXHMkLywgbm9kZVR5cGUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcmRlcjogK21hdGNoWzFdXG4gICAgfTtcbiAgfSwgZnVuY3Rpb24gKG1hdGNoLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMub3JkZXIgPT0gK21hdGNoWzFdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVsbGV0TGlzdFJ1bGUobm9kZVR5cGUpIHtcbiAgcmV0dXJuIHByb3NlbWlycm9ySW5wdXRydWxlcy53cmFwcGluZ0lucHV0UnVsZSgvXlxccyooWy0rKl0pXFxzJC8sIG5vZGVUeXBlKTtcbn1cblxuZnVuY3Rpb24gY29kZUJsb2NrUnVsZShub2RlVHlwZSkge1xuICByZXR1cm4gcHJvc2VtaXJyb3JJbnB1dHJ1bGVzLnRleHRibG9ja1R5cGVJbnB1dFJ1bGUoL15gYGAkLywgbm9kZVR5cGUpO1xufVxuXG5mdW5jdGlvbiBoZWFkaW5nUnVsZShub2RlVHlwZSwgbWF4TGV2ZWwpIHtcbiAgcmV0dXJuIHByb3NlbWlycm9ySW5wdXRydWxlcy50ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKG5ldyBSZWdFeHAoXCJeKCN7MSxcIiArIG1heExldmVsICsgXCJ9KVxcXFxzJFwiKSwgbm9kZVR5cGUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbWF0Y2hbMV0ubGVuZ3RoXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSW5wdXRSdWxlcyhzY2hlbWEpIHtcbiAgdmFyIHJ1bGVzID0gcHJvc2VtaXJyb3JJbnB1dHJ1bGVzLnNtYXJ0UXVvdGVzLmNvbmNhdChwcm9zZW1pcnJvcklucHV0cnVsZXMuZWxsaXBzaXMsIHByb3NlbWlycm9ySW5wdXRydWxlcy5lbURhc2gpLFxuICAgICAgdHlwZTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYmxvY2txdW90ZSkgcnVsZXMucHVzaChibG9ja1F1b3RlUnVsZSh0eXBlKSk7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLm9yZGVyZWRfbGlzdCkgcnVsZXMucHVzaChvcmRlcmVkTGlzdFJ1bGUodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5idWxsZXRfbGlzdCkgcnVsZXMucHVzaChidWxsZXRMaXN0UnVsZSh0eXBlKSk7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmNvZGVfYmxvY2spIHJ1bGVzLnB1c2goY29kZUJsb2NrUnVsZSh0eXBlKSk7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpIHJ1bGVzLnB1c2goaGVhZGluZ1J1bGUodHlwZSwgNikpO1xuICByZXR1cm4gcHJvc2VtaXJyb3JJbnB1dHJ1bGVzLmlucHV0UnVsZXMoe1xuICAgIHJ1bGVzOiBydWxlc1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhhbXBsZVNldHVwKG9wdGlvbnMpIHtcbiAgdmFyIHBsdWdpbnMgPSBbYnVpbGRJbnB1dFJ1bGVzKG9wdGlvbnMuc2NoZW1hKSwgcHJvc2VtaXJyb3JLZXltYXAua2V5bWFwKGJ1aWxkS2V5bWFwKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLm1hcEtleXMpKSwgcHJvc2VtaXJyb3JLZXltYXAua2V5bWFwKHByb3NlbWlycm9yQ29tbWFuZHMuYmFzZUtleW1hcCksIHByb3NlbWlycm9yRHJvcGN1cnNvci5kcm9wQ3Vyc29yKCksIHByb3NlbWlycm9yR2FwY3Vyc29yLmdhcEN1cnNvcigpXTtcbiAgaWYgKG9wdGlvbnMubWVudUJhciAhPT0gZmFsc2UpIHBsdWdpbnMucHVzaChwcm9zZW1pcnJvck1lbnUubWVudUJhcih7XG4gICAgZmxvYXRpbmc6IG9wdGlvbnMuZmxvYXRpbmdNZW51ICE9PSBmYWxzZSxcbiAgICBjb250ZW50OiBvcHRpb25zLm1lbnVDb250ZW50IHx8IGJ1aWxkTWVudUl0ZW1zKG9wdGlvbnMuc2NoZW1hKS5mdWxsTWVudVxuICB9KSk7XG4gIGlmIChvcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKSBwbHVnaW5zLnB1c2gocHJvc2VtaXJyb3JIaXN0b3J5Lmhpc3RvcnkoKSk7XG4gIHJldHVybiBwbHVnaW5zLmNvbmNhdChuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJQcm9zZU1pcnJvci1leGFtcGxlLXNldHVwLXN0eWxlXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cblxuZXhwb3J0cy5idWlsZElucHV0UnVsZXMgPSBidWlsZElucHV0UnVsZXM7XG5leHBvcnRzLmJ1aWxkS2V5bWFwID0gYnVpbGRLZXltYXA7XG5leHBvcnRzLmJ1aWxkTWVudUl0ZW1zID0gYnVpbGRNZW51SXRlbXM7XG5leHBvcnRzLmV4YW1wbGVTZXR1cCA9IGV4YW1wbGVTZXR1cDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvcktleW1hcCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLWtleW1hcCcpO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHByb3NlbWlycm9yVmlldyA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXZpZXcnKTtcblxudmFyIEdhcEN1cnNvciA9IGZ1bmN0aW9uIChfcHJvc2VtaXJyb3JTdGF0ZSRTZWwpIHtcbiAgX2luaGVyaXRzKEdhcEN1cnNvciwgX3Byb3NlbWlycm9yU3RhdGUkU2VsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEdhcEN1cnNvcik7XG5cbiAgZnVuY3Rpb24gR2FwQ3Vyc29yKCRwb3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2FwQ3Vyc29yKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAkcG9zLCAkcG9zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHYXBDdXJzb3IsIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEdhcEN1cnNvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZ2FwY3Vyc29yXCIsXG4gICAgICAgIHBvczogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb29rbWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb29rbWFyaygpIHtcbiAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgR2FwQ3Vyc29yKGRvYy5yZXNvbHZlKGpzb24ucG9zKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkKCRwb3MpIHtcbiAgICAgIHZhciBwYXJlbnQgPSAkcG9zLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQuaXNUZXh0YmxvY2sgfHwgIWNsb3NlZEJlZm9yZSgkcG9zKSB8fCAhY2xvc2VkQWZ0ZXIoJHBvcykpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbCkgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgdmFyIGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRHYXBDdXJzb3JGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRHYXBDdXJzb3JGcm9tKCRwb3MsIGRpcikge1xuICAgICAgdmFyIG11c3RNb3ZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgc2VhcmNoOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghbXVzdE1vdmUgJiYgR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKSByZXR1cm4gJHBvcztcbiAgICAgICAgdmFyIHBvcyA9ICRwb3MucG9zLFxuICAgICAgICAgICAgbmV4dCA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuXG4gICAgICAgICAgaWYgKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgPCBwYXJlbnQuY2hpbGRDb3VudCA6ICRwb3MuaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICB2YXIgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKSByZXR1cm4gJGN1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICB2YXIgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuXG4gICAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIXByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmV4dCkpIHtcbiAgICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgICBwb3MgKz0gZGlyO1xuXG4gICAgICAgICAgdmFyIF8kY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuXG4gICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZChfJGN1cikpIHJldHVybiBfJGN1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHYXBDdXJzb3I7XG59KHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uKTtcblxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5wcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcblxudmFyIEdhcEJvb2ttYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHYXBCb29rbWFyayhwb3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2FwQm9va21hcmspO1xuXG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2FwQm9va21hcmssIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jKSB7XG4gICAgICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMucG9zKTtcbiAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2FwQm9va21hcms7XG59KCk7XG5cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBpbmRleCA9ICRwb3MuaW5kZXgoZCksXG4gICAgICAgIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcblxuICAgIGlmIChpbmRleCA9PSAwKSB7XG4gICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICBpZiAoYmVmb3JlLmNoaWxkQ291bnQgPT0gMCAmJiAhYmVmb3JlLmlubGluZUNvbnRlbnQgfHwgYmVmb3JlLmlzQXRvbSB8fCBiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksXG4gICAgICAgIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcblxuICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGFmdGVyID0gcGFyZW50LmNoaWxkKGluZGV4KTs7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCkge1xuICAgICAgaWYgKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCB8fCBhZnRlci5pc0F0b20gfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogZHJhd0dhcEN1cnNvcixcbiAgICAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW46IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW4oX3ZpZXcsICRhbmNob3IsICRoZWFkKSB7XG4gICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBoYW5kbGVLZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBoYW5kbGVLZXlEb3duID0gcHJvc2VtaXJyb3JLZXltYXAua2V5ZG93bkhhbmRsZXIoe1xuICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gIFwiQXJyb3dVcFwiOiBhcnJvdyhcInZlcnRcIiwgLTEpLFxuICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuXG5mdW5jdGlvbiBhcnJvdyhheGlzLCBkaXIpIHtcbiAgdmFyIGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyBkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIgOiBkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgJHN0YXJ0ID0gZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20sXG4gICAgICAgIG11c3RNb3ZlID0gc2VsLmVtcHR5O1xuXG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbikge1xuICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgfHwgJHN0YXJ0LmRlcHRoID09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgIH1cblxuICAgIHZhciAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICBpZiAoISRmb3VuZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJGZvdW5kKSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gIGlmICghdmlldyB8fCAhdmlldy5lZGl0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNsaWNrUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7XG4gICAgbGVmdDogZXZlbnQuY2xpZW50WCxcbiAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgfSk7XG4gIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSkgcmV0dXJuIGZhbHNlO1xuICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gIGlmIChldmVudC5pbnB1dFR5cGUgIT0gXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIiB8fCAhKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGZyb20gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgdmFyIGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gIGlmICghaW5zZXJ0KSByZXR1cm4gZmFsc2U7XG4gIHZhciBmcmFnID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcblxuICBmb3IgKHZhciBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZnJhZyA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gIH1cblxuICB2YXIgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGZyYWcsIDAsIDApKTtcbiAgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpKSk7XG4gIHZpZXcuZGlzcGF0Y2godHIpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSkgcmV0dXJuIG51bGw7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICByZXR1cm4gcHJvc2VtaXJyb3JWaWV3LkRlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW3Byb3NlbWlycm9yVmlldy5EZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwge1xuICAgIGtleTogXCJnYXBjdXJzb3JcIlxuICB9KV0pO1xufVxuXG5leHBvcnRzLkdhcEN1cnNvciA9IEdhcEN1cnNvcjtcbmV4cG9ydHMuZ2FwQ3Vyc29yID0gZ2FwQ3Vyc29yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBSb3BlU2VxdWVuY2UgPSByZXF1aXJlKCdyb3BlLXNlcXVlbmNlJyk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeShlKSB7XG4gIHJldHVybiBlICYmIF90eXBlb2YoZSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHtcbiAgICAnZGVmYXVsdCc6IGVcbiAgfTtcbn1cblxudmFyIFJvcGVTZXF1ZW5jZV9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdExlZ2FjeShSb3BlU2VxdWVuY2UpO1xuXG52YXIgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuXG52YXIgQnJhbmNoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJhbmNoKTtcblxuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJyYW5jaCwgW3tcbiAgICBrZXk6IFwicG9wRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZW5kID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOzsgZW5kLS0pIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcblxuICAgICAgICBpZiAobmV4dC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAtLWVuZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVtYXAsIG1hcEZyb207XG5cbiAgICAgIGlmIChwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgdmFyIHNlbGVjdGlvbiwgcmVtYWluaW5nO1xuICAgICAgdmFyIGFkZEFmdGVyID0gW10sXG4gICAgICAgICAgYWRkQmVmb3JlID0gW107XG4gICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKCFpdGVtLnN0ZXApIHtcbiAgICAgICAgICBpZiAoIXJlbWFwKSB7XG4gICAgICAgICAgICByZW1hcCA9IF90aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLFxuICAgICAgICAgICAgICBtYXA7XG5cbiAgICAgICAgICBpZiAoc3RlcCAmJiB0cmFuc2Zvcm0ubWF5YmVTdGVwKHN0ZXApLmRvYykge1xuICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgYWRkQWZ0ZXIucHVzaChuZXcgSXRlbShtYXAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhZGRBZnRlci5sZW5ndGggKyBhZGRCZWZvcmUubGVuZ3RoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgIGlmIChtYXApIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zZm9ybS5tYXliZVN0ZXAoaXRlbS5zdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IHJlbWFwID8gaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSA6IGl0ZW0uc2VsZWN0aW9uO1xuICAgICAgICAgIHJlbWFpbmluZyA9IG5ldyBCcmFuY2goX3RoaXMuaXRlbXMuc2xpY2UoMCwgZW5kKS5hcHBlbmQoYWRkQmVmb3JlLnJldmVyc2UoKS5jb25jYXQoYWRkQWZ0ZXIpKSwgX3RoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtYWluaW5nOiByZW1haW5pbmcsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRyYW5zZm9ybSh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IFtdLFxuICAgICAgICAgIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICB2YXIgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLFxuICAgICAgICAgIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm0uc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0ZXAgPSB0cmFuc2Zvcm0uc3RlcHNbaV0uaW52ZXJ0KHRyYW5zZm9ybS5kb2NzW2ldKTtcbiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLFxuICAgICAgICAgICAgbWVyZ2VkID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChtZXJnZWQgPSBsYXN0SXRlbSAmJiBsYXN0SXRlbS5tZXJnZShpdGVtKSkge1xuICAgICAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICAgICAgaWYgKGkpIG5ld0l0ZW1zLnBvcCgpO2Vsc2Ugb2xkSXRlbXMgPSBvbGRJdGVtcy5zbGljZSgwLCBvbGRJdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuXG4gICAgICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgICAgICBvbGRJdGVtcyA9IGN1dE9mZkV2ZW50cyhvbGRJdGVtcywgb3ZlcmZsb3cpO1xuICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEJyYW5jaChvbGRJdGVtcy5hcHBlbmQobmV3SXRlbXMpLCBldmVudENvdW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbWFwcGluZyhmcm9tLCB0bykge1xuICAgICAgdmFyIG1hcHMgPSBuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uTWFwcGluZygpO1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIHZhciBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgIHJldHVybiBtYXBzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRNYXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLmFwcGVuZChhcnJheS5tYXAoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZW0obWFwKTtcbiAgICAgIH0pKSwgdGhpcy5ldmVudENvdW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmViYXNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50Q291bnQpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHJlYmFzZWRJdGVtcyA9IFtdLFxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgdmFyIG1hcHBpbmcgPSByZWJhc2VkVHJhbnNmb3JtLm1hcHBpbmc7XG4gICAgICB2YXIgbmV3VW50aWwgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDtcbiAgICAgIHZhciBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikgZXZlbnRDb3VudC0tO1xuICAgICAgfSwgc3RhcnQpO1xuICAgICAgdmFyIGlSZWJhc2VkID0gcmViYXNlZENvdW50O1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIG5ld1VudGlsID0gTWF0aC5taW4obmV3VW50aWwsIHBvcyk7XG4gICAgICAgIHZhciBtYXAgPSBtYXBwaW5nLm1hcHNbcG9zXTtcblxuICAgICAgICBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKG1hcHBpbmcuc2xpY2UoaVJlYmFzZWQgKyAxLCBwb3MpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBldmVudENvdW50Kys7XG4gICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgfVxuICAgICAgfSwgc3RhcnQpO1xuICAgICAgdmFyIG5ld01hcHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlYmFzZWRDb3VudDsgaSA8IG5ld1VudGlsOyBpKyspIHtcbiAgICAgICAgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDAsIHN0YXJ0KS5hcHBlbmQobmV3TWFwcykuYXBwZW5kKHJlYmFzZWRJdGVtcyk7XG4gICAgICB2YXIgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICBpZiAoYnJhbmNoLmVtcHR5SXRlbUNvdW50KCkgPiBtYXhfZW1wdHlfaXRlbXMpIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1wdHlJdGVtQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHlJdGVtQ291bnQoKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5zdGVwKSBjb3VudCsrO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXByZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXByZXNzKCkge1xuICAgICAgdmFyIHVwdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdmFyIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksXG4gICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZW1zID0gW10sXG4gICAgICAgICAgZXZlbnRzID0gMDtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAoaSA+PSB1cHRvKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIGV2ZW50cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksXG4gICAgICAgICAgICAgIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgaWYgKG1hcCkgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG5cbiAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBldmVudHMrKztcbiAgICAgICAgICAgIHZhciBuZXdJdGVtID0gbmV3IEl0ZW0obWFwLmludmVydCgpLCBzdGVwLCBzZWxlY3Rpb24pLFxuICAgICAgICAgICAgICAgIG1lcmdlZCxcbiAgICAgICAgICAgICAgICBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpIGl0ZW1zW2xhc3RdID0gbWVyZ2VkO2Vsc2UgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5tYXApIHtcbiAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmFuY2g7XG59KCk7XG5cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5lbXB0eSwgMCk7XG5cbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICB2YXIgY3V0UG9pbnQ7XG4gIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBpZiAoaXRlbS5zZWxlY3Rpb24gJiYgbi0tID09IDApIHtcbiAgICAgIGN1dFBvaW50ID0gaTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuXG52YXIgSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSXRlbShtYXAsIHN0ZXAsIHNlbGVjdGlvbiwgbWlycm9yT2Zmc2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW0pO1xuXG4gICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJdGVtLCBbe1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShvdGhlcikge1xuICAgICAgaWYgKHRoaXMuc3RlcCAmJiBvdGhlci5zdGVwICYmICFvdGhlci5zZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgIGlmIChzdGVwKSByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJdGVtO1xufSgpO1xuXG52YXIgSGlzdG9yeVN0YXRlID0gX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIEhpc3RvcnlTdGF0ZShkb25lLCB1bmRvbmUsIHByZXZSYW5nZXMsIHByZXZUaW1lKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaXN0b3J5U3RhdGUpO1xuXG4gIHRoaXMuZG9uZSA9IGRvbmU7XG4gIHRoaXMudW5kb25lID0gdW5kb25lO1xuICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG59KTtcblxudmFyIERFUFRIX09WRVJGTE9XID0gMjA7XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHRyLCBvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLFxuICAgICAgcmViYXNlZDtcbiAgaWYgKGhpc3RvcnlUcikgcmV0dXJuIGhpc3RvcnlUci5oaXN0b3J5U3RhdGU7XG4gIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDApO1xuICB2YXIgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcblxuICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfSBlbHNlIGlmIChhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpKSB7XG4gICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbykgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUpO2Vsc2UgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSk7XG4gIH0gZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICB2YXIgbmV3R3JvdXAgPSBoaXN0b3J5LnByZXZUaW1lID09IDAgfHwgIWFwcGVuZGVkICYmIChoaXN0b3J5LnByZXZUaW1lIDwgKHRyLnRpbWUgfHwgMCkgLSBvcHRpb25zLm5ld0dyb3VwRGVsYXkgfHwgIWlzQWRqYWNlbnRUbyh0ciwgaGlzdG9yeS5wcmV2UmFuZ2VzKSk7XG4gICAgdmFyIHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgbmV3R3JvdXAgPyBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSA6IHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgQnJhbmNoLmVtcHR5LCBwcmV2UmFuZ2VzLCB0ci50aW1lKTtcbiAgfSBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIGhpc3RvcnkudW5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS51bmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBZGphY2VudFRvKHRyYW5zZm9ybSwgcHJldlJhbmdlcykge1xuICBpZiAoIXByZXZSYW5nZXMpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZCkgcmV0dXJuIHRydWU7XG4gIHZhciBhZGphY2VudCA9IGZhbHNlO1xuICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZSYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSkgYWRqYWNlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhZGphY2VudDtcbn1cblxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfZnJvbSwgX3RvLCBmcm9tLCB0bykge1xuICAgIHJldHVybiByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXBSYW5nZXMocmFuZ2VzLCBtYXBwaW5nKSB7XG4gIGlmICghcmFuZ2VzKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcChyYW5nZXNbaV0sIDEpLFxuICAgICAgICB0byA9IG1hcHBpbmcubWFwKHJhbmdlc1tpICsgMV0sIC0xKTtcbiAgICBpZiAoZnJvbSA8PSB0bykgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICB2YXIgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKTtcbiAgdmFyIGhpc3RPcHRpb25zID0gaGlzdG9yeUtleS5nZXQoc3RhdGUpLnNwZWMuY29uZmlnO1xuICB2YXIgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICBpZiAoIXBvcCkgcmV0dXJuO1xuICB2YXIgc2VsZWN0aW9uID0gcG9wLnNlbGVjdGlvbi5yZXNvbHZlKHBvcC50cmFuc2Zvcm0uZG9jKTtcbiAgdmFyIGFkZGVkID0gKHJlZG8gPyBoaXN0b3J5LmRvbmUgOiBoaXN0b3J5LnVuZG9uZSkuYWRkVHJhbnNmb3JtKHBvcC50cmFuc2Zvcm0sIHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcyk7XG4gIHZhciBuZXdIaXN0ID0gbmV3IEhpc3RvcnlTdGF0ZShyZWRvID8gYWRkZWQgOiBwb3AucmVtYWluaW5nLCByZWRvID8gcG9wLnJlbWFpbmluZyA6IGFkZGVkLCBudWxsLCAwKTtcbiAgZGlzcGF0Y2gocG9wLnRyYW5zZm9ybS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zZXRNZXRhKGhpc3RvcnlLZXksIHtcbiAgICByZWRvOiByZWRvLFxuICAgIGhpc3RvcnlTdGF0ZTogbmV3SGlzdFxuICB9KS5zY3JvbGxJbnRvVmlldygpKTtcbn1cblxudmFyIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZSxcbiAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG5cbmZ1bmN0aW9uIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSB7XG4gIHZhciBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcblxuICBpZiAoY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgIT0gcGx1Z2lucykge1xuICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZTtcbiAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zO1xufVxuXG5mdW5jdGlvbiBjbG9zZUhpc3RvcnkodHIpIHtcbiAgcmV0dXJuIHRyLnNldE1ldGEoY2xvc2VIaXN0b3J5S2V5LCB0cnVlKTtcbn1cblxudmFyIGhpc3RvcnlLZXkgPSBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW5LZXkoXCJoaXN0b3J5XCIpO1xudmFyIGNsb3NlSGlzdG9yeUtleSA9IG5ldyBwcm9zZW1pcnJvclN0YXRlLlBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcblxuZnVuY3Rpb24gaGlzdG9yeSgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbmZpZyA9IHtcbiAgICBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICBuZXdHcm91cERlbGF5OiBjb25maWcubmV3R3JvdXBEZWxheSB8fCA1MDBcbiAgfTtcbiAgcmV0dXJuIG5ldyBwcm9zZW1pcnJvclN0YXRlLlBsdWdpbih7XG4gICAga2V5OiBoaXN0b3J5S2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShCcmFuY2guZW1wdHksIEJyYW5jaC5lbXB0eSwgbnVsbCwgMCk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYXBwbHlUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgdHIsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maWc6IGNvbmZpZyxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWlucHV0OiBmdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgdmFyIGlucHV0VHlwZSA9IGUuaW5wdXRUeXBlO1xuICAgICAgICAgIHZhciBjb21tYW5kID0gaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgaWYgKCFjb21tYW5kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHVuZG8gPSBmdW5jdGlvbiB1bmRvKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIWhpc3QgfHwgaGlzdC5kb25lLmV2ZW50Q291bnQgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgcmVkbyA9IGZ1bmN0aW9uIHJlZG8oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIGlmICghaGlzdCB8fCBoaXN0LnVuZG9uZS5ldmVudENvdW50ID09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgdmFyIGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgcmV0dXJuIGhpc3QgPyBoaXN0LmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG5cbmZ1bmN0aW9uIHJlZG9EZXB0aChzdGF0ZSkge1xuICB2YXIgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnRzLmNsb3NlSGlzdG9yeSA9IGNsb3NlSGlzdG9yeTtcbmV4cG9ydHMuaGlzdG9yeSA9IGhpc3Rvcnk7XG5leHBvcnRzLnJlZG8gPSByZWRvO1xuZXhwb3J0cy5yZWRvRGVwdGggPSByZWRvRGVwdGg7XG5leHBvcnRzLnVuZG8gPSB1bmRvO1xuZXhwb3J0cy51bmRvRGVwdGggPSB1bmRvRGVwdGg7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbnZhciBJbnB1dFJ1bGUgPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gSW5wdXRSdWxlKG1hdGNoLCBoYW5kbGVyKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dFJ1bGUpO1xuXG4gIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICB0aGlzLmhhbmRsZXIgPSB0eXBlb2YgaGFuZGxlciA9PSBcInN0cmluZ1wiID8gc3RyaW5nSGFuZGxlcihoYW5kbGVyKSA6IGhhbmRsZXI7XG59KTtcblxuZnVuY3Rpb24gc3RyaW5nSGFuZGxlcihzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaW5zZXJ0ID0gc3RyaW5nO1xuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICB2YXIgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG5cbiAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgfTtcbn1cblxudmFyIE1BWF9NQVRDSCA9IDUwMDtcblxuZnVuY3Rpb24gaW5wdXRSdWxlcyhfcmVmKSB7XG4gIHZhciBydWxlcyA9IF9yZWYucnVsZXM7XG4gIHZhciBwbHVnaW4gPSBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlZCA9IHRyLmdldE1ldGEodGhpcyk7XG4gICAgICAgIGlmIChzdG9yZWQpIHJldHVybiBzdG9yZWQ7XG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dDogZnVuY3Rpb24gaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBydW4odmlldywgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBjb21wb3NpdGlvbmVuZDogZnVuY3Rpb24gY29tcG9zaXRpb25lbmQodmlldykge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yO1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHJ1bih2aWV3LCAkY3Vyc29yLnBvcywgJGN1cnNvci5wb3MsIFwiXCIsIHJ1bGVzLCBwbHVnaW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG5cbmZ1bmN0aW9uIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbikge1xuICBpZiAodmlldy5jb21wb3NpbmcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHN0YXRlID0gdmlldy5zdGF0ZSxcbiAgICAgICRmcm9tID0gc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gIGlmICgkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIHRleHRCZWZvcmUgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oTWF0aC5tYXgoMCwgJGZyb20ucGFyZW50T2Zmc2V0IC0gTUFYX01BVENIKSwgJGZyb20ucGFyZW50T2Zmc2V0LCBudWxsLCBcIlxcdUZGRkNcIikgKyB0ZXh0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBydWxlc1tpXS5tYXRjaC5leGVjKHRleHRCZWZvcmUpO1xuICAgIHZhciB0ciA9IG1hdGNoICYmIHJ1bGVzW2ldLmhhbmRsZXIoc3RhdGUsIG1hdGNoLCBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSwgdG8pO1xuICAgIGlmICghdHIpIGNvbnRpbnVlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgdGV4dDogdGV4dFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHVuZG9JbnB1dFJ1bGUgPSBmdW5jdGlvbiB1bmRvSW5wdXRSdWxlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV0sXG4gICAgICAgIHVuZG9hYmxlID0gdm9pZCAwO1xuXG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLFxuICAgICAgICAgICAgdG9VbmRvID0gdW5kb2FibGUudHJhbnNmb3JtO1xuXG4gICAgICAgIGZvciAodmFyIGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKTtcbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cltcImRlbGV0ZVwiXSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50byk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBlbURhc2ggPSBuZXcgSW5wdXRSdWxlKC8tLSQvLCBcIuKAlFwiKTtcbnZhciBlbGxpcHNpcyA9IG5ldyBJbnB1dFJ1bGUoL1xcLlxcLlxcLiQvLCBcIuKAplwiKTtcbnZhciBvcGVuRG91YmxlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKFwiKSQvLCBcIuKAnFwiKTtcbnZhciBjbG9zZURvdWJsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvXCIkLywgXCLigJ1cIik7XG52YXIgb3BlblNpbmdsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvKD86XnxbXFxzXFx7XFxbXFwoXFw8J1wiXFx1MjAxOFxcdTIwMUNdKSgnKSQvLCBcIuKAmFwiKTtcbnZhciBjbG9zZVNpbmdsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvJyQvLCBcIuKAmVwiKTtcbnZhciBzbWFydFF1b3RlcyA9IFtvcGVuRG91YmxlUXVvdGUsIGNsb3NlRG91YmxlUXVvdGUsIG9wZW5TaW5nbGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZV07XG5cbmZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUpIHtcbiAgdmFyIGdldEF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB2YXIgam9pblByZWRpY2F0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IElucHV0UnVsZShyZWdleHAsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZ2V0QXR0cnMobWF0Y2gpIDogZ2V0QXR0cnM7XG4gICAgdmFyIHRyID0gc3RhdGUudHJbXCJkZWxldGVcIl0oc3RhcnQsIGVuZCk7XG4gICAgdmFyICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0KSxcbiAgICAgICAgcmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpLFxuICAgICAgICB3cmFwcGluZyA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICBpZiAoIXdyYXBwaW5nKSByZXR1cm4gbnVsbDtcbiAgICB0ci53cmFwKHJhbmdlLCB3cmFwcGluZyk7XG4gICAgdmFyIGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0IC0gMSkubm9kZUJlZm9yZTtcbiAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS50eXBlID09IG5vZGVUeXBlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4odHIuZG9jLCBzdGFydCAtIDEpICYmICgham9pblByZWRpY2F0ZSB8fCBqb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKSkgdHIuam9pbihzdGFydCAtIDEpO1xuICAgIHJldHVybiB0cjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUocmVnZXhwLCBub2RlVHlwZSkge1xuICB2YXIgZ2V0QXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgZnVuY3Rpb24gKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShzdGFydCk7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGdldEF0dHJzKG1hdGNoKSA6IGdldEF0dHJzO1xuICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgbm9kZVR5cGUpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc3RhdGUudHJbXCJkZWxldGVcIl0oc3RhcnQsIGVuZCkuc2V0QmxvY2tUeXBlKHN0YXJ0LCBzdGFydCwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuSW5wdXRSdWxlID0gSW5wdXRSdWxlO1xuZXhwb3J0cy5jbG9zZURvdWJsZVF1b3RlID0gY2xvc2VEb3VibGVRdW90ZTtcbmV4cG9ydHMuY2xvc2VTaW5nbGVRdW90ZSA9IGNsb3NlU2luZ2xlUXVvdGU7XG5leHBvcnRzLmVsbGlwc2lzID0gZWxsaXBzaXM7XG5leHBvcnRzLmVtRGFzaCA9IGVtRGFzaDtcbmV4cG9ydHMuaW5wdXRSdWxlcyA9IGlucHV0UnVsZXM7XG5leHBvcnRzLm9wZW5Eb3VibGVRdW90ZSA9IG9wZW5Eb3VibGVRdW90ZTtcbmV4cG9ydHMub3BlblNpbmdsZVF1b3RlID0gb3BlblNpbmdsZVF1b3RlO1xuZXhwb3J0cy5zbWFydFF1b3RlcyA9IHNtYXJ0UXVvdGVzO1xuZXhwb3J0cy50ZXh0YmxvY2tUeXBlSW5wdXRSdWxlID0gdGV4dGJsb2NrVHlwZUlucHV0UnVsZTtcbmV4cG9ydHMudW5kb0lucHV0UnVsZSA9IHVuZG9JbnB1dFJ1bGU7XG5leHBvcnRzLndyYXBwaW5nSW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgdzNjS2V5bmFtZSA9IHJlcXVpcmUoJ3czYy1rZXluYW1lJyk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyksXG4gICAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpIHJlc3VsdCA9IFwiIFwiO1xuICB2YXIgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSBtZXRhID0gdHJ1ZTtlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIGFsdCA9IHRydWU7ZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgY3RybCA9IHRydWU7ZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHNoaWZ0ID0gdHJ1ZTtlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChtYWMpIG1ldGEgPSB0cnVlO2Vsc2UgY3RybCA9IHRydWU7XG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gIH1cblxuICBpZiAoYWx0KSByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgaWYgKGN0cmwpIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgaWYgKG1ldGEpIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgaWYgKHNoaWZ0KSByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xuICAgIGNvcHlbbm9ybWFsaXplS2V5TmFtZShwcm9wKV0gPSBtYXBbcHJvcF07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICBpZiAoZXZlbnQuYWx0S2V5KSBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICBpZiAoZXZlbnQuY3RybEtleSkgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gIGlmIChldmVudC5tZXRhS2V5KSBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSkgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncylcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykge1xuICB2YXIgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICAgIHZhciBuYW1lID0gdzNjS2V5bmFtZS5rZXlOYW1lKGV2ZW50KSxcbiAgICAgICAgaXNDaGFyID0gbmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiLFxuICAgICAgICBiYXNlTmFtZTtcbiAgICB2YXIgZGlyZWN0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildO1xuICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChpc0NoYXIgJiYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IG5hbWUuY2hhckNvZGVBdCgwKSA+IDEyNykgJiYgKGJhc2VOYW1lID0gdzNjS2V5bmFtZS5iYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICB2YXIgZnJvbUNvZGUgPSBtYXBbbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldO1xuICAgICAgaWYgKGZyb21Db2RlICYmIGZyb21Db2RlKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgdmFyIHdpdGhTaGlmdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXTtcbiAgICAgIGlmICh3aXRoU2hpZnQgJiYgd2l0aFNoaWZ0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbmV4cG9ydHMua2V5ZG93bkhhbmRsZXIgPSBrZXlkb3duSGFuZGxlcjtcbmV4cG9ydHMua2V5bWFwID0ga2V5bWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBjcmVsID0gcmVxdWlyZSgnY3JlbHQnKTtcblxudmFyIHByb3NlbWlycm9yQ29tbWFuZHMgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1jb21tYW5kcycpO1xuXG52YXIgcHJvc2VtaXJyb3JIaXN0b3J5ID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItaGlzdG9yeScpO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeShlKSB7XG4gIHJldHVybiBlICYmIF90eXBlb2YoZSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHtcbiAgICAnZGVmYXVsdCc6IGVcbiAgfTtcbn1cblxudmFyIGNyZWxfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHRMZWdhY3koY3JlbCk7XG5cbnZhciBTVkcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG52YXIgWExJTksgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbnZhciBwcmVmaXgkMiA9IFwiUHJvc2VNaXJyb3ItaWNvblwiO1xuXG5mdW5jdGlvbiBoYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgcGF0aC5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBnZXRJY29uKGljb24pIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBub2RlLmNsYXNzTmFtZSA9IHByZWZpeCQyO1xuXG4gIGlmIChpY29uLnBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGljb24ucGF0aCxcbiAgICAgICAgd2lkdGggPSBpY29uLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBpY29uLmhlaWdodDtcbiAgICB2YXIgbmFtZSA9IFwicG0taWNvbi1cIiArIGhhc2hQYXRoKHBhdGgpLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5hbWUpKSBidWlsZFNWRyhuYW1lLCBpY29uKTtcbiAgICB2YXIgc3ZnID0gbm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInN2Z1wiKSk7XG4gICAgc3ZnLnN0eWxlLndpZHRoID0gd2lkdGggLyBoZWlnaHQgKyBcImVtXCI7XG4gICAgdmFyIHVzZSA9IHN2Zy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInVzZVwiKSk7XG4gICAgdXNlLnNldEF0dHJpYnV0ZU5TKFhMSU5LLCBcImhyZWZcIiwgLyhbXiNdKikvLmV4ZWMoZG9jdW1lbnQubG9jYXRpb24udG9TdHJpbmcoKSlbMV0gKyBcIiNcIiArIG5hbWUpO1xuICB9IGVsc2UgaWYgKGljb24uZG9tKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChpY29uLmRvbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ZXh0ID0gaWNvbi50ZXh0LFxuICAgICAgICBjc3MgPSBpY29uLmNzcztcbiAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKS50ZXh0Q29udGVudCA9IHRleHQgfHwgJyc7XG4gICAgaWYgKGNzcykgbm9kZS5maXJzdENoaWxkLnN0eWxlLmNzc1RleHQgPSBjc3M7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTVkcobmFtZSwgZGF0YSkge1xuICB2YXIgY29sbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCQyICsgXCItY29sbGVjdGlvblwiKTtcblxuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJzdmdcIik7XG4gICAgY29sbGVjdGlvbi5pZCA9IHByZWZpeCQyICsgXCItY29sbGVjdGlvblwiO1xuICAgIGNvbGxlY3Rpb24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGNvbGxlY3Rpb24sIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gIH1cblxuICB2YXIgc3ltID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJzeW1ib2xcIik7XG4gIHN5bS5pZCA9IG5hbWU7XG4gIHN5bS5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiICsgZGF0YS53aWR0aCArIFwiIFwiICsgZGF0YS5oZWlnaHQpO1xuICB2YXIgcGF0aCA9IHN5bS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInBhdGhcIikpO1xuICBwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgZGF0YS5wYXRoKTtcbiAgY29sbGVjdGlvbi5hcHBlbmRDaGlsZChzeW0pO1xufVxuXG52YXIgcHJlZml4JDEgPSBcIlByb3NlTWlycm9yLW1lbnVcIjtcblxudmFyIE1lbnVJdGVtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZW51SXRlbShzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVJdGVtKTtcblxuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWVudUl0ZW0sIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIodmlldykge1xuICAgICAgdmFyIHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICB2YXIgZG9tID0gc3BlYy5yZW5kZXIgPyBzcGVjLnJlbmRlcih2aWV3KSA6IHNwZWMuaWNvbiA/IGdldEljb24oc3BlYy5pY29uKSA6IHNwZWMubGFiZWwgPyBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCBudWxsLCB0cmFuc2xhdGUodmlldywgc3BlYy5sYWJlbCkpIDogbnVsbDtcbiAgICAgIGlmICghZG9tKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1lbnVJdGVtIHdpdGhvdXQgaWNvbiBvciBsYWJlbCBwcm9wZXJ0eVwiKTtcblxuICAgICAgaWYgKHNwZWMudGl0bGUpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdHlwZW9mIHNwZWMudGl0bGUgPT09IFwiZnVuY3Rpb25cIiA/IHNwZWMudGl0bGUodmlldy5zdGF0ZSkgOiBzcGVjLnRpdGxlO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdHJhbnNsYXRlKHZpZXcsIHRpdGxlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVjW1wiY2xhc3NcIl0pIGRvbS5jbGFzc0xpc3QuYWRkKHNwZWNbXCJjbGFzc1wiXSk7XG4gICAgICBpZiAoc3BlYy5jc3MpIGRvbS5zdHlsZS5jc3NUZXh0ICs9IHNwZWMuY3NzO1xuICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIWRvbS5jbGFzc0xpc3QuY29udGFpbnMocHJlZml4JDEgKyBcIi1kaXNhYmxlZFwiKSkgc3BlYy5ydW4odmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldywgZSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzcGVjLnNlbGVjdCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNwZWMuc2VsZWN0KHN0YXRlKTtcbiAgICAgICAgICBkb20uc3R5bGUuZGlzcGxheSA9IHNlbGVjdGVkID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc3BlYy5lbmFibGUpIHtcbiAgICAgICAgICBlbmFibGVkID0gc3BlYy5lbmFibGUoc3RhdGUpIHx8IGZhbHNlO1xuICAgICAgICAgIHNldENsYXNzKGRvbSwgcHJlZml4JDEgKyBcIi1kaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy5hY3RpdmUpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlID0gZW5hYmxlZCAmJiBzcGVjLmFjdGl2ZShzdGF0ZSkgfHwgZmFsc2U7XG4gICAgICAgICAgc2V0Q2xhc3MoZG9tLCBwcmVmaXgkMSArIFwiLWFjdGl2ZVwiLCBhY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogZG9tLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVudUl0ZW07XG59KCk7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2aWV3LCB0ZXh0KSB7XG4gIHJldHVybiB2aWV3Ll9wcm9wcy50cmFuc2xhdGUgPyB2aWV3Ll9wcm9wcy50cmFuc2xhdGUodGV4dCkgOiB0ZXh0O1xufVxuXG52YXIgbGFzdE1lbnVFdmVudCA9IHtcbiAgdGltZTogMCxcbiAgbm9kZTogbnVsbFxufTtcblxuZnVuY3Rpb24gbWFya01lbnVFdmVudChlKSB7XG4gIGxhc3RNZW51RXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gIGxhc3RNZW51RXZlbnQubm9kZSA9IGUudGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc01lbnVFdmVudCh3cmFwcGVyKSB7XG4gIHJldHVybiBEYXRlLm5vdygpIC0gMTAwIDwgbGFzdE1lbnVFdmVudC50aW1lICYmIGxhc3RNZW51RXZlbnQubm9kZSAmJiB3cmFwcGVyLmNvbnRhaW5zKGxhc3RNZW51RXZlbnQubm9kZSk7XG59XG5cbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRHJvcGRvd24oY29udGVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5jb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIodmlldykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRlbnQgPSByZW5kZXJEcm9wZG93bkl0ZW1zKHRoaXMuY29udGVudCwgdmlldyk7XG4gICAgICB2YXIgbGFiZWwgPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1kcm9wZG93biBcIiArICh0aGlzLm9wdGlvbnNbXCJjbGFzc1wiXSB8fCBcIlwiKSxcbiAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5jc3NcbiAgICAgIH0sIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMubGFiZWwgfHwgXCJcIikpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aXRsZSkgbGFiZWwuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdHJhbnNsYXRlKHZpZXcsIHRoaXMub3B0aW9ucy50aXRsZSkpO1xuICAgICAgdmFyIHdyYXAgPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1kcm9wZG93bi13cmFwXCJcbiAgICAgIH0sIGxhYmVsKTtcbiAgICAgIHZhciBvcGVuID0gbnVsbDtcbiAgICAgIHZhciBsaXN0ZW5pbmdPbkNsb3NlID0gbnVsbDtcblxuICAgICAgdmFyIGNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGlmIChvcGVuICYmIG9wZW4uY2xvc2UoKSkge1xuICAgICAgICAgIG9wZW4gPSBudWxsO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGxpc3RlbmluZ09uQ2xvc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbWFya01lbnVFdmVudChlKTtcblxuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlbiA9IF90aGlzLmV4cGFuZCh3cmFwLCBjb250ZW50LmRvbSk7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbGlzdGVuaW5nT25DbG9zZSA9IGZ1bmN0aW9uIGxpc3RlbmluZ09uQ2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIWlzTWVudUV2ZW50KHdyYXApKSBjbG9zZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgICAgIHZhciBpbm5lciA9IGNvbnRlbnQudXBkYXRlKHN0YXRlKTtcbiAgICAgICAgd3JhcC5zdHlsZS5kaXNwbGF5ID0gaW5uZXIgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tOiB3cmFwLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGFuZChkb20sIGl0ZW1zKSB7XG4gICAgICB2YXIgbWVudURPTSA9IGNyZWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFwiZGl2XCIsIHtcbiAgICAgICAgXCJjbGFzc1wiOiBwcmVmaXgkMSArIFwiLWRyb3Bkb3duLW1lbnUgXCIgKyAodGhpcy5vcHRpb25zW1wiY2xhc3NcIl0gfHwgXCJcIilcbiAgICAgIH0sIGl0ZW1zKTtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgZG9tLnJlbW92ZUNoaWxkKG1lbnVET00pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZG9tLmFwcGVuZENoaWxkKG1lbnVET00pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICBub2RlOiBtZW51RE9NXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wZG93bjtcbn0oKTtcblxuZnVuY3Rpb24gcmVuZGVyRHJvcGRvd25JdGVtcyhpdGVtcywgdmlldykge1xuICB2YXIgcmVuZGVyZWQgPSBbXSxcbiAgICAgIHVwZGF0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9pdGVtcyRpJHJlbmRlciA9IGl0ZW1zW2ldLnJlbmRlcih2aWV3KSxcbiAgICAgICAgZG9tID0gX2l0ZW1zJGkkcmVuZGVyLmRvbSxcbiAgICAgICAgdXBkYXRlID0gX2l0ZW1zJGkkcmVuZGVyLnVwZGF0ZTtcblxuICAgIHJlbmRlcmVkLnB1c2goY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgXCJjbGFzc1wiOiBwcmVmaXgkMSArIFwiLWRyb3Bkb3duLWl0ZW1cIlxuICAgIH0sIGRvbSkpO1xuICAgIHVwZGF0ZXMucHVzaCh1cGRhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkb206IHJlbmRlcmVkLFxuICAgIHVwZGF0ZTogY29tYmluZVVwZGF0ZXModXBkYXRlcywgcmVuZGVyZWQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVVcGRhdGVzKHVwZGF0ZXMsIG5vZGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgc29tZXRoaW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1cCA9IHVwZGF0ZXNbaV0oc3RhdGUpO1xuICAgICAgbm9kZXNbaV0uc3R5bGUuZGlzcGxheSA9IHVwID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgaWYgKHVwKSBzb21ldGhpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzb21ldGhpbmc7XG4gIH07XG59XG5cbnZhciBEcm9wZG93blN1Ym1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3Bkb3duU3VibWVudShjb250ZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duU3VibWVudSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duU3VibWVudSwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih2aWV3KSB7XG4gICAgICB2YXIgaXRlbXMgPSByZW5kZXJEcm9wZG93bkl0ZW1zKHRoaXMuY29udGVudCwgdmlldyk7XG4gICAgICB2YXIgbGFiZWwgPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1zdWJtZW51LWxhYmVsXCJcbiAgICAgIH0sIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMubGFiZWwgfHwgXCJcIikpO1xuICAgICAgdmFyIHdyYXAgPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1zdWJtZW51LXdyYXBcIlxuICAgICAgfSwgbGFiZWwsIGNyZWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFwiZGl2XCIsIHtcbiAgICAgICAgXCJjbGFzc1wiOiBwcmVmaXgkMSArIFwiLXN1Ym1lbnVcIlxuICAgICAgfSwgaXRlbXMuZG9tKSk7XG4gICAgICB2YXIgX2xpc3RlbmluZ09uQ2xvc2UgPSBudWxsO1xuICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG1hcmtNZW51RXZlbnQoZSk7XG4gICAgICAgIHNldENsYXNzKHdyYXAsIHByZWZpeCQxICsgXCItc3VibWVudS13cmFwLWFjdGl2ZVwiLCBmYWxzZSk7XG4gICAgICAgIGlmICghX2xpc3RlbmluZ09uQ2xvc2UpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9saXN0ZW5pbmdPbkNsb3NlID0gZnVuY3Rpb24gbGlzdGVuaW5nT25DbG9zZSgpIHtcbiAgICAgICAgICBpZiAoIWlzTWVudUV2ZW50KHdyYXApKSB7XG4gICAgICAgICAgICB3cmFwLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4JDEgKyBcIi1zdWJtZW51LXdyYXAtYWN0aXZlXCIpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX2xpc3RlbmluZ09uQ2xvc2UpO1xuICAgICAgICAgICAgX2xpc3RlbmluZ09uQ2xvc2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgICAgIHZhciBpbm5lciA9IGl0ZW1zLnVwZGF0ZShzdGF0ZSk7XG4gICAgICAgIHdyYXAuc3R5bGUuZGlzcGxheSA9IGlubmVyID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogd3JhcCxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyb3Bkb3duU3VibWVudTtcbn0oKTtcblxuZnVuY3Rpb24gcmVuZGVyR3JvdXBlZCh2aWV3LCBjb250ZW50KSB7XG4gIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciB1cGRhdGVzID0gW10sXG4gICAgICBzZXBhcmF0b3JzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW1zID0gY29udGVudFtpXSxcbiAgICAgICAgbG9jYWxVcGRhdGVzID0gW10sXG4gICAgICAgIGxvY2FsTm9kZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfaXRlbXMkaiRyZW5kZXIgPSBpdGVtc1tqXS5yZW5kZXIodmlldyksXG4gICAgICAgICAgZG9tID0gX2l0ZW1zJGokcmVuZGVyLmRvbSxcbiAgICAgICAgICBfdXBkYXRlID0gX2l0ZW1zJGokcmVuZGVyLnVwZGF0ZTtcblxuICAgICAgdmFyIHNwYW4gPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcInNwYW5cIiwge1xuICAgICAgICBcImNsYXNzXCI6IHByZWZpeCQxICsgXCJpdGVtXCJcbiAgICAgIH0sIGRvbSk7XG4gICAgICByZXN1bHQuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBsb2NhbE5vZGVzLnB1c2goc3Bhbik7XG4gICAgICBsb2NhbFVwZGF0ZXMucHVzaChfdXBkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAobG9jYWxVcGRhdGVzLmxlbmd0aCkge1xuICAgICAgdXBkYXRlcy5wdXNoKGNvbWJpbmVVcGRhdGVzKGxvY2FsVXBkYXRlcywgbG9jYWxOb2RlcykpO1xuICAgICAgaWYgKGkgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHNlcGFyYXRvcnMucHVzaChyZXN1bHQuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yKCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICB2YXIgc29tZXRoaW5nID0gZmFsc2UsXG4gICAgICAgIG5lZWRTZXAgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1cGRhdGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGhhc0NvbnRlbnQgPSB1cGRhdGVzW19pXShzdGF0ZSk7XG5cbiAgICAgIGlmIChfaSkgc2VwYXJhdG9yc1tfaSAtIDFdLnN0eWxlLmRpc3BsYXkgPSBuZWVkU2VwICYmIGhhc0NvbnRlbnQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICBuZWVkU2VwID0gaGFzQ29udGVudDtcbiAgICAgIGlmIChoYXNDb250ZW50KSBzb21ldGhpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzb21ldGhpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvbTogcmVzdWx0LFxuICAgIHVwZGF0ZTogdXBkYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlcGFyYXRvcigpIHtcbiAgcmV0dXJuIGNyZWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFwic3BhblwiLCB7XG4gICAgXCJjbGFzc1wiOiBwcmVmaXgkMSArIFwic2VwYXJhdG9yXCJcbiAgfSk7XG59XG5cbnZhciBpY29ucyA9IHtcbiAgam9pbjoge1xuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA5MDAsXG4gICAgcGF0aDogXCJNMCA3NWg4MDB2MTI1aC04MDB6IE0wIDgyNWg4MDB2LTEyNWgtODAweiBNMjUwIDQwMGgxMDB2LTEwMGgxMDB2MTAwaDEwMHYxMDBoLTEwMHYxMDBoLTEwMHYtMTAwaC0xMDB6XCJcbiAgfSxcbiAgbGlmdDoge1xuICAgIHdpZHRoOiAxMDI0LFxuICAgIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk0yMTkgMzEwdjMyOXEwIDctNSAxMnQtMTIgNXEtOCAwLTEzLTVsLTE2NC0xNjRxLTUtNS01LTEzdDUtMTNsMTY0LTE2NHE1LTUgMTMtNSA3IDAgMTIgNXQ1IDEyek0xMDI0IDc0OXYxMDlxMCA3LTUgMTJ0LTEyIDVoLTk4N3EtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDk4N3E3IDAgMTIgNXQ1IDEyek0xMDI0IDUzMHYxMDlxMCA3LTUgMTJ0LTEyIDVoLTYyMXEtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDYyMXE3IDAgMTIgNXQ1IDEyek0xMDI0IDMxMHYxMDlxMCA3LTUgMTJ0LTEyIDVoLTYyMXEtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDYyMXE3IDAgMTIgNXQ1IDEyek0xMDI0IDkxdjEwOXEwIDctNSAxMnQtMTIgNWgtOTg3cS03IDAtMTItNXQtNS0xMnYtMTA5cTAtNyA1LTEydDEyLTVoOTg3cTcgMCAxMiA1dDUgMTJ6XCJcbiAgfSxcbiAgc2VsZWN0UGFyZW50Tm9kZToge1xuICAgIHRleHQ6IFwiXFx1MkIxQVwiLFxuICAgIGNzczogXCJmb250LXdlaWdodDogYm9sZFwiXG4gIH0sXG4gIHVuZG86IHtcbiAgICB3aWR0aDogMTAyNCxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNzYxIDEwMjRjMTEzLTIwNiAxMzItNTIwLTMxMy01MDl2MjUzbC0zODQtMzg0IDM4NC0zODR2MjQ4YzUzNC0xMyA1OTQgNDcyIDMxMyA3NzV6XCJcbiAgfSxcbiAgcmVkbzoge1xuICAgIHdpZHRoOiAxMDI0LFxuICAgIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk01NzYgMjQ4di0yNDhsMzg0IDM4NC0zODQgMzg0di0yNTNjLTQ0Ni0xMC00MjcgMzAzLTMxMyA1MDktMjgwLTMwMy0yMjEtNzg5IDMxMy03NzV6XCJcbiAgfSxcbiAgc3Ryb25nOiB7XG4gICAgd2lkdGg6IDgwNSxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNMzE3IDg2OXE0MiAxOCA4MCAxOCAyMTQgMCAyMTQtMTkxIDAtNjUtMjMtMTAyLTE1LTI1LTM1LTQydC0zOC0yNi00Ni0xNC00OC02LTU0LTFxLTQxIDAtNTcgNSAwIDMwLTAgOTB0LTAgOTBxMCA0LTAgMzh0LTAgNTUgMiA0NyA2IDM4ek0zMDkgNDQycTI0IDQgNjIgNCA0NiAwIDgxLTd0NjItMjUgNDItNTEgMTQtODFxMC00MC0xNi03MHQtNDUtNDYtNjEtMjQtNzAtOHEtMjggMC03NCA3IDAgMjggMiA4NnQyIDg2cTAgMTUtMCA0NXQtMCA0NXEwIDI2IDAgMzl6TTAgOTUwbDEtNTNxOC0yIDQ4LTl0NjAtMTVxNC02IDctMTV0NC0xOSAzLTE4IDEtMjEgMC0xOXYtMzdxMC01NjEtMTItNTg1LTItNC0xMi04dC0yNS02LTI4LTQtMjctMi0xNy0xbC0yLTQ3cTU2LTEgMTk0LTZ0MjEzLTVxMTMgMCAzOSAwdDM4IDBxNDAgMCA3OCA3dDczIDI0IDYxIDQwIDQyIDU5IDE2IDc4cTAgMjktOSA1NHQtMjIgNDEtMzYgMzItNDEgMjUtNDggMjJxODggMjAgMTQ2IDc2dDU4IDE0MXEwIDU3LTIwIDEwMnQtNTMgNzQtNzggNDgtOTMgMjctMTAwIDhxLTI1IDAtNzUtMXQtNzUtMXEtNjAgMC0xNzUgNnQtMTMyIDZ6XCJcbiAgfSxcbiAgZW06IHtcbiAgICB3aWR0aDogNTg1LFxuICAgIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk0wIDk0OWw5LTQ4cTMtMSA0Ni0xMnQ2My0yMXExNi0yMCAyMy01NyAwLTQgMzUtMTY1dDY1LTMxMCAyOS0xNjl2LTE0cS0xMy03LTMxLTEwdC0zOS00LTMzLTNsMTAtNThxMTggMSA2OCAzdDg1IDQgNjggMXEyNyAwIDU2LTF0NjktNCA1Ni0zcS0yIDIyLTEwIDUwLTE3IDUtNTggMTZ0LTYyIDE5cS00IDEwLTggMjR0LTUgMjItNCAyNi0zIDI0cS0xNSA4NC01MCAyMzl0LTQ0IDIwM3EtMSA1LTcgMzN0LTExIDUxLTkgNDctMyAzMmwwIDEwcTkgMiAxMDUgMTctMSAyNS05IDU2LTYgMC0xOCAwdC0xOCAwcS0xNiAwLTQ5LTV0LTQ5LTVxLTc4LTEtMTE3LTEtMjkgMC04MSA1dC02OSA2elwiXG4gIH0sXG4gIGNvZGU6IHtcbiAgICB3aWR0aDogODk2LFxuICAgIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk02MDggMTkybC05NiA5NiAyMjQgMjI0LTIyNCAyMjQgOTYgOTYgMjg4LTMyMC0yODgtMzIwek0yODggMTkybC0yODggMzIwIDI4OCAzMjAgOTYtOTYtMjI0LTIyNCAyMjQtMjI0LTk2LTk2elwiXG4gIH0sXG4gIGxpbms6IHtcbiAgICB3aWR0aDogOTUxLFxuICAgIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk04MzIgNjk0cTAtMjItMTYtMzhsLTExOC0xMThxLTE2LTE2LTM4LTE2LTI0IDAtNDEgMTggMSAxIDEwIDEwdDEyIDEyIDggMTAgNyAxNCAyIDE1cTAgMjItMTYgMzh0LTM4IDE2cS04IDAtMTUtMnQtMTQtNy0xMC04LTEyLTEyLTEwLTEwcS0xOCAxNy0xOCA0MSAwIDIyIDE2IDM4bDExNyAxMThxMTUgMTUgMzggMTUgMjIgMCAzOC0xNGw4NC04M3ExNi0xNiAxNi0zOHpNNDMwIDI5MnEwLTIyLTE2LTM4bC0xMTctMTE4cS0xNi0xNi0zOC0xNi0yMiAwLTM4IDE1bC04NCA4M3EtMTYgMTYtMTYgMzggMCAyMiAxNiAzOGwxMTggMTE4cTE1IDE1IDM4IDE1IDI0IDAgNDEtMTctMS0xLTEwLTEwdC0xMi0xMi04LTEwLTctMTQtMi0xNXEwLTIyIDE2LTM4dDM4LTE2cTggMCAxNSAydDE0IDcgMTAgOCAxMiAxMiAxMCAxMHExOC0xNyAxOC00MXpNOTQxIDY5NHEwIDY4LTQ4IDExNmwtODQgODNxLTQ3IDQ3LTExNiA0Ny02OSAwLTExNi00OGwtMTE3LTExOHEtNDctNDctNDctMTE2IDAtNzAgNTAtMTE5bC01MC01MHEtNDkgNTAtMTE4IDUwLTY4IDAtMTE2LTQ4bC0xMTgtMTE4cS00OC00OC00OC0xMTZ0NDgtMTE2bDg0LTgzcTQ3LTQ3IDExNi00NyA2OSAwIDExNiA0OGwxMTcgMTE4cTQ3IDQ3IDQ3IDExNiAwIDcwLTUwIDExOWw1MCA1MHE0OS01MCAxMTgtNTAgNjggMCAxMTYgNDhsMTE4IDExOHE0OCA0OCA0OCAxMTZ6XCJcbiAgfSxcbiAgYnVsbGV0TGlzdDoge1xuICAgIHdpZHRoOiA3NjgsXG4gICAgaGVpZ2h0OiA4OTYsXG4gICAgcGF0aDogXCJNMCA1MTJoMTI4di0xMjhoLTEyOHYxMjh6TTAgMjU2aDEyOHYtMTI4aC0xMjh2MTI4ek0wIDc2OGgxMjh2LTEyOGgtMTI4djEyOHpNMjU2IDUxMmg1MTJ2LTEyOGgtNTEydjEyOHpNMjU2IDI1Nmg1MTJ2LTEyOGgtNTEydjEyOHpNMjU2IDc2OGg1MTJ2LTEyOGgtNTEydjEyOHpcIlxuICB9LFxuICBvcmRlcmVkTGlzdDoge1xuICAgIHdpZHRoOiA3NjgsXG4gICAgaGVpZ2h0OiA4OTYsXG4gICAgcGF0aDogXCJNMzIwIDUxMmg0NDh2LTEyOGgtNDQ4djEyOHpNMzIwIDc2OGg0NDh2LTEyOGgtNDQ4djEyOHpNMzIwIDEyOHYxMjhoNDQ4di0xMjhoLTQ0OHpNNzkgMzg0aDc4di0yNTZoLTM2bC04NSAyM3Y1MGw0My0ydjE4NXpNMTg5IDU5MGMwLTM2LTEyLTc4LTk2LTc4LTMzIDAtNjQgNi04MyAxNmwxIDY2YzIxLTEwIDQyLTE1IDY3LTE1czMyIDExIDMyIDI4YzAgMjYtMzAgNTgtMTEwIDExMnY1MGgxOTJ2LTY3bC05MSAyYzQ5LTMwIDg3LTY2IDg3LTExM2wxLTF6XCJcbiAgfSxcbiAgYmxvY2txdW90ZToge1xuICAgIHdpZHRoOiA2NDAsXG4gICAgaGVpZ2h0OiA4OTYsXG4gICAgcGF0aDogXCJNMCA0NDh2MjU2aDI1NnYtMjU2aC0xMjhjMCAwIDAtMTI4IDEyOC0xMjh2LTEyOGMwIDAtMjU2IDAtMjU2IDI1NnpNNjQwIDMyMHYtMTI4YzAgMC0yNTYgMC0yNTYgMjU2djI1NmgyNTZ2LTI1NmgtMTI4YzAgMCAwLTEyOCAxMjgtMTI4elwiXG4gIH1cbn07XG52YXIgam9pblVwSXRlbSA9IG5ldyBNZW51SXRlbSh7XG4gIHRpdGxlOiBcIkpvaW4gd2l0aCBhYm92ZSBibG9ja1wiLFxuICBydW46IHByb3NlbWlycm9yQ29tbWFuZHMuam9pblVwLFxuICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChzdGF0ZSkge1xuICAgIHJldHVybiBwcm9zZW1pcnJvckNvbW1hbmRzLmpvaW5VcChzdGF0ZSk7XG4gIH0sXG4gIGljb246IGljb25zLmpvaW5cbn0pO1xudmFyIGxpZnRJdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiTGlmdCBvdXQgb2YgZW5jbG9zaW5nIGJsb2NrXCIsXG4gIHJ1bjogcHJvc2VtaXJyb3JDb21tYW5kcy5saWZ0LFxuICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChzdGF0ZSkge1xuICAgIHJldHVybiBwcm9zZW1pcnJvckNvbW1hbmRzLmxpZnQoc3RhdGUpO1xuICB9LFxuICBpY29uOiBpY29ucy5saWZ0XG59KTtcbnZhciBzZWxlY3RQYXJlbnROb2RlSXRlbSA9IG5ldyBNZW51SXRlbSh7XG4gIHRpdGxlOiBcIlNlbGVjdCBwYXJlbnQgbm9kZVwiLFxuICBydW46IHByb3NlbWlycm9yQ29tbWFuZHMuc2VsZWN0UGFyZW50Tm9kZSxcbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3Qoc3RhdGUpIHtcbiAgICByZXR1cm4gcHJvc2VtaXJyb3JDb21tYW5kcy5zZWxlY3RQYXJlbnROb2RlKHN0YXRlKTtcbiAgfSxcbiAgaWNvbjogaWNvbnMuc2VsZWN0UGFyZW50Tm9kZVxufSk7XG52YXIgdW5kb0l0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJVbmRvIGxhc3QgY2hhbmdlXCIsXG4gIHJ1bjogcHJvc2VtaXJyb3JIaXN0b3J5LnVuZG8sXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHByb3NlbWlycm9ySGlzdG9yeS51bmRvKHN0YXRlKTtcbiAgfSxcbiAgaWNvbjogaWNvbnMudW5kb1xufSk7XG52YXIgcmVkb0l0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJSZWRvIGxhc3QgdW5kb25lIGNoYW5nZVwiLFxuICBydW46IHByb3NlbWlycm9ySGlzdG9yeS5yZWRvLFxuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHJldHVybiBwcm9zZW1pcnJvckhpc3RvcnkucmVkbyhzdGF0ZSk7XG4gIH0sXG4gIGljb246IGljb25zLnJlZG9cbn0pO1xuXG5mdW5jdGlvbiB3cmFwSXRlbShub2RlVHlwZSwgb3B0aW9ucykge1xuICB2YXIgcGFzc2VkT3B0aW9ucyA9IHtcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiBwcm9zZW1pcnJvckNvbW1hbmRzLndyYXBJbihub2RlVHlwZSwgb3B0aW9ucy5hdHRycykoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICB9LFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KHN0YXRlKSB7XG4gICAgICByZXR1cm4gcHJvc2VtaXJyb3JDb21tYW5kcy53cmFwSW4obm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgcGFzc2VkT3B0aW9uc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gIH1cblxuICByZXR1cm4gbmV3IE1lbnVJdGVtKHBhc3NlZE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBibG9ja1R5cGVJdGVtKG5vZGVUeXBlLCBvcHRpb25zKSB7XG4gIHZhciBjb21tYW5kID0gcHJvc2VtaXJyb3JDb21tYW5kcy5zZXRCbG9ja1R5cGUobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpO1xuICB2YXIgcGFzc2VkT3B0aW9ucyA9IHtcbiAgICBydW46IGNvbW1hbmQsXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kKHN0YXRlKTtcbiAgICB9LFxuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uLnRvLFxuICAgICAgICAgIG5vZGUgPSBfc3RhdGUkc2VsZWN0aW9uLm5vZGU7XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKTtcbiAgICAgIHJldHVybiB0byA8PSAkZnJvbS5lbmQoKSAmJiAkZnJvbS5wYXJlbnQuaGFzTWFya3VwKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgcGFzc2VkT3B0aW9uc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gIH1cblxuICByZXR1cm4gbmV3IE1lbnVJdGVtKHBhc3NlZE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzZXRDbGFzcyhkb20sIGNscywgb24pIHtcbiAgaWYgKG9uKSBkb20uY2xhc3NMaXN0LmFkZChjbHMpO2Vsc2UgZG9tLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbn1cblxudmFyIHByZWZpeCA9IFwiUHJvc2VNaXJyb3ItbWVudWJhclwiO1xuXG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICB2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gIS9FZGdlXFwvXFxkLy50ZXN0KGFnZW50KSAmJiAvQXBwbGVXZWJLaXQvLnRlc3QoYWdlbnQpICYmIC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KTtcbn1cblxuZnVuY3Rpb24gbWVudUJhcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIHZpZXc6IGZ1bmN0aW9uIHZpZXcoZWRpdG9yVmlldykge1xuICAgICAgcmV0dXJuIG5ldyBNZW51QmFyVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgTWVudUJhclZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1lbnVCYXJWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51QmFyVmlldyk7XG5cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBlZGl0b3JWaWV3O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gMDtcbiAgICB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0ID0gMDtcbiAgICB0aGlzLmZsb2F0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLndyYXBwZXIgPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICBcImNsYXNzXCI6IHByZWZpeCArIFwiLXdyYXBwZXJcIlxuICAgIH0pO1xuICAgIHRoaXMubWVudSA9IHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICBcImNsYXNzXCI6IHByZWZpeFxuICAgIH0pKTtcbiAgICB0aGlzLm1lbnUuY2xhc3NOYW1lID0gcHJlZml4O1xuICAgIGlmIChlZGl0b3JWaWV3LmRvbS5wYXJlbnROb2RlKSBlZGl0b3JWaWV3LmRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLndyYXBwZXIsIGVkaXRvclZpZXcuZG9tKTtcbiAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoZWRpdG9yVmlldy5kb20pO1xuXG4gICAgdmFyIF9yZW5kZXJHcm91cGVkID0gcmVuZGVyR3JvdXBlZCh0aGlzLmVkaXRvclZpZXcsIHRoaXMub3B0aW9ucy5jb250ZW50KSxcbiAgICAgICAgZG9tID0gX3JlbmRlckdyb3VwZWQuZG9tLFxuICAgICAgICB1cGRhdGUgPSBfcmVuZGVyR3JvdXBlZC51cGRhdGU7XG5cbiAgICB0aGlzLmNvbnRlbnRVcGRhdGUgPSB1cGRhdGU7XG4gICAgdGhpcy5tZW51LmFwcGVuZENoaWxkKGRvbSk7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmZsb2F0aW5nICYmICFpc0lPUygpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZsb2F0KCk7XG4gICAgICB2YXIgcG90ZW50aWFsU2Nyb2xsZXJzID0gZ2V0QWxsV3JhcHBpbmcodGhpcy53cmFwcGVyKTtcblxuICAgICAgdGhpcy5zY3JvbGxIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfdGhpczIuZWRpdG9yVmlldy5yb290O1xuICAgICAgICBpZiAoIShyb290LmJvZHkgfHwgcm9vdCkuY29udGFpbnMoX3RoaXMyLndyYXBwZXIpKSBwb3RlbnRpYWxTY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBfdGhpczIuc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIH0pO2Vsc2UgX3RoaXMyLnVwZGF0ZUZsb2F0KGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGUudGFyZ2V0IDogdW5kZWZpbmVkKTtcbiAgICAgIH07XG5cbiAgICAgIHBvdGVudGlhbFNjcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMyLnNjcm9sbEhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lbnVCYXJWaWV3LCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5jb250ZW50VXBkYXRlKHRoaXMuZWRpdG9yVmlldy5zdGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLmZsb2F0aW5nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQ3Vyc29yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5tZW51Lm9mZnNldFdpZHRoICE9IHRoaXMud2lkdGhGb3JNYXhIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0ID0gdGhpcy5tZW51Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1lbnUub2Zmc2V0SGVpZ2h0ID4gdGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLm1heEhlaWdodCA9IHRoaXMubWVudS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgdGhpcy5tZW51LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNjcm9sbEN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTY3JvbGxDdXJzb3IoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3JWaWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbi5mb2N1c05vZGUpIHJldHVybjtcbiAgICAgIHZhciByZWN0cyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgICB2YXIgc2VsUmVjdCA9IHJlY3RzW3NlbGVjdGlvbklzSW52ZXJ0ZWQoc2VsZWN0aW9uKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghc2VsUmVjdCkgcmV0dXJuO1xuICAgICAgdmFyIG1lbnVSZWN0ID0gdGhpcy5tZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoc2VsUmVjdC50b3AgPCBtZW51UmVjdC5ib3R0b20gJiYgc2VsUmVjdC5ib3R0b20gPiBtZW51UmVjdC50b3ApIHtcbiAgICAgICAgdmFyIHNjcm9sbGFibGUgPSBmaW5kV3JhcHBpbmdTY3JvbGxhYmxlKHRoaXMud3JhcHBlcik7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlKSBzY3JvbGxhYmxlLnNjcm9sbFRvcCAtPSBtZW51UmVjdC5ib3R0b20gLSBzZWxSZWN0LnRvcDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRmxvYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRmxvYXQoc2Nyb2xsQW5jZXN0b3IpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLndyYXBwZXIsXG4gICAgICAgICAgZWRpdG9yUmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICB0b3AgPSBzY3JvbGxBbmNlc3RvciA/IE1hdGgubWF4KDAsIHNjcm9sbEFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgOiAwO1xuXG4gICAgICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgICAgICBpZiAoZWRpdG9yUmVjdC50b3AgPj0gdG9wIHx8IGVkaXRvclJlY3QuYm90dG9tIDwgdGhpcy5tZW51Lm9mZnNldEhlaWdodCArIDEwKSB7XG4gICAgICAgICAgdGhpcy5mbG9hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gdGhpcy5tZW51LnN0eWxlLnRvcCA9IHRoaXMubWVudS5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICAgICAgdGhpcy5tZW51LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgIHRoaXMuc3BhY2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zcGFjZXIpO1xuICAgICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gKHBhcmVudC5vZmZzZXRXaWR0aCAtIHBhcmVudC5jbGllbnRXaWR0aCkgLyAyO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gZWRpdG9yUmVjdC5sZWZ0ICsgYm9yZGVyICsgXCJweFwiO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5kaXNwbGF5ID0gZWRpdG9yUmVjdC50b3AgPiB3aW5kb3cuaW5uZXJIZWlnaHQgPyBcIm5vbmVcIiA6IFwiXCI7XG4gICAgICAgICAgaWYgKHNjcm9sbEFuY2VzdG9yKSB0aGlzLm1lbnUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWRpdG9yUmVjdC50b3AgPCB0b3AgJiYgZWRpdG9yUmVjdC5ib3R0b20gPj0gdGhpcy5tZW51Lm9mZnNldEhlaWdodCArIDEwKSB7XG4gICAgICAgICAgdGhpcy5mbG9hdGluZyA9IHRydWU7XG4gICAgICAgICAgdmFyIG1lbnVSZWN0ID0gdGhpcy5tZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gbWVudVJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgICB0aGlzLm1lbnUuc3R5bGUud2lkdGggPSBtZW51UmVjdC53aWR0aCArIFwicHhcIjtcbiAgICAgICAgICBpZiAoc2Nyb2xsQW5jZXN0b3IpIHRoaXMubWVudS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5tZW51LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICAgIHRoaXMuc3BhY2VyID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBwcmVmaXggKyBcIi1zcGFjZXJcIixcbiAgICAgICAgICAgIHN0eWxlOiBcImhlaWdodDogXCIuY29uY2F0KG1lbnVSZWN0LmhlaWdodCwgXCJweFwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5zcGFjZXIsIHRoaXMubWVudSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMud3JhcHBlci5wYXJlbnROb2RlKSB0aGlzLndyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5lZGl0b3JWaWV3LmRvbSwgdGhpcy53cmFwcGVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVudUJhclZpZXc7XG59KCk7XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbklzSW52ZXJ0ZWQoc2VsZWN0aW9uKSB7XG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PSBzZWxlY3Rpb24uZm9jdXNOb2RlKSByZXR1cm4gc2VsZWN0aW9uLmFuY2hvck9mZnNldCA+IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgcmV0dXJuIHNlbGVjdGlvbi5hbmNob3JOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHNlbGVjdGlvbi5mb2N1c05vZGUpID09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xufVxuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdTY3JvbGxhYmxlKG5vZGUpIHtcbiAgZm9yICh2YXIgY3VyID0gbm9kZS5wYXJlbnROb2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0KSByZXR1cm4gY3VyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbFdyYXBwaW5nKG5vZGUpIHtcbiAgdmFyIHJlcyA9IFt3aW5kb3ddO1xuXG4gIGZvciAodmFyIGN1ciA9IG5vZGUucGFyZW50Tm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgIHJlcy5wdXNoKGN1cik7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLkRyb3Bkb3duID0gRHJvcGRvd247XG5leHBvcnRzLkRyb3Bkb3duU3VibWVudSA9IERyb3Bkb3duU3VibWVudTtcbmV4cG9ydHMuTWVudUl0ZW0gPSBNZW51SXRlbTtcbmV4cG9ydHMuYmxvY2tUeXBlSXRlbSA9IGJsb2NrVHlwZUl0ZW07XG5leHBvcnRzLmljb25zID0gaWNvbnM7XG5leHBvcnRzLmpvaW5VcEl0ZW0gPSBqb2luVXBJdGVtO1xuZXhwb3J0cy5saWZ0SXRlbSA9IGxpZnRJdGVtO1xuZXhwb3J0cy5tZW51QmFyID0gbWVudUJhcjtcbmV4cG9ydHMucmVkb0l0ZW0gPSByZWRvSXRlbTtcbmV4cG9ydHMucmVuZGVyR3JvdXBlZCA9IHJlbmRlckdyb3VwZWQ7XG5leHBvcnRzLnNlbGVjdFBhcmVudE5vZGVJdGVtID0gc2VsZWN0UGFyZW50Tm9kZUl0ZW07XG5leHBvcnRzLnVuZG9JdGVtID0gdW5kb0l0ZW07XG5leHBvcnRzLndyYXBJdGVtID0gd3JhcEl0ZW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIE9yZGVyZWRNYXAgPSByZXF1aXJlKCdvcmRlcmVkbWFwJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeShlKSB7XG4gIHJldHVybiBlICYmIF90eXBlb2YoZSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHtcbiAgICAnZGVmYXVsdCc6IGVcbiAgfTtcbn1cblxudmFyIE9yZGVyZWRNYXBfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHRMZWdhY3koT3JkZXJlZE1hcCk7XG5cbmZ1bmN0aW9uIF9maW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICBmb3IgKHZhciBpID0gMDs7IGkrKykge1xuICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudCkgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgIHZhciBjaGlsZEEgPSBhLmNoaWxkKGkpLFxuICAgICAgICBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuXG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpIHJldHVybiBwb3M7XG5cbiAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspIHtcbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgdmFyIGlubmVyID0gX2ZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcblxuICAgICAgaWYgKGlubmVyICE9IG51bGwpIHJldHVybiBpbm5lcjtcbiAgICB9XG5cbiAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9maW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gIGZvciAodmFyIGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMCkgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHtcbiAgICAgIGE6IHBvc0EsXG4gICAgICBiOiBwb3NCXG4gICAgfTtcbiAgICB2YXIgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSxcbiAgICAgICAgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSxcbiAgICAgICAgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcblxuICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICBwb3NBIC09IHNpemU7XG4gICAgICBwb3NCIC09IHNpemU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpIHJldHVybiB7XG4gICAgICBhOiBwb3NBLFxuICAgICAgYjogcG9zQlxuICAgIH07XG5cbiAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgdmFyIHNhbWUgPSAwLFxuICAgICAgICAgIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgIHNhbWUrKztcbiAgICAgICAgcG9zQS0tO1xuICAgICAgICBwb3NCLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IHBvc0EsXG4gICAgICAgIGI6IHBvc0JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgdmFyIGlubmVyID0gX2ZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcblxuICAgICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG4gICAgfVxuXG4gICAgcG9zQSAtPSBzaXplO1xuICAgIHBvc0IgLT0gc2l6ZTtcbiAgfVxufVxuXG52YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYWdtZW50KGNvbnRlbnQsIHNpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhZ21lbnQpO1xuXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcIm5vZGVzQmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgIHZhciBub2RlU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY29udGVudFtpXSxcbiAgICAgICAgICAgIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuXG4gICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NlbmRhbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgIHZhciB0ZXh0ID0gXCJcIixcbiAgICAgICAgICBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgdGV4dCArPSBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgIHNlcGFyYXRlZCA9ICFibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzTGVhZikge1xuICAgICAgICAgIGlmIChsZWFmVGV4dCkge1xuICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUuc3BlYy5sZWFmVGV4dCkge1xuICAgICAgICAgICAgdGV4dCArPSBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlcGFyYXRlZCAmJiBub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQob3RoZXIpIHtcbiAgICAgIGlmICghb3RoZXIuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXRoaXMuc2l6ZSkgcmV0dXJuIG90aGVyO1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmxhc3RDaGlsZCxcbiAgICAgICAgICBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICBpID0gMTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1dChmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2l6ZTtcbiAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzaXplID0gMDtcbiAgICAgIGlmICh0byA+IGZyb20pIGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY29udGVudFtpXSxcbiAgICAgICAgICAgIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuXG4gICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQpIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtlbHNlIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MgLSAxKSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHBvcyAtIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0QnlJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb0VuZChub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZENvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQoaW5kZXgpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICBpZiAoIWZvdW5kKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRGlmZlN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmU3RhcnQob3RoZXIpIHtcbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmREaWZmRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmRW5kKG90aGVyKSB7XG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICB2YXIgb3RoZXJQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG90aGVyLnNpemU7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbmRleChwb3MpIHtcbiAgICAgIHZhciByb3VuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogLTE7XG4gICAgICBpZiAocG9zID09IDApIHJldHVybiByZXRJbmRleCgwLCBwb3MpO1xuICAgICAgaWYgKHBvcyA9PSB0aGlzLnNpemUpIHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiLmNvbmNhdChwb3MsIFwiIG91dHNpZGUgb2YgZnJhZ21lbnQgKFwiKS5jb25jYXQodGhpcywgXCIpXCIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY2hpbGQoaSksXG4gICAgICAgICAgICBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG5cbiAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICBpZiAoZW5kID09IHBvcyB8fCByb3VuZCA+IDApIHJldHVybiByZXRJbmRleChpICsgMSwgZW5kKTtcbiAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSwgY3VyUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ0lubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nSW5uZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbi50b0pTT04oKTtcbiAgICAgIH0pIDogbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgdmFyIGpvaW5lZCxcbiAgICAgICAgICBzaXplID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGFycmF5W2ldO1xuICAgICAgICBzaXplICs9IG5vZGUubm9kZVNpemU7XG5cbiAgICAgICAgaWYgKGkgJiYgbm9kZS5pc1RleHQgJiYgYXJyYXlbaSAtIDFdLnNhbWVNYXJrdXAobm9kZSkpIHtcbiAgICAgICAgICBpZiAoIWpvaW5lZCkgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGUud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgICAgICBqb2luZWQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShub2Rlcykge1xuICAgICAgaWYgKCFub2RlcykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpIHJldHVybiBub2RlcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgIGlmIChub2Rlcy5hdHRycykgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICsgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFnbWVudDtcbn0oKTtcblxuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xudmFyIGZvdW5kID0ge1xuICBpbmRleDogMCxcbiAgb2Zmc2V0OiAwXG59O1xuXG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCEoYSAmJiBfdHlwZW9mKGEpID09IFwib2JqZWN0XCIpIHx8ICEoYiAmJiBfdHlwZW9mKGIpID09IFwib2JqZWN0XCIpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIShwIGluIGIpIHx8ICFjb21wYXJlRGVlcChhW3BdLCBiW3BdKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9wIGluIGIpIHtcbiAgICAgIGlmICghKF9wIGluIGEpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBNYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmspO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFyaywgW3tcbiAgICBrZXk6IFwiYWRkVG9TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9TZXQoc2V0KSB7XG4gICAgICB2YXIgY29weSxcbiAgICAgICAgICBwbGFjZWQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG90aGVyID0gc2V0W2ldO1xuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpIHJldHVybiBzZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgICAgIGlmICghY29weSkgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgICAgICBpZiAoIWNvcHkpIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb3B5KSBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29weSkgY29weSA9IHNldC5zbGljZSgpO1xuICAgICAgaWYgKCFwbGFjZWQpIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVGcm9tU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKSByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJblNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZS5uYW1lXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAoIWpzb24pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTWFyay5mcm9tSlNPTlwiKTtcbiAgICAgIHZhciB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICBpZiAoIXR5cGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gbWFyayB0eXBlIFwiLmNvbmNhdChqc29uLnR5cGUsIFwiIGluIHRoaXMgc2NoZW1hXCIpKTtcbiAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2FtZVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1lU2V0KGEsIGIpIHtcbiAgICAgIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbShtYXJrcykge1xuICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMCkgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspIHJldHVybiBbbWFya3NdO1xuICAgICAgdmFyIGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgY29weS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFyaztcbn0oKTtcblxuTWFyay5ub25lID0gW107XG5cbnZhciBSZXBsYWNlRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhSZXBsYWNlRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZXBsYWNlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFJlcGxhY2VFcnJvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGFjZUVycm9yKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVwbGFjZUVycm9yKTtcbn0oX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGljZSk7XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIHRoaXMub3BlbkVuZCA9IG9wZW5FbmQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpY2UsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQgJiYgbmV3IFNsaWNlKGNvbnRlbnQsIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApIGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7XG4gICAgICBpZiAodGhpcy5vcGVuRW5kID4gMCkganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAoIWpzb24pIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLFxuICAgICAgICAgIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heE9wZW4oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBvcGVuSXNvbGF0aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIG9wZW5TdGFydCA9IDAsXG4gICAgICAgICAgb3BlbkVuZCA9IDA7XG5cbiAgICAgIGZvciAodmFyIG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZCkge1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX24gPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IF9uICYmICFfbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIV9uLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBfbiA9IF9uLmxhc3RDaGlsZCkge1xuICAgICAgICBvcGVuRW5kKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNsaWNlO1xufSgpO1xuXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gIHZhciBfY29udGVudCRmaW5kSW5kZXggPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSxcbiAgICAgIGluZGV4ID0gX2NvbnRlbnQkZmluZEluZGV4LmluZGV4LFxuICAgICAgb2Zmc2V0ID0gX2NvbnRlbnQkZmluZEluZGV4Lm9mZnNldCxcbiAgICAgIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcblxuICB2YXIgX2NvbnRlbnQkZmluZEluZGV4MiA9IGNvbnRlbnQuZmluZEluZGV4KHRvKSxcbiAgICAgIGluZGV4VG8gPSBfY29udGVudCRmaW5kSW5kZXgyLmluZGV4LFxuICAgICAgb2Zmc2V0VG8gPSBfY29udGVudCRmaW5kSW5kZXgyLm9mZnNldDtcblxuICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gIH1cblxuICBpZiAoaW5kZXggIT0gaW5kZXhUbykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDMgPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSxcbiAgICAgIGluZGV4ID0gX2NvbnRlbnQkZmluZEluZGV4My5pbmRleCxcbiAgICAgIG9mZnNldCA9IF9jb250ZW50JGZpbmRJbmRleDMub2Zmc2V0LFxuICAgICAgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuXG4gIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpO1xuICB9XG5cbiAgdmFyIGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aCkgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluc2VydGVkIGNvbnRlbnQgZGVlcGVyIHRoYW4gaW5zZXJ0aW9uIHBvc2l0aW9uXCIpO1xuICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZCkgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgdmFyIGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLFxuICAgICAgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuXG4gIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICB2YXIgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICB9IGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICB9IGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7XG4gICAgdmFyIHBhcmVudCA9ICRmcm9tLnBhcmVudCxcbiAgICAgICAgY29udGVudCA9IHBhcmVudC5jb250ZW50O1xuICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcHJlcGFyZVNsaWNlRm9yUmVwbGEgPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSksXG4gICAgICAgIHN0YXJ0ID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLnN0YXJ0LFxuICAgICAgICBlbmQgPSBfcHJlcGFyZVNsaWNlRm9yUmVwbGEuZW5kO1xuXG4gICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgc3RhcnQsIGVuZCwgJHRvLCBkZXB0aCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKSB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cblxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICB2YXIgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gIHZhciBsYXN0ID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSkgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtlbHNlIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gIHZhciBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwLFxuICAgICAgZW5kSW5kZXggPSAkZW5kID8gJGVuZC5pbmRleChkZXB0aCkgOiBub2RlLmNoaWxkQ291bnQ7XG5cbiAgaWYgKCRzdGFydCkge1xuICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuXG4gICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgfSBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgfVxuXG4gIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KSBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICBpZiAoIW5vZGUudHlwZS52YWxpZENvbnRlbnQoY29udGVudCkpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgXCIgKyBub2RlLnR5cGUubmFtZSk7XG4gIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gIHZhciBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gIHZhciBvcGVuRW5kID0gJHRvLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGVuZCwgJHRvLCBkZXB0aCArIDEpO1xuICB2YXIgY29udGVudCA9IFtdO1xuICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuXG4gIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3BlblN0YXJ0KSBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5FbmQpIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuXG4gIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gIHZhciBjb250ZW50ID0gW107XG4gIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG5cbiAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICB2YXIgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuXG4gIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgdmFyIGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LFxuICAgICAgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICB2YXIgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuXG4gIGZvciAodmFyIGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICBlbmQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUobm9kZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kIC0gZXh0cmEpXG4gIH07XG59XG5cbnZhciBSZXNvbHZlZFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZWRQb3MpO1xuXG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNvbHZlZFBvcywgW3tcbiAgICBrZXk6IFwicmVzb2x2ZURlcHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICBpZiAodmFsIDwgMCkgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZSgwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlKGRlcHRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChkZXB0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZGV4QWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhBZnRlcihkZXB0aCkge1xuICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChkZXB0aCkge1xuICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGRlcHRoKSArIHRoaXMubm9kZShkZXB0aCkuY29udGVudC5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIGlmICghZGVwdGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlcihkZXB0aCkge1xuICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICBpZiAoIWRlcHRoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVBZnRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVCZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChkT2ZmKSByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKTtcbiAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0F0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zQXRJbmRleChpbmRleCwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSxcbiAgICAgICAgICBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya3MoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKSByZXR1cm4gTWFyay5ub25lO1xuICAgICAgaWYgKHRoaXMudGV4dE9mZnNldCkgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICB2YXIgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksXG4gICAgICAgICAgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG5cbiAgICAgIGlmICghbWFpbikge1xuICAgICAgICB2YXIgdG1wID0gbWFpbjtcbiAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmtzID0gbWFpbi5tYXJrcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKSBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya3NBY3Jvc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gYWZ0ZXIubWFya3MsXG4gICAgICAgICAgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSkgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoYXJlZERlcHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgZm9yICh2YXIgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnQoZGVwdGgpIDw9IHBvcyAmJiB0aGlzLmVuZChkZXB0aCkgPj0gcG9zKSByZXR1cm4gZGVwdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibG9ja1JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrUmFuZ2UoKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXM7XG4gICAgICB2YXIgcHJlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKSByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpIHJldHVybiBuZXcgTm9kZVJhbmdlKHRoaXMsIG90aGVyLCBkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICAgIHBhcmVudE9mZnNldCA9IHBvcztcblxuICAgICAgZm9yICh2YXIgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZW50JGZpbmRJbmQgPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCksXG4gICAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5pbmRleCxcbiAgICAgICAgICAgIG9mZnNldCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5vZmZzZXQ7XG5cbiAgICAgICAgdmFyIHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgIGlmICghcmVtKSBicmVhaztcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIGJyZWFrO1xuICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZUNhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2FjaGVkID0gcmVzb2x2ZUNhY2hlW2ldO1xuICAgICAgICBpZiAoY2FjaGVkLnBvcyA9PSBwb3MgJiYgY2FjaGVkLmRvYyA9PSBkb2MpIHJldHVybiBjYWNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgcmVzb2x2ZUNhY2hlUG9zID0gKHJlc29sdmVDYWNoZVBvcyArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc29sdmVkUG9zO1xufSgpO1xuXG52YXIgcmVzb2x2ZUNhY2hlID0gW10sXG4gICAgcmVzb2x2ZUNhY2hlUG9zID0gMCxcbiAgICByZXNvbHZlQ2FjaGVTaXplID0gMTI7XG5cbnZhciBOb2RlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGVSYW5nZSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlUmFuZ2UpO1xuXG4gICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgIHRoaXMuJHRvID0gJHRvO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlUmFuZ2UsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRJbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZEluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZVJhbmdlO1xufSgpO1xuXG52YXIgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciBOb2RlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50KSB7XG4gICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBNYXJrLm5vbmU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2Rlc0JldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICB2YXIgc3RhcnRQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NlbmRhbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dENvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzYW1lTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNNYXJrdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0KGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5jb250ZW50LnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY29udGVudC5zaXplO1xuICAgICAgdmFyIGluY2x1ZGVQYXJlbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIGlmIChmcm9tID09IHRvKSByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICB2YXIgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksXG4gICAgICAgICAgJHRvID0gdGhpcy5yZXNvbHZlKHRvKTtcbiAgICAgIHZhciBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgIHZhciBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSxcbiAgICAgICAgICBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICB2YXIgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsICRmcm9tLmRlcHRoIC0gZGVwdGgsICR0by5kZXB0aCAtIGRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgcmV0dXJuIF9yZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZUF0KHBvcykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICB2YXIgX25vZGUkY29udGVudCRmaW5kSW5kMiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocG9zKSxcbiAgICAgICAgICAgIGluZGV4ID0gX25vZGUkY29udGVudCRmaW5kSW5kMi5pbmRleCxcbiAgICAgICAgICAgIG9mZnNldCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZDIub2Zmc2V0O1xuXG4gICAgICAgIG5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICB2YXIgX3RoaXMkY29udGVudCRmaW5kSW5kID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkY29udGVudCRmaW5kSW5kLmluZGV4LFxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJGNvbnRlbnQkZmluZEluZC5vZmZzZXQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGRCZWZvcmUocG9zKSB7XG4gICAgICBpZiAocG9zID09IDApIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdGhpcyRjb250ZW50JGZpbmRJbmQyID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkY29udGVudCRmaW5kSW5kMi5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRjb250ZW50JGZpbmRJbmQyLm9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA8IHBvcykgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBpbmRleDogaW5kZXggLSAxLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShwb3MpIHtcbiAgICAgIHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVOb0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVOb0NhY2hlKHBvcykge1xuICAgICAgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VIYXNNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBpZiAodG8gPiBmcm9tKSB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSkgZm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNCbG9jaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUZXh0YmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZUNvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbmxpbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRNYXRjaEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5SZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2UoZnJvbSwgdG8pIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogRnJhZ21lbnQuZW1wdHk7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiByZXBsYWNlbWVudC5jaGlsZENvdW50O1xuICAgICAgdmFyIG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICB2YXIgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhyZXBsYWNlbWVudC5jaGlsZChpKS5tYXJrcykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhblJlcGxhY2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5BcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKSByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtlbHNlIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgaWYgKCF0aGlzLnR5cGUudmFsaWRDb250ZW50KHRoaXMuY29udGVudCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiLmNvbmNhdCh0aGlzLnR5cGUubmFtZSwgXCI6IFwiKS5jb25jYXQodGhpcy5jb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApKSk7XG4gICAgICB2YXIgY29weSA9IE1hcmsubm9uZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvcHkgPSB0aGlzLm1hcmtzW2ldLmFkZFRvU2V0KGNvcHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbGxlY3Rpb24gb2YgbWFya3MgZm9yIG5vZGUgXCIuY29uY2F0KHRoaXMudHlwZS5uYW1lLCBcIjogXCIpLmNvbmNhdCh0aGlzLm1hcmtzLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbS50eXBlLm5hbWU7XG4gICAgICB9KSkpO1xuICAgICAgdGhpcy5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hlY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLm5hbWVcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKSBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aCkgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udG9KU09OKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAoIWpzb24pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgIHZhciBtYXJrcyA9IG51bGw7XG5cbiAgICAgIGlmIChqc29uLm1hcmtzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIik7XG4gICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZTtcbn0oKTtcblxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcblxudmFyIFRleHROb2RlID0gZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhUZXh0Tm9kZSwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFRleHROb2RlKTtcblxuICBmdW5jdGlvbiBUZXh0Tm9kZSh0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dE5vZGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIyLmNhbGwodGhpcywgdHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICBpZiAoIWNvbnRlbnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgX3RoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHROb2RlLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKSByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFRleHQodGV4dCkge1xuICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1dCgpIHtcbiAgICAgIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgYmFzZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFRleHROb2RlLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0Tm9kZTtcbn0oTm9kZSk7XG5cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gIGZvciAodmFyIGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG52YXIgQ29udGVudE1hdGNoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZW50TWF0Y2godmFsaWRFbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGVudE1hdGNoKTtcblxuICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICB0aGlzLm5leHQgPSBbXTtcbiAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRlbnRNYXRjaCwgW3tcbiAgICBrZXk6IFwibWF0Y2hUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSkgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hGcmFnbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaEZyYWdtZW50KGZyYWcpIHtcbiAgICAgIHZhciBzdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZyYWcuY2hpbGRDb3VudDtcbiAgICAgIHZhciBjdXIgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmxpbmVDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5uZXh0W2ldLnR5cGU7XG4gICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSkgcmV0dXJuIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXRpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhdGlibGUob3RoZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsQmVmb3JlKGFmdGVyKSB7XG4gICAgICB2YXIgdG9FbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgc2VlbiA9IFt0aGlzXTtcblxuICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICB2YXIgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKSByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAoZnVuY3Rpb24gKHRwKSB7XG4gICAgICAgICAgcmV0dXJuIHRwLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfbWF0Y2gkbmV4dCRpID0gbWF0Y2gubmV4dFtpXSxcbiAgICAgICAgICAgICAgdHlwZSA9IF9tYXRjaCRuZXh0JGkudHlwZSxcbiAgICAgICAgICAgICAgbmV4dCA9IF9tYXRjaCRuZXh0JGkubmV4dDtcblxuICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcblxuICAgICAgICAgICAgdmFyIF9mb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuXG4gICAgICAgICAgICBpZiAoX2ZvdW5kKSByZXR1cm4gX2ZvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldCkgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVXcmFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICB2YXIgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgYWN0aXZlID0gW3tcbiAgICAgICAgbWF0Y2g6IHRoaXMsXG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIHZpYTogbnVsbFxuICAgICAgfV07XG5cbiAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksXG4gICAgICAgICAgICBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG5cbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfbWF0Y2gkbmV4dCRpMiA9IG1hdGNoLm5leHRbaV0sXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWF0Y2gkbmV4dCRpMi50eXBlLFxuICAgICAgICAgICAgICBuZXh0ID0gX21hdGNoJG5leHQkaTIubmV4dDtcblxuICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaCh7XG4gICAgICAgICAgICAgIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgdmlhOiBjdXJyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlZGdlQ291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkZ2Uobikge1xuICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSdzIG5vIFwiLmNvbmNhdChuLCBcInRoIGVkZ2UgaW4gdGhpcyBjb250ZW50IG1hdGNoXCIpKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRbbl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHNlZW4gPSBbXTtcblxuICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgIHNlZW4ucHVzaChtKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKSBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY2FuKHRoaXMpO1xuICAgICAgcmV0dXJuIHNlZW4ubWFwKGZ1bmN0aW9uIChtLCBpKSB7XG4gICAgICAgIHZhciBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtLm5leHQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgb3V0ICs9IChfaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W19pXS50eXBlLm5hbWUgKyBcIi0+XCIgKyBzZWVuLmluZGV4T2YobS5uZXh0W19pXS5uZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKSByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgIGlmIChzdHJlYW0ubmV4dCkgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgIHZhciBtYXRjaCA9IGRmYShuZmEoZXhwcikpO1xuICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGVudE1hdGNoO1xufSgpO1xuXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuXG52YXIgVG9rZW5TdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRva2VuU3RyZWFtKTtcblxuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKSB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRva2VuU3RyZWFtLCBbe1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWF0KHRvaykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnIoc3RyKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRva2VuU3RyZWFtO1xufSgpO1xuXG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gIHZhciBleHBycyA9IFtdO1xuXG4gIGRvIHtcbiAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuXG4gIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge1xuICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgZXhwcnM6IGV4cHJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgdmFyIGV4cHJzID0gW107XG5cbiAgZG8ge1xuICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG5cbiAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7XG4gICAgdHlwZTogXCJzZXFcIixcbiAgICBleHByczogZXhwcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICB2YXIgZXhwciA9IHBhcnNlRXhwckF0b20oc3RyZWFtKTtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKSBleHByID0ge1xuICAgICAgdHlwZTogXCJwbHVzXCIsXG4gICAgICBleHByOiBleHByXG4gICAgfTtlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkgZXhwciA9IHtcbiAgICAgIHR5cGU6IFwic3RhclwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIGV4cHIgPSB7XG4gICAgICB0eXBlOiBcIm9wdFwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO2Vsc2UgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gIGlmICgvXFxELy50ZXN0KHN0cmVhbS5uZXh0KSkgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICB2YXIgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgc3RyZWFtLnBvcysrO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgdmFyIG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksXG4gICAgICBtYXggPSBtaW47XG5cbiAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgaWYgKHN0cmVhbS5uZXh0ICE9IFwifVwiKSBtYXggPSBwYXJzZU51bShzdHJlYW0pO2Vsc2UgbWF4ID0gLTE7XG4gIH1cblxuICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKSBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBleHByOiBleHByXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICB2YXIgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLFxuICAgICAgdHlwZSA9IHR5cGVzW25hbWVdO1xuICBpZiAodHlwZSkgcmV0dXJuIFt0eXBlXTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgdmFyIF90eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgIGlmIChfdHlwZS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKSByZXN1bHQucHVzaChfdHlwZSk7XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKSBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwckF0b20oc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgIHZhciBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSkgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICByZXR1cm4gZXhwcjtcbiAgfSBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICB2YXIgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChzdHJlYW0uaW5saW5lID09IG51bGwpIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO2Vsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSkgc3RyZWFtLmVycihcIk1peGluZyBpbmxpbmUgYW5kIGJsb2NrIGNvbnRlbnRcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hbWVcIixcbiAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge1xuICAgICAgdHlwZTogXCJjaG9pY2VcIixcbiAgICAgIGV4cHJzOiBleHByc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgdmFyIG5mYSA9IFtbXV07XG4gIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgcmV0dXJuIG5mYTtcblxuICBmdW5jdGlvbiBub2RlKCkge1xuICAgIHJldHVybiBuZmEucHVzaChbXSkgLSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgIHZhciBlZGdlID0ge1xuICAgICAgdGVybTogdGVybSxcbiAgICAgIHRvOiB0b1xuICAgIH07XG4gICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykge1xuICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnRvID0gdG87XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZShmdW5jdGlvbiAob3V0LCBleHByKSB7XG4gICAgICAgIHJldHVybiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpO1xuICAgICAgfSwgW10pO1xuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKSByZXR1cm4gbmV4dDtcbiAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgdmFyIGxvb3AgPSBub2RlKCk7XG4gICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgdmFyIF9sb29wID0gbm9kZSgpO1xuXG4gICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgX2xvb3ApO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgX2xvb3ApLCBfbG9vcCk7XG4gICAgICByZXR1cm4gW2VkZ2UoX2xvb3ApXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgdmFyIGN1ciA9IGZyb207XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGV4cHIubWluOyBfaTIrKykge1xuICAgICAgICB2YXIgX25leHQgPSBub2RlKCk7XG5cbiAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgX25leHQpO1xuICAgICAgICBjdXIgPSBfbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaTMgPSBleHByLm1pbjsgX2kzIDwgZXhwci5tYXg7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9uZXh0MiA9IG5vZGUoKTtcblxuICAgICAgICAgIGVkZ2UoY3VyLCBfbmV4dDIpO1xuICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIF9uZXh0Mik7XG4gICAgICAgICAgY3VyID0gX25leHQyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgcmV0dXJuIGIgLSBhO1xufVxuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBzY2FuKG5vZGUpO1xuICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcblxuICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICB2YXIgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKSByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgcmVzdWx0LnB1c2gobm9kZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2VkZ2VzJGkgPSBlZGdlc1tpXSxcbiAgICAgICAgICB0ZXJtID0gX2VkZ2VzJGkudGVybSxcbiAgICAgICAgICB0byA9IF9lZGdlcyRpLnRvO1xuICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSkgc2Nhbih0byk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRmYShuZmEpIHtcbiAgdmFyIGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcblxuICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbmZhW25vZGVdLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHRlcm0gPSBfcmVmLnRlcm0sXG4gICAgICAgICAgICB0byA9IF9yZWYudG87XG4gICAgICAgIGlmICghdGVybSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2V0O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKSBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgIH1cblxuICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKCFzZXQpIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSkgc2V0LnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9zdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuXG4gICAgICBzdGF0ZS5uZXh0LnB1c2goe1xuICAgICAgICB0eXBlOiBvdXRbaV1bMF0sXG4gICAgICAgIG5leHQ6IGxhYmVsZWRbX3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShfc3RhdGVzKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICBmb3IgKHZhciBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gd29ya1tpXSxcbiAgICAgICAgZGVhZCA9ICFzdGF0ZS52YWxpZEVuZCxcbiAgICAgICAgbm9kZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9zdGF0ZSRuZXh0JGogPSBzdGF0ZS5uZXh0W2pdLFxuICAgICAgICAgIHR5cGUgPSBfc3RhdGUkbmV4dCRqLnR5cGUsXG4gICAgICAgICAgbmV4dCA9IF9zdGF0ZSRuZXh0JGoubmV4dDtcbiAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKSBkZWFkID0gZmFsc2U7XG4gICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKSB3b3JrLnB1c2gobmV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGRlYWQpIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgdmFyIGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgIGlmICghYXR0ci5oYXNEZWZhdWx0KSByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyW1wiZGVmYXVsdFwiXTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0cztcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgdmFyIGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBuYW1lIGluIGF0dHJzKSB7XG4gICAgdmFyIGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG5cbiAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpIGdpdmVuID0gYXR0cltcImRlZmF1bHRcIl07ZWxzZSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICB9XG5cbiAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWx0O1xufVxuXG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChhdHRycykgZm9yICh2YXIgbmFtZSBpbiBhdHRycykge1xuICAgIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUoYXR0cnNbbmFtZV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBOb2RlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVUeXBlKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmlzQmxvY2sgPSAhKHNwZWMuaW5saW5lIHx8IG5hbWUgPT0gXCJ0ZXh0XCIpO1xuICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlVHlwZSwgW3tcbiAgICBrZXk6IFwiaXNJbmxpbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc0Jsb2NrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RleHRibG9ja1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBdG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0xlYWYgfHwgISF0aGlzLnNwZWMuYXRvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2hpdGVzcGFjZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzUmVxdWlyZWRBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhdGlibGVDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhdGlibGVDb250ZW50KG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMpIHtcbiAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpIHJldHVybiB0aGlzLmRlZmF1bHRBdHRycztlbHNlIHJldHVybiBfY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWFya3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmlzVGV4dCkgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNoZWNrZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2hlY2tlZCgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWFya3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgXCIgKyB0aGlzLm5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgY29udGVudCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUFuZEZpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQW5kRmlsbCgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWFya3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG5cbiAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoY29udGVudCk7XG4gICAgICAgIGlmICghYmVmb3JlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgIHZhciBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgIGlmICghYWZ0ZXIpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb3dzTWFya1R5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb3dzTWFya1R5cGUobWFya1R5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb3dzTWFya3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd2VkTWFya3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb3dlZE1hcmtzKG1hcmtzKSB7XG4gICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpIHJldHVybiBtYXJrcztcbiAgICAgIHZhciBjb3B5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgIGlmICghY29weSkgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKTtcbiAgICAgIGlmICghcmVzdWx0LnRleHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIik7XG5cbiAgICAgIGZvciAodmFyIF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVUeXBlO1xufSgpO1xuXG52YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyaWJ1dGUpO1xuXG4gICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICB0aGlzW1wiZGVmYXVsdFwiXSA9IG9wdGlvbnNbXCJkZWZhdWx0XCJdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZSwgW3tcbiAgICBrZXk6IFwiaXNSZXF1aXJlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZTtcbn0oKTtcblxudmFyIE1hcmtUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXJrVHlwZShuYW1lLCByYW5rLCBzY2hlbWEsIHNwZWMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya1R5cGUpO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICB2YXIgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXJrVHlwZSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSkgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgX2NvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVGcm9tU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJblNldChzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSByZXR1cm4gc2V0W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGNsdWRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGNsdWRlcyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgcmFuayA9IDA7XG4gICAgICBtYXJrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrVHlwZTtcbn0oKTtcblxudmFyIFNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NoZW1hKHNwZWMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NoZW1hKTtcblxuICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnNwZWMgPSB7XG4gICAgICBub2RlczogT3JkZXJlZE1hcF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnJvbShzcGVjLm5vZGVzKSxcbiAgICAgIG1hcmtzOiBPcmRlcmVkTWFwX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgdG9wTm9kZTogc3BlYy50b3BOb2RlXG4gICAgfTtcbiAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgdmFyIGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICBpZiAocHJvcCBpbiB0aGlzLm1hcmtzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLFxuICAgICAgICAgIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIixcbiAgICAgICAgICBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHwgKGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdID0gQ29udGVudE1hdGNoLnBhcnNlKGNvbnRlbnRFeHByLCB0aGlzLm5vZGVzKSk7XG4gICAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDogbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDogbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9wcm9wIGluIHRoaXMubWFya3MpIHtcbiAgICAgIHZhciBfdHlwZTIgPSB0aGlzLm1hcmtzW19wcm9wXSxcbiAgICAgICAgICBleGNsID0gX3R5cGUyLnNwZWMuZXhjbHVkZXM7XG4gICAgICBfdHlwZTIuZXhjbHVkZWQgPSBleGNsID09IG51bGwgPyBbX3R5cGUyXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgIH1cblxuICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgdGhpcy50b3BOb2RlVHlwZSA9IHRoaXMubm9kZXNbdGhpcy5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIl07XG4gICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2hlbWEsIFt7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZSh0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIikgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7ZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO2Vsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0KF90ZXh0LCBtYXJrcykge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCBfdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZUZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICByZXR1cm4gTm9kZS5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0Zyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICByZXR1cm4gTWFyay5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZVR5cGUobmFtZSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgIGlmICghZm91bmQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjaGVtYTtcbn0oKTtcblxuZnVuY3Rpb24gZ2F0aGVyTWFya3Moc2NoZW1hLCBtYXJrcykge1xuICB2YXIgZm91bmQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBtYXJrc1tpXSxcbiAgICAgICAgbWFyayA9IHNjaGVtYS5tYXJrc1tuYW1lXSxcbiAgICAgICAgb2sgPSBtYXJrO1xuXG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgIHZhciBfbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgX21hcmsuc3BlYy5ncm91cCAmJiBfbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpIGZvdW5kLnB1c2gob2sgPSBfbWFyayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvaykgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBtYXJrIHR5cGU6ICdcIiArIG1hcmtzW2ldICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG52YXIgRE9NUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBET01QYXJzZXIoc2NoZW1hLCBydWxlcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVBhcnNlcik7XG5cbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAocnVsZS50YWcpIF90aGlzMi50YWdzLnB1c2gocnVsZSk7ZWxzZSBpZiAocnVsZS5zdHlsZSkgX3RoaXMyLnN0eWxlcy5wdXNoKHJ1bGUpO1xuICAgIH0pO1xuICAgIHRoaXMubm9ybWFsaXplTGlzdHMgPSAhdGhpcy50YWdzLnNvbWUoZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgICAgcmV0dXJuIG5vZGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01QYXJzZXIsIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGRvbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU2xpY2UoZG9tKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgZm9yICh2YXIgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiYgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiYgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgZm9yICh2YXIgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5zdHlsZXNbaV0sXG4gICAgICAgICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHwgcnVsZS5jb250ZXh0ICYmICFjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkgfHwgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiYgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBydWxlLmdldEF0dHJzKHZhbHVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgY29udGludWU7XG4gICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzY2hlbWFSdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgdmFyIHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgICAgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKG5hbWUpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgIGlmIChydWxlcykgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICBfbG9vcDIobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcDMgPSBmdW5jdGlvbiBfbG9vcDMoX25hbWUpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm5vZGVzW19uYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICBpZiAocnVsZXMpIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgIHJ1bGUubm9kZSA9IF9uYW1lO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9uYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICBfbG9vcDMoX25hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHwgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTVBhcnNlcjtcbn0oKTtcblxudmFyIGJsb2NrVGFncyA9IHtcbiAgYWRkcmVzczogdHJ1ZSxcbiAgYXJ0aWNsZTogdHJ1ZSxcbiAgYXNpZGU6IHRydWUsXG4gIGJsb2NrcXVvdGU6IHRydWUsXG4gIGNhbnZhczogdHJ1ZSxcbiAgZGQ6IHRydWUsXG4gIGRpdjogdHJ1ZSxcbiAgZGw6IHRydWUsXG4gIGZpZWxkc2V0OiB0cnVlLFxuICBmaWdjYXB0aW9uOiB0cnVlLFxuICBmaWd1cmU6IHRydWUsXG4gIGZvb3RlcjogdHJ1ZSxcbiAgZm9ybTogdHJ1ZSxcbiAgaDE6IHRydWUsXG4gIGgyOiB0cnVlLFxuICBoMzogdHJ1ZSxcbiAgaDQ6IHRydWUsXG4gIGg1OiB0cnVlLFxuICBoNjogdHJ1ZSxcbiAgaGVhZGVyOiB0cnVlLFxuICBoZ3JvdXA6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBsaTogdHJ1ZSxcbiAgbm9zY3JpcHQ6IHRydWUsXG4gIG9sOiB0cnVlLFxuICBvdXRwdXQ6IHRydWUsXG4gIHA6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgc2VjdGlvbjogdHJ1ZSxcbiAgdGFibGU6IHRydWUsXG4gIHRmb290OiB0cnVlLFxuICB1bDogdHJ1ZVxufTtcbnZhciBpZ25vcmVUYWdzID0ge1xuICBoZWFkOiB0cnVlLFxuICBub3NjcmlwdDogdHJ1ZSxcbiAgb2JqZWN0OiB0cnVlLFxuICBzY3JpcHQ6IHRydWUsXG4gIHN0eWxlOiB0cnVlLFxuICB0aXRsZTogdHJ1ZVxufTtcbnZhciBsaXN0VGFncyA9IHtcbiAgb2w6IHRydWUsXG4gIHVsOiB0cnVlXG59O1xudmFyIE9QVF9QUkVTRVJWRV9XUyA9IDEsXG4gICAgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLFxuICAgIE9QVF9PUEVOX0xFRlQgPSA0O1xuXG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbCkgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8IChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cblxudmFyIE5vZGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgbWFya3MsIHBlbmRpbmdNYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDb250ZXh0KTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgIHRoaXMuc3Rhc2hNYXJrcyA9IFtdO1xuICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVDb250ZXh0LCBbe1xuICAgIGtleTogXCJmaW5kV3JhcHBpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcblxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCxcbiAgICAgICAgICAgICAgd3JhcDtcblxuICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmlzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBtO1xuXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aCkgdGhpcy5jb250ZW50LnBvcCgpO2Vsc2UgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wRnJvbVN0YXNoTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BGcm9tU3Rhc2hNYXJrKG1hcmspIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnN0YXNoTWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSkgcmV0dXJuIHRoaXMuc3Rhc2hNYXJrcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5UGVuZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVBlbmRpbmcobmV4dFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtYXJrID0gcGVuZGluZ1tpXTtcblxuICAgICAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJiAhbWFyay5pc0luU2V0KHRoaXMuYWN0aXZlTWFya3MpKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5wZW5kaW5nTWFya3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICBpZiAodGhpcy50eXBlKSByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCkgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVDb250ZXh0O1xufSgpO1xuXG52YXIgUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZUNvbnRleHQocGFyc2VyLCBvcHRpb25zLCBpc09wZW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VDb250ZXh0KTtcblxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pc09wZW4gPSBpc09wZW47XG4gICAgdGhpcy5vcGVuID0gMDtcbiAgICB2YXIgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSxcbiAgICAgICAgdG9wQ29udGV4dDtcbiAgICB2YXIgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihudWxsLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgMCkgfCAoaXNPcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICAgIGlmICh0b3BOb2RlKSB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7ZWxzZSBpZiAoaXNPcGVuKSB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtlbHNlIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhcnNlQ29udGV4dCwgW3tcbiAgICBrZXk6IFwidG9wXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRE9NKGRvbSkge1xuICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICB2YXIgbWFya3MgPSBzdHlsZSA/IHRoaXMucmVhZFN0eWxlcyhwYXJzZVN0eWxlcyhzdHlsZSkpIDogbnVsbCxcbiAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobWFya3MgIT0gbnVsbCkgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsobWFya3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgICAgICBpZiAobWFya3MgIT0gbnVsbCkgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbWFya3MubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFya3NbX2k0XSwgdG9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUZXh0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0Tm9kZShkb20pIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3A7XG5cbiAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMIHx8IHRvcC5pbmxpbmVDb250ZXh0KGRvbSkgfHwgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcblxuICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciBub2RlQmVmb3JlID0gdG9wLmNvbnRlbnRbdG9wLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHwgZG9tTm9kZUJlZm9yZSAmJiBkb21Ob2RlQmVmb3JlLm5vZGVOYW1lID09ICdCUicgfHwgbm9kZUJlZm9yZS5pc1RleHQgJiYgL1sgXFx0XFxyXFxuXFx1MDAwY10kLy50ZXN0KG5vZGVCZWZvcmUudGV4dCkpIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dCh2YWx1ZSkpO1xuICAgICAgICB0aGlzLmZpbmRJblRleHQoZG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVsZW1lbnQoZG9tLCBtYXRjaEFmdGVyKSB7XG4gICAgICB2YXIgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJ1bGVJRDtcbiAgICAgIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cykgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSB8fCAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG5cbiAgICAgIGlmIChydWxlID8gcnVsZS5pZ25vcmUgOiBpZ25vcmVUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gICAgICB9IGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO2Vsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKSBkb20gPSBydWxlLnNraXA7XG4gICAgICAgIHZhciBzeW5jLFxuICAgICAgICAgICAgdG9wID0gdGhpcy50b3AsXG4gICAgICAgICAgICBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuXG4gICAgICAgIGlmIChibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRvcC50eXBlKSB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgaWYgKHN5bmMpIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhZkZhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYWZGYWxsYmFjayhkb20pIHtcbiAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSB0aGlzLmFkZFRleHROb2RlKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlRmFsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlRmFsbGJhY2soZG9tKSB7XG4gICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWRTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgIHZhciBtYXJrcyA9IE1hcmsubm9uZTtcblxuICAgICAgc3R5bGU6IGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGZvciAodmFyIGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUoc3R5bGVzW2ldLCBzdHlsZXNbaSArIDFdLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgaWYgKCFydWxlKSBjb250aW51ZSBzdHlsZTtcbiAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpIHJldHVybiBudWxsO1xuICAgICAgICAgIG1hcmtzID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKSBhZnRlciA9IHJ1bGU7ZWxzZSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEVsZW1lbnRCeVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3luYywgbm9kZVR5cGUsIG1hcms7XG5cbiAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgbm9kZVR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbcnVsZS5ub2RlXTtcblxuICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgIHN5bmMgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFya1R5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXTtcbiAgICAgICAgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKTtcbiAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0SW4gPSB0aGlzLnRvcDtcblxuICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGludWVBZnRlcikge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgICAgIH0gZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRlbnRET00gPSBkb207XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKSBjb250ZW50RE9NID0gZG9tLnF1ZXJ5U2VsZWN0b3IocnVsZS5jb250ZW50RWxlbWVudCk7ZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKSBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO2Vsc2UgaWYgKHJ1bGUuY29udGVudEVsZW1lbnQpIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSkgdGhpcy5vcGVuLS07XG4gICAgICBpZiAobWFyaykgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrLCBzdGFydEluKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFsbChwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgIHRoaXMuYWRkRE9NKGRvbSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRQbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUGxhY2Uobm9kZSkge1xuICAgICAgdmFyIHJvdXRlLCBzeW5jO1xuXG4gICAgICBmb3IgKHZhciBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICB2YXIgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcblxuICAgICAgICB2YXIgX2ZvdW5kMiA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcblxuICAgICAgICBpZiAoX2ZvdW5kMiAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IF9mb3VuZDIubGVuZ3RoKSkge1xuICAgICAgICAgIHJvdXRlID0gX2ZvdW5kMjtcbiAgICAgICAgICBzeW5jID0gY3g7XG4gICAgICAgICAgaWYgKCFfZm91bmQyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3guc29saWQpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnN5bmMoc3luYyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgaWYgKGJsb2NrKSB0aGlzLmVudGVySW5uZXIoYmxvY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5kUGxhY2Uobm9kZSkpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLmFwcGx5UGVuZGluZyhub2RlLnR5cGUpO1xuICAgICAgICBpZiAodG9wLm1hdGNoKSB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgIHZhciBtYXJrcyA9IHRvcC5hY3RpdmVNYXJrcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXRvcC50eXBlIHx8IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG5vZGUubWFya3NbaV0udHlwZSkpIG1hcmtzID0gbm9kZS5tYXJrc1tpXS5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhtYXJrcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlcih0eXBlLCBhdHRycywgcHJlc2VydmVXUykge1xuICAgICAgdmFyIG9rID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgIGlmIChvaykgdGhpcy5lbnRlcklubmVyKHR5cGUsIGF0dHJzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgIHJldHVybiBvaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlcklubmVyKHR5cGUpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciBzb2xpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgcHJlc2VydmVXUyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdTLCB0b3Aub3B0aW9ucyk7XG4gICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKSBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCB0b3AuYWN0aXZlTWFya3MsIHRvcC5wZW5kaW5nTWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICB0aGlzLm9wZW4rKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VFeHRyYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUV4dHJhKCkge1xuICAgICAgdmFyIG9wZW5FbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdmFyIGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLm5vZGVzW2kgLSAxXS5jb250ZW50LnB1c2godGhpcy5ub2Rlc1tpXS5maW5pc2gob3BlbkVuZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmModG8pIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW2ldID09IHRvKSB7XG4gICAgICAgICAgdGhpcy5vcGVuID0gaTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRQb3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuXG4gICAgICAgIGZvciAodmFyIGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSkgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRBdFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICBpZiAodGhpcy5maW5kKSBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5zaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICBpZiAodGhpcy5maW5kKSBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRBcm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRJblRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICB2YXIgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgIHZhciB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgdmFyIG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcblxuICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goaSwgZGVwdGgpIHtcbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGRlcHRoID4gMCB8fCBkZXB0aCA9PSAwICYmIHVzZVJvb3QgPyBfdGhpczQubm9kZXNbZGVwdGhdLnR5cGUgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0Lm5hbWUgIT0gcGFydCAmJiBuZXh0Lmdyb3Vwcy5pbmRleE9mKHBhcnQpID09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRibG9ja0Zyb21Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgdmFyICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICBpZiAoJGNvbnRleHQpIGZvciAodmFyIGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgdmFyIGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycykgcmV0dXJuIGRlZmx0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQZW5kaW5nTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQZW5kaW5nTWFyayhtYXJrKSB7XG4gICAgICB2YXIgZm91bmQgPSBmaW5kU2FtZU1hcmtJblNldChtYXJrLCB0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgICAgaWYgKGZvdW5kKSB0aGlzLnRvcC5zdGFzaE1hcmtzLnB1c2goZm91bmQpO1xuICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVQZW5kaW5nTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQZW5kaW5nTWFyayhtYXJrLCB1cHRvKSB7XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcblxuICAgICAgICB2YXIgX2ZvdW5kMyA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcblxuICAgICAgICBpZiAoX2ZvdW5kMyA+IC0xKSB7XG4gICAgICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgIHZhciBzdGFzaE1hcmsgPSBsZXZlbC5wb3BGcm9tU3Rhc2hNYXJrKG1hcmspO1xuICAgICAgICAgIGlmIChzdGFzaE1hcmsgJiYgbGV2ZWwudHlwZSAmJiBsZXZlbC50eXBlLmFsbG93c01hcmtUeXBlKHN0YXNoTWFyay50eXBlKSkgbGV2ZWwuYWN0aXZlTWFya3MgPSBzdGFzaE1hcmsuYWRkVG9TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsID09IHVwdG8pIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJzZUNvbnRleHQ7XG59KCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gIGZvciAodmFyIGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gIHZhciByZSA9IC9cXHMqKFtcXHctXSspXFxzKjpcXHMqKFteO10rKS9nLFxuICAgICAgbSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpIHtcbiAgICByZXN1bHQucHVzaChtWzFdLCBtWzJdLnRyaW0oKSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICB2YXIgY29weSA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gIHZhciBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcblxuICB2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KG5hbWUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKSByZXR1cm4gXCJjb250aW51ZVwiO1xuXG4gICAgdmFyIHNlZW4gPSBbXSxcbiAgICAgICAgc2NhbiA9IGZ1bmN0aW9uIHNjYW4obWF0Y2gpIHtcbiAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIF9tYXRjaCRlZGdlID0gbWF0Y2guZWRnZShpKSxcbiAgICAgICAgICAgIHR5cGUgPSBfbWF0Y2gkZWRnZS50eXBlLFxuICAgICAgICAgICAgbmV4dCA9IF9tYXRjaCRlZGdlLm5leHQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gbm9kZVR5cGUpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpIHJldHVybiB7XG4gICAgICB2OiB0cnVlXG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciBuYW1lIGluIG5vZGVzKSB7XG4gICAgdmFyIF9yZXQgPSBfbG9vcDQobmFtZSk7XG5cbiAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICBpZiAoX3R5cGVvZihfcmV0KSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU2FtZU1hcmtJblNldChtYXJrLCBzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWFyay5lcShzZXRbaV0pKSByZXR1cm4gc2V0W2ldO1xuICB9XG59XG5cbnZhciBET01TZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBET01TZXJpYWxpemVyKG5vZGVzLCBtYXJrcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBET01TZXJpYWxpemVyKTtcblxuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NU2VyaWFsaXplciwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplRnJhZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciB0b3AgPSB0YXJnZXQsXG4gICAgICAgICAgYWN0aXZlID0gW107XG4gICAgICBmcmFnbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtlZXAgPSAwLFxuICAgICAgICAgICAgICByZW5kZXJlZCA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcblxuICAgICAgICAgICAgaWYgKCFfdGhpczUubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdWzBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKVsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG5cbiAgICAgICAgICAgIHZhciBtYXJrRE9NID0gX3RoaXM1LnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b3AuYXBwZW5kQ2hpbGQoX3RoaXM1LnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZU5vZGVJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIF9ET01TZXJpYWxpemVyJHJlbmRlciA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpKSxcbiAgICAgICAgICBkb20gPSBfRE9NU2VyaWFsaXplciRyZW5kZXIuZG9tLFxuICAgICAgICAgIGNvbnRlbnRET00gPSBfRE9NU2VyaWFsaXplciRyZW5kZXIuY29udGVudERPTTtcblxuICAgICAgaWYgKGNvbnRlbnRET00pIHtcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplTm9kZShub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZW5kZXJTcGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUpIHtcbiAgICAgIHZhciB4bWxOUyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpIHJldHVybiB7XG4gICAgICAgIGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSlcbiAgICAgIH07XG4gICAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpIHJldHVybiB7XG4gICAgICAgIGRvbTogc3RydWN0dXJlXG4gICAgICB9O1xuICAgICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKSByZXR1cm4gc3RydWN0dXJlO1xuICAgICAgdmFyIHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sXG4gICAgICAgICAgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuXG4gICAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50RE9NO1xuICAgICAgdmFyIGRvbSA9IHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgIHZhciBhdHRycyA9IHN0cnVjdHVyZVsxXSxcbiAgICAgICAgICBzdGFydCA9IDE7XG5cbiAgICAgIGlmIChhdHRycyAmJiBfdHlwZW9mKGF0dHJzKSA9PSBcIm9iamVjdFwiICYmIGF0dHJzLm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgIHN0YXJ0ID0gMjtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuXG4gICAgICAgICAgICBpZiAoX3NwYWNlID4gMCkgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgX3NwYWNlKSwgbmFtZS5zbGljZShfc3BhY2UgKyAxKSwgYXR0cnNbbmFtZV0pO2Vsc2UgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IGRvbSxcbiAgICAgICAgICAgIGNvbnRlbnRET006IGRvbVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9ET01TZXJpYWxpemVyJHJlbmRlcjIgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMpLFxuICAgICAgICAgICAgICBpbm5lciA9IF9ET01TZXJpYWxpemVyJHJlbmRlcjIuZG9tLFxuICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBfRE9NU2VyaWFsaXplciRyZW5kZXIyLmNvbnRlbnRET007XG5cbiAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuXG4gICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRET00pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKTtcbiAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogZG9tLFxuICAgICAgICBjb250ZW50RE9NOiBjb250ZW50RE9NXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8IChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVzRnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgICAgIGlmICghcmVzdWx0LnRleHQpIHJlc3VsdC50ZXh0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrc0Zyb21TY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTVNlcmlhbGl6ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICB2YXIgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICBpZiAodG9ET00pIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xufVxuXG5leHBvcnRzLkNvbnRlbnRNYXRjaCA9IENvbnRlbnRNYXRjaDtcbmV4cG9ydHMuRE9NUGFyc2VyID0gRE9NUGFyc2VyO1xuZXhwb3J0cy5ET01TZXJpYWxpemVyID0gRE9NU2VyaWFsaXplcjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTWFyayA9IE1hcms7XG5leHBvcnRzLk1hcmtUeXBlID0gTWFya1R5cGU7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuZXhwb3J0cy5Ob2RlUmFuZ2UgPSBOb2RlUmFuZ2U7XG5leHBvcnRzLk5vZGVUeXBlID0gTm9kZVR5cGU7XG5leHBvcnRzLlJlcGxhY2VFcnJvciA9IFJlcGxhY2VFcnJvcjtcbmV4cG9ydHMuUmVzb2x2ZWRQb3MgPSBSZXNvbHZlZFBvcztcbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuZXhwb3J0cy5TbGljZSA9IFNsaWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yTW9kZWwgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1tb2RlbCcpO1xuXG52YXIgcERPTSA9IFtcInBcIiwgMF0sXG4gICAgYmxvY2txdW90ZURPTSA9IFtcImJsb2NrcXVvdGVcIiwgMF0sXG4gICAgaHJET00gPSBbXCJoclwiXSxcbiAgICBwcmVET00gPSBbXCJwcmVcIiwgW1wiY29kZVwiLCAwXV0sXG4gICAgYnJET00gPSBbXCJiclwiXTtcbnZhciBub2RlcyA9IHtcbiAgZG9jOiB7XG4gICAgY29udGVudDogXCJibG9jaytcIlxuICB9LFxuICBwYXJhZ3JhcGg6IHtcbiAgICBjb250ZW50OiBcImlubGluZSpcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcInBcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBwRE9NO1xuICAgIH1cbiAgfSxcbiAgYmxvY2txdW90ZToge1xuICAgIGNvbnRlbnQ6IFwiYmxvY2srXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZURPTTogW3tcbiAgICAgIHRhZzogXCJibG9ja3F1b3RlXCJcbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICByZXR1cm4gYmxvY2txdW90ZURPTTtcbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWxfcnVsZToge1xuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiaHJcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBockRPTTtcbiAgICB9XG4gIH0sXG4gIGhlYWRpbmc6IHtcbiAgICBhdHRyczoge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiaDFcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGxldmVsOiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdGFnOiBcImgyXCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBsZXZlbDogMlxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJoM1wiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbGV2ZWw6IDNcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0YWc6IFwiaDRcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGxldmVsOiA0XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdGFnOiBcImg1XCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBsZXZlbDogNVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJoNlwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbGV2ZWw6IDZcbiAgICAgIH1cbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00obm9kZSkge1xuICAgICAgcmV0dXJuIFtcImhcIiArIG5vZGUuYXR0cnMubGV2ZWwsIDBdO1xuICAgIH1cbiAgfSxcbiAgY29kZV9ibG9jazoge1xuICAgIGNvbnRlbnQ6IFwidGV4dCpcIixcbiAgICBtYXJrczogXCJcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIGNvZGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwicHJlXCIsXG4gICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6IFwiZnVsbFwiXG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgcmV0dXJuIHByZURPTTtcbiAgICB9XG4gIH0sXG4gIHRleHQ6IHtcbiAgICBncm91cDogXCJpbmxpbmVcIlxuICB9LFxuICBpbWFnZToge1xuICAgIGlubGluZTogdHJ1ZSxcbiAgICBhdHRyczoge1xuICAgICAgc3JjOiB7fSxcbiAgICAgIGFsdDoge1xuICAgICAgICBcImRlZmF1bHRcIjogbnVsbFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiaW1nW3NyY11cIixcbiAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcmM6IGRvbS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksXG4gICAgICAgICAgdGl0bGU6IGRvbS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSxcbiAgICAgICAgICBhbHQ6IGRvbS5nZXRBdHRyaWJ1dGUoXCJhbHRcIilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00obm9kZSkge1xuICAgICAgdmFyIF9ub2RlJGF0dHJzID0gbm9kZS5hdHRycyxcbiAgICAgICAgICBzcmMgPSBfbm9kZSRhdHRycy5zcmMsXG4gICAgICAgICAgYWx0ID0gX25vZGUkYXR0cnMuYWx0LFxuICAgICAgICAgIHRpdGxlID0gX25vZGUkYXR0cnMudGl0bGU7XG4gICAgICByZXR1cm4gW1wiaW1nXCIsIHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIGFsdDogYWx0LFxuICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgIH1dO1xuICAgIH1cbiAgfSxcbiAgaGFyZF9icmVhazoge1xuICAgIGlubGluZTogdHJ1ZSxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBwYXJzZURPTTogW3tcbiAgICAgIHRhZzogXCJiclwiXG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgcmV0dXJuIGJyRE9NO1xuICAgIH1cbiAgfVxufTtcbnZhciBlbURPTSA9IFtcImVtXCIsIDBdLFxuICAgIHN0cm9uZ0RPTSA9IFtcInN0cm9uZ1wiLCAwXSxcbiAgICBjb2RlRE9NID0gW1wiY29kZVwiLCAwXTtcbnZhciBtYXJrcyA9IHtcbiAgbGluazoge1xuICAgIGF0dHJzOiB7XG4gICAgICBocmVmOiB7fSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImFbaHJlZl1cIixcbiAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiBkb20uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICB0aXRsZTogZG9tLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHtcbiAgICAgIHZhciBfbm9kZSRhdHRyczIgPSBub2RlLmF0dHJzLFxuICAgICAgICAgIGhyZWYgPSBfbm9kZSRhdHRyczIuaHJlZixcbiAgICAgICAgICB0aXRsZSA9IF9ub2RlJGF0dHJzMi50aXRsZTtcbiAgICAgIHJldHVybiBbXCJhXCIsIHtcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICB9LCAwXTtcbiAgICB9XG4gIH0sXG4gIGVtOiB7XG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiaVwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcImVtXCJcbiAgICB9LCB7XG4gICAgICBzdHlsZTogXCJmb250LXN0eWxlPWl0YWxpY1wiXG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgcmV0dXJuIGVtRE9NO1xuICAgIH1cbiAgfSxcbiAgc3Ryb25nOiB7XG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwic3Ryb25nXCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwiYlwiLFxuICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPSBcIm5vcm1hbFwiICYmIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc3R5bGU6IFwiZm9udC13ZWlnaHRcIixcbiAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsO1xuICAgICAgfVxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBzdHJvbmdET007XG4gICAgfVxuICB9LFxuICBjb2RlOiB7XG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiY29kZVwiXG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgcmV0dXJuIGNvZGVET007XG4gICAgfVxuICB9XG59O1xudmFyIHNjaGVtYSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNjaGVtYSh7XG4gIG5vZGVzOiBub2RlcyxcbiAgbWFya3M6IG1hcmtzXG59KTtcbmV4cG9ydHMubWFya3MgPSBtYXJrcztcbmV4cG9ydHMubm9kZXMgPSBub2RlcztcbmV4cG9ydHMuc2NoZW1hID0gc2NoZW1hO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgb2xET00gPSBbXCJvbFwiLCAwXSxcbiAgICB1bERPTSA9IFtcInVsXCIsIDBdLFxuICAgIGxpRE9NID0gW1wibGlcIiwgMF07XG52YXIgb3JkZXJlZExpc3QgPSB7XG4gIGF0dHJzOiB7XG4gICAgb3JkZXI6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxXG4gICAgfVxuICB9LFxuICBwYXJzZURPTTogW3tcbiAgICB0YWc6IFwib2xcIixcbiAgICBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDFcbiAgICAgIH07XG4gICAgfVxuICB9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7XG4gICAgICBzdGFydDogbm9kZS5hdHRycy5vcmRlclxuICAgIH0sIDBdO1xuICB9XG59O1xudmFyIGJ1bGxldExpc3QgPSB7XG4gIHBhcnNlRE9NOiBbe1xuICAgIHRhZzogXCJ1bFwiXG4gIH1dLFxuICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgcmV0dXJuIHVsRE9NO1xuICB9XG59O1xudmFyIGxpc3RJdGVtID0ge1xuICBwYXJzZURPTTogW3tcbiAgICB0YWc6IFwibGlcIlxuICB9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgIHJldHVybiBsaURPTTtcbiAgfSxcbiAgZGVmaW5pbmc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGFkZChvYmosIHByb3BzKSB7XG4gIHZhciBjb3B5ID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AgaW4gcHJvcHMpIHtcbiAgICBjb3B5W19wcm9wXSA9IHByb3BzW19wcm9wXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHtcbiAgICAgIGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLFxuICAgICAgZ3JvdXA6IGxpc3RHcm91cFxuICAgIH0pLFxuICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwge1xuICAgICAgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsXG4gICAgICBncm91cDogbGlzdEdyb3VwXG4gICAgfSksXG4gICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHtcbiAgICAgIGNvbnRlbnQ6IGl0ZW1Db250ZW50XG4gICAgfSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbkxpc3QobGlzdFR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24uJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSxcbiAgICAgICAgZG9Kb2luID0gZmFsc2UsXG4gICAgICAgIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgJGluc2VydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICBvdXRlclJhbmdlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KSByYW5nZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLk5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgICBkb0pvaW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB3cmFwID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgIGlmICghd3JhcCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0VHlwZSkge1xuICB2YXIgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICB9XG5cbiAgdHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gIHZhciBmb3VuZCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHdyYXBwZXJzLmxlbmd0aDsgX2krKykge1xuICAgIGlmICh3cmFwcGVyc1tfaV0udHlwZSA9PSBsaXN0VHlwZSkgZm91bmQgPSBfaSArIDE7XG4gIH1cblxuICB2YXIgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICB2YXIgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLFxuICAgICAgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuXG4gIGZvciAodmFyIF9pMiA9IHJhbmdlLnN0YXJ0SW5kZXgsIGUgPSByYW5nZS5lbmRJbmRleCwgZmlyc3QgPSB0cnVlOyBfaTIgPCBlOyBfaTIrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgIGlmICghZmlyc3QgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgIHNwbGl0UG9zICs9IDIgKiBzcGxpdERlcHRoO1xuICAgIH1cblxuICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChfaTIpLm5vZGVTaXplO1xuICB9XG5cbiAgcmV0dXJuIHRyO1xufVxuXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24yID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb24yLiRmcm9tLFxuICAgICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMi4kdG8sXG4gICAgICAgIG5vZGUgPSBfc3RhdGUkc2VsZWN0aW9uMi5ub2RlO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNCbG9jayB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9IGl0ZW1UeXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHwgJGZyb20uaW5kZXgoLTIpICE9ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgd3JhcCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIHZhciBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcblxuICAgICAgICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSkge1xuICAgICAgICAgIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICB2YXIgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG5cbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG5cbiAgICAgICAgdmFyIHNlbCA9IC0xO1xuXG4gICAgICAgIF90ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCBfdHIuZG9jLmNvbnRlbnQuc2l6ZSwgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgICAgIGlmIChzZWwgPiAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmIG5vZGUuY29udGVudC5zaXplID09IDApIHNlbCA9IHBvcyArIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWwgPiAtMSkgX3RyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKF90ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgIGRpc3BhdGNoKF90ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICB2YXIgdHIgPSBzdGF0ZS50cltcImRlbGV0ZVwiXSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgIHZhciB0eXBlcyA9IG5leHRUeXBlID8gW251bGwsIHtcbiAgICAgIHR5cGU6IG5leHRUeXBlXG4gICAgfV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24zID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb24zLiRmcm9tLFxuICAgICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMy4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZTtcbiAgICB9KTtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFkaXNwYXRjaCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSByZXR1cm4gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKTtlbHNlIHJldHVybiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsXG4gICAgICBlbmQgPSByYW5nZS5lbmQsXG4gICAgICBlbmRPZkxpc3QgPSByYW5nZS4kdG8uZW5kKHJhbmdlLmRlcHRoKTtcblxuICBpZiAoZW5kIDwgZW5kT2ZMaXN0KSB7XG4gICAgdHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCByYW5nZS5wYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgcmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICB9XG5cbiAgZGlzcGF0Y2godHIubGlmdChyYW5nZSwgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gIHZhciB0ciA9IHN0YXRlLnRyLFxuICAgICAgbGlzdCA9IHJhbmdlLnBhcmVudDtcblxuICBmb3IgKHZhciBwb3MgPSByYW5nZS5lbmQsIGkgPSByYW5nZS5lbmRJbmRleCAtIDEsIGUgPSByYW5nZS5zdGFydEluZGV4OyBpID4gZTsgaS0tKSB7XG4gICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgdHJbXCJkZWxldGVcIl0ocG9zIC0gMSwgcG9zICsgMSk7XG4gIH1cblxuICB2YXIgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLFxuICAgICAgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gIGlmICh0ci5tYXBwaW5nLm1hcChyYW5nZS5lbmQpICE9IHJhbmdlLnN0YXJ0ICsgJHN0YXJ0Lm5vZGVBZnRlci5ub2RlU2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCxcbiAgICAgIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICB2YXIgcGFyZW50ID0gJHN0YXJ0Lm5vZGUoLTEpLFxuICAgICAgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkgOiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obGlzdCkpKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3RhcnQgPSAkc3RhcnQucG9zLFxuICAgICAgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICB0ci5zdGVwKG5ldyBwcm9zZW1pcnJvclRyYW5zZm9ybS5SZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoKGF0U3RhcnQgPyBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5IDogcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGxpc3QuY29weShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5KSkpLmFwcGVuZChhdEVuZCA/IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkgOiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obGlzdC5jb3B5KHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNpbmtMaXN0SXRlbShpdGVtVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uNCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uNC4kZnJvbSxcbiAgICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjQuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGU7XG4gICAgfSk7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCxcbiAgICAgICAgbm9kZUJlZm9yZSA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSk7XG4gICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgIHZhciBpbm5lciA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgdmFyIGJlZm9yZSA9IHJhbmdlLnN0YXJ0LFxuICAgICAgICAgIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmV4cG9ydHMuYWRkTGlzdE5vZGVzID0gYWRkTGlzdE5vZGVzO1xuZXhwb3J0cy5idWxsZXRMaXN0ID0gYnVsbGV0TGlzdDtcbmV4cG9ydHMubGlmdExpc3RJdGVtID0gbGlmdExpc3RJdGVtO1xuZXhwb3J0cy5saXN0SXRlbSA9IGxpc3RJdGVtO1xuZXhwb3J0cy5vcmRlcmVkTGlzdCA9IG9yZGVyZWRMaXN0O1xuZXhwb3J0cy5zaW5rTGlzdEl0ZW0gPSBzaW5rTGlzdEl0ZW07XG5leHBvcnRzLnNwbGl0TGlzdEl0ZW0gPSBzcGxpdExpc3RJdGVtO1xuZXhwb3J0cy53cmFwSW5MaXN0ID0gd3JhcEluTGlzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbnZhciBjbGFzc2VzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCwgcmFuZ2VzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbik7XG5cbiAgICB0aGlzLiRhbmNob3IgPSAkYW5jaG9yO1xuICAgIHRoaXMuJGhlYWQgPSAkaGVhZDtcbiAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uLCBbe1xuICAgIGtleTogXCJhbmNob3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRhbmNob3IucG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWFkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kaGVhZC5wb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRmcm9tLnBvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0by5wb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIiRmcm9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIiR0b1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiR0bztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1wdHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJhbmdlc1tpXS4kZnJvbS5wb3MgIT0gcmFuZ2VzW2ldLiR0by5wb3MpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodHIpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5O1xuICAgICAgdmFyIGxhc3ROb2RlID0gY29udGVudC5jb250ZW50Lmxhc3RDaGlsZCxcbiAgICAgICAgICBsYXN0UGFyZW50ID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lm9wZW5FbmQ7IGkrKykge1xuICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUubGFzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZXMgPSB0aGlzLnJhbmdlcztcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJhbmdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9yYW5nZXMkX2kgPSByYW5nZXNbX2ldLFxuICAgICAgICAgICAgJGZyb20gPSBfcmFuZ2VzJF9pLiRmcm9tLFxuICAgICAgICAgICAgJHRvID0gX3JhbmdlcyRfaS4kdG8sXG4gICAgICAgICAgICBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBfaSA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgaWYgKF9pID09IDApIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCAobGFzdE5vZGUgPyBsYXN0Tm9kZS5pc0lubGluZSA6IGxhc3RQYXJlbnQgJiYgbGFzdFBhcmVudC5pc1RleHRibG9jaykgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuICAgICAgdmFyIG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcmFuZ2VzJGkgPSByYW5nZXNbaV0sXG4gICAgICAgICAgICAkZnJvbSA9IF9yYW5nZXMkaS4kZnJvbSxcbiAgICAgICAgICAgICR0byA9IF9yYW5nZXMkaS4kdG8sXG4gICAgICAgICAgICBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLFxuICAgICAgICAgICAgdG8gPSBtYXBwaW5nLm1hcCgkdG8ucG9zKTtcblxuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgbm9kZS5pc0lubGluZSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKHRoaXMuJGFuY2hvciwgdGhpcy4kaGVhZCkuZ2V0Qm9va21hcmsoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmaW5kRnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRnJvbSgkcG9zLCBkaXIpIHtcbiAgICAgIHZhciB0ZXh0T25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgaW5uZXIgPSAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50ID8gbmV3IFRleHRTZWxlY3Rpb24oJHBvcykgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICBpZiAoaW5uZXIpIHJldHVybiBpbm5lcjtcblxuICAgICAgZm9yICh2YXIgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICB2YXIgZm91bmQgPSBkaXIgPCAwID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5hZnRlcihkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSArIDEsIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcigkcG9zKSB7XG4gICAgICB2YXIgYmlhcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXRTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdFN0YXJ0KGRvYykge1xuICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgMCwgMCwgMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdEVuZChkb2MpIHtcbiAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIGRvYy5jb250ZW50LnNpemUsIGRvYy5jaGlsZENvdW50LCAtMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgIGlmICghanNvbiB8fCAhanNvbi50eXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzQnlJZFtqc29uLnR5cGVdO1xuICAgICAgaWYgKCFjbHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gc2VsZWN0aW9uIHR5cGUgXCIuY29uY2F0KGpzb24udHlwZSwgXCIgZGVmaW5lZFwiKSk7XG4gICAgICByZXR1cm4gY2xzLmZyb21KU09OKGRvYywganNvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpzb25JRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICBpZiAoaWQgaW4gY2xhc3Nlc0J5SWQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgIGNsYXNzZXNCeUlkW2lkXSA9IHNlbGVjdGlvbkNsYXNzO1xuICAgICAgc2VsZWN0aW9uQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb247XG59KCk7XG5cblNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IHRydWU7XG5cbnZhciBTZWxlY3Rpb25SYW5nZSA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBTZWxlY3Rpb25SYW5nZSgkZnJvbSwgJHRvKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb25SYW5nZSk7XG5cbiAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICB0aGlzLiR0byA9ICR0bztcbn0pO1xuXG52YXIgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrVGV4dFNlbGVjdGlvbigkcG9zKSB7XG4gIGlmICghd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uICYmICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICB9XG59XG5cbnZhciBUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKF9TZWxlY3Rpb24pIHtcbiAgX2luaGVyaXRzKFRleHRTZWxlY3Rpb24sIF9TZWxlY3Rpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dFNlbGVjdGlvbik7XG5cbiAgZnVuY3Rpb24gVGV4dFNlbGVjdGlvbigkYW5jaG9yKSB7XG4gICAgdmFyICRoZWFkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAkYW5jaG9yO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRTZWxlY3Rpb24pO1xuXG4gICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRhbmNob3IpO1xuICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICRhbmNob3IsICRoZWFkKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0U2VsZWN0aW9uLCBbe1xuICAgIGtleTogXCIkY3Vyc29yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyA9PSB0aGlzLiRoZWFkLnBvcyA/IHRoaXMuJGhlYWQgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgdmFyICRoZWFkID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQpO1xuICAgICAgdmFyICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQgPyAkYW5jaG9yIDogJGhlYWQsICRoZWFkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRyKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUpLCBcInJlcGxhY2VcIiwgdGhpcykuY2FsbCh0aGlzLCB0ciwgY29udGVudCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgdmFyIG1hcmtzID0gdGhpcy4kZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLiR0byk7XG4gICAgICAgIGlmIChtYXJrcykgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvb2ttYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvb2ttYXJrKCkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsodGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvcixcbiAgICAgICAgaGVhZDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoZG9jLCBhbmNob3IpIHtcbiAgICAgIHZhciBoZWFkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhbmNob3I7XG4gICAgICB2YXIgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoJGFuY2hvciwgaGVhZCA9PSBhbmNob3IgPyAkYW5jaG9yIDogZG9jLnJlc29sdmUoaGVhZCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICAgIHZhciBkUG9zID0gJGFuY2hvci5wb3MgLSAkaGVhZC5wb3M7XG4gICAgICBpZiAoIWJpYXMgfHwgZFBvcykgYmlhcyA9IGRQb3MgPj0gMCA/IDEgOiAtMTtcblxuICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB2YXIgZm91bmQgPSBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIGJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgLWJpYXMsIHRydWUpO1xuICAgICAgICBpZiAoZm91bmQpICRoZWFkID0gZm91bmQuJGhlYWQ7ZWxzZSByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5jaG9yID0gKFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCAtYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIGJpYXMsIHRydWUpKS4kYW5jaG9yO1xuICAgICAgICAgIGlmICgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcyAhPSBkUG9zIDwgMCkgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb247XG59KFNlbGVjdGlvbik7XG5cblNlbGVjdGlvbi5qc29uSUQoXCJ0ZXh0XCIsIFRleHRTZWxlY3Rpb24pO1xuXG52YXIgVGV4dEJvb2ttYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZXh0Qm9va21hcmsoYW5jaG9yLCBoZWFkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRCb29rbWFyayk7XG5cbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHRCb29rbWFyaywgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jKSB7XG4gICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgZG9jLnJlc29sdmUodGhpcy5oZWFkKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRCb29rbWFyaztcbn0oKTtcblxudmFyIE5vZGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoX1NlbGVjdGlvbjIpIHtcbiAgX2luaGVyaXRzKE5vZGVTZWxlY3Rpb24sIF9TZWxlY3Rpb24yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihOb2RlU2VsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBOb2RlU2VsZWN0aW9uKCRwb3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVNlbGVjdGlvbik7XG5cbiAgICB2YXIgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIHZhciAkZW5kID0gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICBfdGhpcyA9IF9zdXBlcjIuY2FsbCh0aGlzLCAkcG9zLCAkZW5kKTtcbiAgICBfdGhpcy5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVNlbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgIHZhciBfbWFwcGluZyRtYXBSZXN1bHQgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvciksXG4gICAgICAgICAgZGVsZXRlZCA9IF9tYXBwaW5nJG1hcFJlc3VsdC5kZWxldGVkLFxuICAgICAgICAgIHBvcyA9IF9tYXBwaW5nJG1hcFJlc3VsdC5wb3M7XG5cbiAgICAgIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICAgIGlmIChkZWxldGVkKSByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICBhbmNob3I6IHRoaXMuYW5jaG9yXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb29rbWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb29rbWFyaygpIHtcbiAgICAgIHJldHVybiBuZXcgTm9kZUJvb2ttYXJrKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoZG9jLCBmcm9tKSB7XG4gICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoZnJvbSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1NlbGVjdGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgIHJldHVybiAhbm9kZS5pc1RleHQgJiYgbm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVTZWxlY3Rpb247XG59KFNlbGVjdGlvbik7XG5cbk5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblNlbGVjdGlvbi5qc29uSUQoXCJub2RlXCIsIE5vZGVTZWxlY3Rpb24pO1xuXG52YXIgTm9kZUJvb2ttYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlQm9va21hcmsoYW5jaG9yKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVCb29rbWFyayk7XG5cbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlQm9va21hcmssIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIF9tYXBwaW5nJG1hcFJlc3VsdDIgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvciksXG4gICAgICAgICAgZGVsZXRlZCA9IF9tYXBwaW5nJG1hcFJlc3VsdDIuZGVsZXRlZCxcbiAgICAgICAgICBwb3MgPSBfbWFwcGluZyRtYXBSZXN1bHQyLnBvcztcblxuICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGRvYykge1xuICAgICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksXG4gICAgICAgICAgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZUJvb2ttYXJrO1xufSgpO1xuXG52YXIgQWxsU2VsZWN0aW9uID0gZnVuY3Rpb24gKF9TZWxlY3Rpb24zKSB7XG4gIF9pbmhlcml0cyhBbGxTZWxlY3Rpb24sIF9TZWxlY3Rpb24zKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihBbGxTZWxlY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIEFsbFNlbGVjdGlvbihkb2MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxsU2VsZWN0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmNhbGwodGhpcywgZG9jLnJlc29sdmUoMCksIGRvYy5yZXNvbHZlKGRvYy5jb250ZW50LnNpemUpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbGxTZWxlY3Rpb24sIFt7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0cikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHk7XG5cbiAgICAgIGlmIChjb250ZW50ID09IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgdHJbXCJkZWxldGVcIl0oMCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgIHZhciBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICBpZiAoIXNlbC5lcSh0ci5zZWxlY3Rpb24pKSB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEFsbFNlbGVjdGlvbi5wcm90b3R5cGUpLCBcInJlcGxhY2VcIiwgdGhpcykuY2FsbCh0aGlzLCB0ciwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFsbFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGRvYykge1xuICAgICAgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gQWxsQm9va21hcms7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZG9jKSB7XG4gICAgICByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbGxTZWxlY3Rpb247XG59KFNlbGVjdGlvbik7XG5cblNlbGVjdGlvbi5qc29uSUQoXCJhbGxcIiwgQWxsU2VsZWN0aW9uKTtcbnZhciBBbGxCb29rbWFyayA9IHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jKSB7XG4gICAgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZFNlbGVjdGlvbkluKGRvYywgbm9kZSwgcG9zLCBpbmRleCwgZGlyKSB7XG4gIHZhciB0ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgaWYgKG5vZGUuaW5saW5lQ29udGVudCkgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zKTtcblxuICBmb3IgKHZhciBpID0gaW5kZXggLSAoZGlyID4gMCA/IDAgOiAxKTsgZGlyID4gMCA/IGkgPCBub2RlLmNoaWxkQ291bnQgOiBpID49IDA7IGkgKz0gZGlyKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZChpKTtcblxuICAgIGlmICghY2hpbGQuaXNBdG9tKSB7XG4gICAgICB2YXIgaW5uZXIgPSBmaW5kU2VsZWN0aW9uSW4oZG9jLCBjaGlsZCwgcG9zICsgZGlyLCBkaXIgPCAwID8gY2hpbGQuY2hpbGRDb3VudCA6IDAsIGRpciwgdGV4dCk7XG4gICAgICBpZiAoaW5uZXIpIHJldHVybiBpbm5lcjtcbiAgICB9IGVsc2UgaWYgKCF0ZXh0ICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zIC0gKGRpciA8IDAgPyBjaGlsZC5ub2RlU2l6ZSA6IDApKTtcbiAgICB9XG5cbiAgICBwb3MgKz0gY2hpbGQubm9kZVNpemUgKiBkaXI7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gIHZhciBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPCBzdGFydExlbikgcmV0dXJuO1xuICB2YXIgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKSkgcmV0dXJuO1xuICB2YXIgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdLFxuICAgICAgZW5kO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSBlbmQgPSBuZXdUbztcbiAgfSk7XG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbnZhciBVUERBVEVEX1NFTCA9IDEsXG4gICAgVVBEQVRFRF9NQVJLUyA9IDIsXG4gICAgVVBEQVRFRF9TQ1JPTEwgPSA0O1xuXG52YXIgVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoX3Byb3NlbWlycm9yVHJhbnNmb3JtKSB7XG4gIF9pbmhlcml0cyhUcmFuc2FjdGlvbiwgX3Byb3NlbWlycm9yVHJhbnNmb3JtKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihUcmFuc2FjdGlvbik7XG5cbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uKTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjQuY2FsbCh0aGlzLCBzdGF0ZS5kb2MpO1xuICAgIF90aGlzMi5jdXJTZWxlY3Rpb25Gb3IgPSAwO1xuICAgIF90aGlzMi51cGRhdGVkID0gMDtcbiAgICBfdGhpczIubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX3RoaXMyLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIF90aGlzMi5jdXJTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgX3RoaXMyLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbiwgW3tcbiAgICBrZXk6IFwic2VsZWN0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5jdXJTZWxlY3Rpb25Gb3IgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHRoaXMuY3VyU2VsZWN0aW9uLm1hcCh0aGlzLmRvYywgdGhpcy5tYXBwaW5nLnNsaWNlKHRoaXMuY3VyU2VsZWN0aW9uRm9yKSk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmN1clNlbGVjdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20uZG9jICE9IHRoaXMuZG9jKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwYXNzZWQgdG8gc2V0U2VsZWN0aW9uIG11c3QgcG9pbnQgYXQgdGhlIGN1cnJlbnQgZG9jdW1lbnRcIik7XG4gICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICB0aGlzLnVwZGF0ZWQgPSAodGhpcy51cGRhdGVkIHwgVVBEQVRFRF9TRUwpICYgflVQREFURURfTUFSS1M7XG4gICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25TZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TRUwpID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3RvcmVkTWFya3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBtYXJrcztcbiAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX01BUktTO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZU1hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZU1hcmtzKG1hcmtzKSB7XG4gICAgICBpZiAoIXByb3NlbWlycm9yTW9kZWwuTWFyay5zYW1lU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSwgbWFya3MpKSB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTdG9yZWRNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0b3JlZE1hcmsobWFyaykge1xuICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlU3RvcmVkTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcmVkTWFya3NTZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9NQVJLUykgPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUcmFuc2FjdGlvbi5wcm90b3R5cGUpLCBcImFkZFN0ZXBcIiwgdGhpcykuY2FsbCh0aGlzLCBzdGVwLCBkb2MpO1xuXG4gICAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRpbWUodGltZSkge1xuICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VTZWxlY3Rpb25XaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUpIHtcbiAgICAgIHZhciBpbmhlcml0TWFya3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICBpZiAoaW5oZXJpdE1hcmtzKSBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogc2VsZWN0aW9uLiRmcm9tLm1hcmtzQWNyb3NzKHNlbGVjdGlvbi4kdG8pIHx8IHByb3NlbWlycm9yTW9kZWwuTWFyay5ub25lKSk7XG4gICAgICBzZWxlY3Rpb24ucmVwbGFjZVdpdGgodGhpcywgbm9kZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5kb2MudHlwZS5zY2hlbWE7XG5cbiAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgaWYgKCF0ZXh0KSByZXR1cm4gdGhpcy5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpIHRvID0gZnJvbTtcbiAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICBpZiAoIXRleHQpIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgdmFyIG1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcztcblxuICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgdmFyICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmVtcHR5KSB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1ldGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWV0YShrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGEoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0dlbmVyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGZvciAodmFyIF8gaW4gdGhpcy5tZXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbEludG9WaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfU0NST0xMO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbGVkSW50b1ZpZXdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNhY3Rpb247XG59KHByb3NlbWlycm9yVHJhbnNmb3JtLlRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICByZXR1cm4gIXNlbGYgfHwgIWYgPyBmIDogZi5iaW5kKHNlbGYpO1xufVxuXG52YXIgRmllbGREZXNjID0gX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIEZpZWxkRGVzYyhuYW1lLCBkZXNjLCBzZWxmKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWVsZERlc2MpO1xuXG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuaW5pdCA9IGJpbmQoZGVzYy5pbml0LCBzZWxmKTtcbiAgdGhpcy5hcHBseSA9IGJpbmQoZGVzYy5hcHBseSwgc2VsZik7XG59KTtcblxudmFyIGJhc2VGaWVsZHMgPSBbbmV3IEZpZWxkRGVzYyhcImRvY1wiLCB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5kb2MgfHwgY29uZmlnLnNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0cikge1xuICAgIHJldHVybiB0ci5kb2M7XG4gIH1cbn0pLCBuZXcgRmllbGREZXNjKFwic2VsZWN0aW9uXCIsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcsIGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyKSB7XG4gICAgcmV0dXJuIHRyLnNlbGVjdGlvbjtcbiAgfVxufSksIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5zdG9yZWRNYXJrcyB8fCBudWxsO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3IgPyB0ci5zdG9yZWRNYXJrcyA6IG51bGw7XG4gIH1cbn0pLCBuZXcgRmllbGREZXNjKFwic2Nyb2xsVG9TZWxlY3Rpb25cIiwge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgIHJldHVybiAwO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIsIHByZXYpIHtcbiAgICByZXR1cm4gdHIuc2Nyb2xsZWRJbnRvVmlldyA/IHByZXYgKyAxIDogcHJldjtcbiAgfVxufSldO1xuXG52YXIgQ29uZmlndXJhdGlvbiA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBDb25maWd1cmF0aW9uKHNjaGVtYSwgcGx1Z2lucykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdGlvbik7XG5cbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICB0aGlzLnBsdWdpbnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuZmllbGRzID0gYmFzZUZpZWxkcy5zbGljZSgpO1xuICBpZiAocGx1Z2lucykgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoX3RoaXMzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBZGRpbmcgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIGtleWVkIHBsdWdpbiAoXCIgKyBwbHVnaW4ua2V5ICsgXCIpXCIpO1xuXG4gICAgX3RoaXMzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuXG4gICAgX3RoaXMzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSA9IHBsdWdpbjtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUpIF90aGlzMy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgfSk7XG59KTtcblxudmFyIEVkaXRvclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFZGl0b3JTdGF0ZShjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRpdG9yU3RhdGUpO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWRpdG9yU3RhdGUsIFt7XG4gICAga2V5OiBcInNjaGVtYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGx1Z2luc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyVHJhbnNhY3Rpb24odHIpIHtcbiAgICAgIHZhciBpZ25vcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC0xO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaWdub3JlKSB7XG4gICAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uICYmICFwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgdHIsIHRoaXMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgIGlmICghdGhpcy5maWx0ZXJUcmFuc2FjdGlvbihyb290VHIpKSByZXR1cm4ge1xuICAgICAgICBzdGF0ZTogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciB0cnMgPSBbcm9vdFRyXSxcbiAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuYXBwbHlJbm5lcihyb290VHIpLFxuICAgICAgICAgIHNlZW4gPSBudWxsO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBoYXZlTmV3ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG5cbiAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBuID0gc2VlbiA/IHNlZW5baV0ubiA6IDAsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPSBzZWVuID8gc2VlbltpXS5zdGF0ZSA6IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHIgPSBuIDwgdHJzLmxlbmd0aCAmJiBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgbiA/IHRycy5zbGljZShuKSA6IHRycywgb2xkU3RhdGUsIG5ld1N0YXRlKTtcblxuICAgICAgICAgICAgaWYgKHRyICYmIG5ld1N0YXRlLmZpbHRlclRyYW5zYWN0aW9uKHRyLCBpKSkge1xuICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuXG4gICAgICAgICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgICAgIHNlZW4gPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIG46IHRycy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBuOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUuYXBwbHlJbm5lcih0cik7XG4gICAgICAgICAgICAgIGhhdmVOZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Vlbikgc2VlbltpXSA9IHtcbiAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICBuOiB0cnMubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGF2ZU5ldykgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgdHJhbnNhY3Rpb25zOiB0cnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUlubmVyKHRyKSB7XG4gICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgYSBtaXNtYXRjaGVkIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgdmFyIG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSxcbiAgICAgICAgICBmaWVsZHMgPSB0aGlzLmNvbmZpZy5maWVsZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNvbmZpZ3VyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgIHZhciBmaWVsZHMgPSAkY29uZmlnLmZpZWxkcyxcbiAgICAgICAgICBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWVsZHNbaV0ubmFtZTtcbiAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB0aGlzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpc1tuYW1lXSA6IGZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBkb2M6IHRoaXMuZG9jLnRvSlNPTigpLFxuICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpIHJlc3VsdC5zdG9yZWRNYXJrcyA9IHRoaXMuc3RvcmVkTWFya3MubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnRvSlNPTigpO1xuICAgICAgfSk7XG4gICAgICBpZiAocGx1Z2luRmllbGRzICYmIF90eXBlb2YocGx1Z2luRmllbGRzKSA9PSAnb2JqZWN0JykgZm9yICh2YXIgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgaWYgKHByb3AgPT0gXCJkb2NcIiB8fCBwcm9wID09IFwic2VsZWN0aW9uXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIEpTT04gZmllbGRzIGBkb2NgIGFuZCBgc2VsZWN0aW9uYCBhcmUgcmVzZXJ2ZWRcIik7XG4gICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sXG4gICAgICAgICAgICBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9KU09OKSByZXN1bHRbcHJvcF0gPSBzdGF0ZS50b0pTT04uY2FsbChwbHVnaW4sIHRoaXNbcGx1Z2luLmtleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKGNvbmZpZykge1xuICAgICAgdmFyICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkY29uZmlnLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnN0YW5jZVskY29uZmlnLmZpZWxkc1tpXS5uYW1lXSA9ICRjb25maWcuZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oY29uZmlnLCBqc29uLCBwbHVnaW5GaWVsZHMpIHtcbiAgICAgIGlmICghanNvbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBFZGl0b3JTdGF0ZS5mcm9tSlNPTlwiKTtcbiAgICAgIGlmICghY29uZmlnLnNjaGVtYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXF1aXJlZCBjb25maWcgZmllbGQgJ3NjaGVtYScgbWlzc2luZ1wiKTtcbiAgICAgIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgJGNvbmZpZy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgIGluc3RhbmNlLmRvYyA9IHByb3NlbWlycm9yTW9kZWwuTm9kZS5mcm9tSlNPTihjb25maWcuc2NoZW1hLCBqc29uLmRvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzdG9yZWRNYXJrc1wiKSB7XG4gICAgICAgICAgaWYgKGpzb24uc3RvcmVkTWFya3MpIGluc3RhbmNlLnN0b3JlZE1hcmtzID0ganNvbi5zdG9yZWRNYXJrcy5tYXAoY29uZmlnLnNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwbHVnaW5GaWVsZHMpIGZvciAodmFyIHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gc3RhdGUuZnJvbUpTT04uY2FsbChwbHVnaW4sIGNvbmZpZywganNvbltwcm9wXSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkaXRvclN0YXRlO1xufSgpO1xuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICB2YXIgdmFsID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbikgdmFsID0gdmFsLmJpbmQoc2VsZik7ZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKSB2YWwgPSBiaW5kUHJvcHModmFsLCBzZWxmLCB7fSk7XG4gICAgdGFyZ2V0W3Byb3BdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luKHNwZWMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcblxuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIGlmIChzcGVjLnByb3BzKSBiaW5kUHJvcHMoc3BlYy5wcm9wcywgdGhpcywgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbHVnaW4sIFt7XG4gICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGVbdGhpcy5rZXldO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbHVnaW47XG59KCk7XG5cbnZhciBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gY3JlYXRlS2V5KG5hbWUpIHtcbiAgaWYgKG5hbWUgaW4ga2V5cykgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAga2V5c1tuYW1lXSA9IDA7XG4gIHJldHVybiBuYW1lICsgXCIkXCI7XG59XG5cbnZhciBQbHVnaW5LZXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbktleSgpIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJrZXlcIjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW5LZXkpO1xuXG4gICAgdGhpcy5rZXkgPSBjcmVhdGVLZXkobmFtZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGx1Z2luS2V5LCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGVbdGhpcy5rZXldO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbHVnaW5LZXk7XG59KCk7XG5cbmV4cG9ydHMuQWxsU2VsZWN0aW9uID0gQWxsU2VsZWN0aW9uO1xuZXhwb3J0cy5FZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlO1xuZXhwb3J0cy5Ob2RlU2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjtcbmV4cG9ydHMuUGx1Z2luID0gUGx1Z2luO1xuZXhwb3J0cy5QbHVnaW5LZXkgPSBQbHVnaW5LZXk7XG5leHBvcnRzLlNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcbmV4cG9ydHMuU2VsZWN0aW9uUmFuZ2UgPSBTZWxlY3Rpb25SYW5nZTtcbmV4cG9ydHMuVGV4dFNlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb247XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yTW9kZWwgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1tb2RlbCcpO1xuXG52YXIgbG93ZXIxNiA9IDB4ZmZmZjtcbnZhciBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcblxuZnVuY3Rpb24gbWFrZVJlY292ZXIoaW5kZXgsIG9mZnNldCkge1xuICByZXR1cm4gaW5kZXggKyBvZmZzZXQgKiBmYWN0b3IxNjtcbn1cblxuZnVuY3Rpb24gcmVjb3ZlckluZGV4KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmIGxvd2VyMTY7XG59XG5cbmZ1bmN0aW9uIHJlY292ZXJPZmZzZXQodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAtICh2YWx1ZSAmIGxvd2VyMTYpKSAvIGZhY3RvcjE2O1xufVxuXG52YXIgREVMX0JFRk9SRSA9IDEsXG4gICAgREVMX0FGVEVSID0gMixcbiAgICBERUxfQUNST1NTID0gNCxcbiAgICBERUxfU0lERSA9IDg7XG5cbnZhciBNYXBSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIHJlY292ZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwUmVzdWx0KTtcblxuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuZGVsSW5mbyA9IGRlbEluZm87XG4gICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBSZXN1bHQsIFt7XG4gICAga2V5OiBcImRlbGV0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlZEJlZm9yZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0JFRk9SRSB8IERFTF9BQ1JPU1MpKSA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZWRBZnRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlZEFjcm9zc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfQUNST1NTKSA+IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcFJlc3VsdDtcbn0oKTtcblxudmFyIFN0ZXBNYXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXBNYXAocmFuZ2VzKSB7XG4gICAgdmFyIGludmVydGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwTWFwKTtcblxuICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSkgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RlcE1hcCwgW3tcbiAgICBrZXk6IFwicmVjb3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyKHZhbHVlKSB7XG4gICAgICB2YXIgZGlmZiA9IDAsXG4gICAgICAgICAgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgaWYgKCF0aGlzLmludmVydGVkKSBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBSZXN1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwUmVzdWx0KHBvcykge1xuICAgICAgdmFyIGFzc29jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAocG9zKSB7XG4gICAgICB2YXIgYXNzb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICB2YXIgZGlmZiA9IDAsXG4gICAgICAgICAgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsXG4gICAgICAgICAgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSBicmVhaztcbiAgICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLFxuICAgICAgICAgICAgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIG9sZFNpemU7XG5cbiAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICB2YXIgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICBpZiAoc2ltcGxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHZhciByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKSBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b3VjaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICB2YXIgZGlmZiA9IDAsXG4gICAgICAgICAgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsXG4gICAgICAgICAgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSBicmVhaztcbiAgICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLFxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMykgcmV0dXJuIHRydWU7XG4gICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSAtIG9sZFNpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSxcbiAgICAgICAgICBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sXG4gICAgICAgICAgICBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksXG4gICAgICAgICAgICBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSxcbiAgICAgICAgICAgIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0KG4pIHtcbiAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RlcE1hcDtcbn0oKTtcblxuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcblxudmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gICAgdmFyIG1hcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHZhciBtaXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG1hcHMubGVuZ3RoO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcHBpbmcpO1xuXG4gICAgdGhpcy5tYXBzID0gbWFwcztcbiAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBwaW5nLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZSgpIHtcbiAgICAgIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1hcHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICBpZiAobWlycm9ycyAhPSBudWxsKSB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZE1hcHBpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWlycm9yKG4pIHtcbiAgICAgIGlmICh0aGlzLm1pcnJvcikgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1pcnJvci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5taXJyb3JbaV0gPT0gbikgcmV0dXJuIHRoaXMubWlycm9yW2kgKyAoaSAlIDIgPyAtMSA6IDEpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWlycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICBpZiAoIXRoaXMubWlycm9yKSB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgdGhpcy5taXJyb3IucHVzaChuLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kTWFwcGluZ0ludmVydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0uaW52ZXJ0KCksIG1pcnIgIT0gbnVsbCAmJiBtaXJyID4gaSA/IHRvdGFsU2l6ZSAtIG1pcnIgLSAxIDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgIHZhciBpbnZlcnNlID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgIGludmVyc2UuYXBwZW5kTWFwcGluZ0ludmVydGVkKHRoaXMpO1xuICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAocG9zKSB7XG4gICAgICB2YXIgYXNzb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICBpZiAodGhpcy5taXJyb3IpIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFJlc3VsdChwb3MpIHtcbiAgICAgIHZhciBhc3NvYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICB2YXIgZGVsSW5mbyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwc1tpXSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuXG4gICAgICAgICAgaWYgKGNvcnIgIT0gbnVsbCAmJiBjb3JyID4gaSAmJiBjb3JyIDwgdGhpcy50bykge1xuICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxJbmZvIHw9IHJlc3VsdC5kZWxJbmZvO1xuICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2ltcGxlID8gcG9zIDogbmV3IE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBwaW5nO1xufSgpO1xuXG52YXIgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIFN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZXApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0ZXAsIFt7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICB2YXIgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgIGlmICghdHlwZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBzdGVwIHR5cGUgXCIuY29uY2F0KGpzb24uc3RlcFR5cGUsIFwiIGRlZmluZWRcIikpO1xuICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvbklEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgIHN0ZXBDbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGVwO1xufSgpO1xuXG52YXIgU3RlcFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RlcFJlc3VsdChkb2MsIGZhaWxlZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwUmVzdWx0KTtcblxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuZmFpbGVkID0gZmFpbGVkO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0ZXBSZXN1bHQsIG51bGwsIFt7XG4gICAga2V5OiBcIm9rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9rKGRvYykge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21SZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SZXBsYWNlKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBwcm9zZW1pcnJvck1vZGVsLlJlcGxhY2VFcnJvcikgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGVwUmVzdWx0O1xufSgpO1xuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gIHZhciBtYXBwZWQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpIGNoaWxkID0gY2hpbGQuY29weShtYXBGcmFnbWVudChjaGlsZC5jb250ZW50LCBmLCBjaGlsZCkpO1xuICAgIGlmIChjaGlsZC5pc0lubGluZSkgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgIG1hcHBlZC5wdXNoKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb21BcnJheShtYXBwZWQpO1xufVxuXG52YXIgQWRkTWFya1N0ZXAgPSBmdW5jdGlvbiAoX1N0ZXApIHtcbiAgX2luaGVyaXRzKEFkZE1hcmtTdGVwLCBfU3RlcCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBZGRNYXJrU3RlcCk7XG5cbiAgZnVuY3Rpb24gQWRkTWFya1N0ZXAoZnJvbSwgdG8sIG1hcmspIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWRkTWFya1N0ZXApO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5mcm9tID0gZnJvbTtcbiAgICBfdGhpcy50byA9IHRvO1xuICAgIF90aGlzLm1hcmsgPSBtYXJrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBZGRNYXJrU3RlcCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoZG9jKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksXG4gICAgICAgICAgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgdmFyIHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShfdGhpczIubWFyay50eXBlKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlLm1hcmsoX3RoaXMyLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgfSwgcGFyZW50KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nKSB7XG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksXG4gICAgICAgICAgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEFkZE1hcmtTdGVwICYmIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJiB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKSByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RlcFR5cGU6IFwiYWRkTWFya1wiLFxuICAgICAgICBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgdG86IHRoaXMudG9cbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWRkTWFya1N0ZXA7XG59KFN0ZXApO1xuXG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xuXG52YXIgUmVtb3ZlTWFya1N0ZXAgPSBmdW5jdGlvbiAoX1N0ZXAyKSB7XG4gIF9pbmhlcml0cyhSZW1vdmVNYXJrU3RlcCwgX1N0ZXAyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihSZW1vdmVNYXJrU3RlcCk7XG5cbiAgZnVuY3Rpb24gUmVtb3ZlTWFya1N0ZXAoZnJvbSwgdG8sIG1hcmspIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbW92ZU1hcmtTdGVwKTtcblxuICAgIF90aGlzMyA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczMuZnJvbSA9IGZyb207XG4gICAgX3RoaXMzLnRvID0gdG87XG4gICAgX3RoaXMzLm1hcmsgPSBtYXJrO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVtb3ZlTWFya1N0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubWFyayhfdGhpczQubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLFxuICAgICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJiBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiYgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSkgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIixcbiAgICAgICAgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbW92ZU1hcmtTdGVwO1xufShTdGVwKTtcblxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcblxudmFyIFJlcGxhY2VTdGVwID0gZnVuY3Rpb24gKF9TdGVwMykge1xuICBfaW5oZXJpdHMoUmVwbGFjZVN0ZXAsIF9TdGVwMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoUmVwbGFjZVN0ZXApO1xuXG4gIGZ1bmN0aW9uIFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICB2YXIgc3RydWN0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXBsYWNlU3RlcCk7XG5cbiAgICBfdGhpczUgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1LmZyb20gPSBmcm9tO1xuICAgIF90aGlzNS50byA9IHRvO1xuICAgIF90aGlzNS5zbGljZSA9IHNsaWNlO1xuICAgIF90aGlzNS5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXBsYWNlU3RlcCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoZG9jKSB7XG4gICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKSByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIHJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy50byAtIHRoaXMuZnJvbSwgdGhpcy5zbGljZS5zaXplXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoZG9jKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLFxuICAgICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSA6IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICB2YXIgX3NsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSA6IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIF9zbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIganNvbiA9IHtcbiAgICAgICAgc3RlcFR5cGU6IFwicmVwbGFjZVwiLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSkganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlcGxhY2VTdGVwO1xufShTdGVwKTtcblxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcblxudmFyIFJlcGxhY2VBcm91bmRTdGVwID0gZnVuY3Rpb24gKF9TdGVwNCkge1xuICBfaW5oZXJpdHMoUmVwbGFjZUFyb3VuZFN0ZXAsIF9TdGVwNCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoUmVwbGFjZUFyb3VuZFN0ZXApO1xuXG4gIGZ1bmN0aW9uIFJlcGxhY2VBcm91bmRTdGVwKGZyb20sIHRvLCBnYXBGcm9tLCBnYXBUbywgc2xpY2UsIGluc2VydCkge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICB2YXIgc3RydWN0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5cbiAgICBfdGhpczYgPSBfc3VwZXI0LmNhbGwodGhpcyk7XG4gICAgX3RoaXM2LmZyb20gPSBmcm9tO1xuICAgIF90aGlzNi50byA9IHRvO1xuICAgIF90aGlzNi5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICBfdGhpczYuZ2FwVG8gPSBnYXBUbztcbiAgICBfdGhpczYuc2xpY2UgPSBzbGljZTtcbiAgICBfdGhpczYuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIF90aGlzNi5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXBsYWNlQXJvdW5kU3RlcCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoZG9jKSB7XG4gICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8IGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKSByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIGdhcC1yZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgdmFyIGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgIHZhciBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgIGlmICghaW5zZXJ0ZWQpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KGRvYykge1xuICAgICAgdmFyIGdhcCA9IHRoaXMuZ2FwVG8gLSB0aGlzLmdhcEZyb207XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLFxuICAgICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgdmFyIGdhcEZyb20gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKSxcbiAgICAgICAgICBnYXBUbyA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIixcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLFxuICAgICAgICBnYXBUbzogdGhpcy5nYXBUbyxcbiAgICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKSBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXBsYWNlQXJvdW5kU3RlcDtcbn0oU3RlcCk7XG5cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5cbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgdmFyICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksXG4gICAgICBkaXN0ID0gdG8gLSBmcm9tLFxuICAgICAgZGVwdGggPSAkZnJvbS5kZXB0aDtcblxuICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICBkZXB0aC0tO1xuICAgIGRpc3QtLTtcbiAgfVxuXG4gIGlmIChkaXN0ID4gMCkge1xuICAgIHZhciBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG5cbiAgICB3aGlsZSAoZGlzdCA+IDApIHtcbiAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlzTGVhZikgcmV0dXJuIHRydWU7XG4gICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgZGlzdC0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2FkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gIHZhciByZW1vdmVkID0gW10sXG4gICAgICBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZpbmcsIGFkZGluZztcbiAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcywgcGFyZW50KSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lKSByZXR1cm47XG4gICAgdmFyIG1hcmtzID0gbm9kZS5tYXJrcztcblxuICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLFxuICAgICAgICAgIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgIHZhciBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSkgcmVtb3ZpbmcudG8gPSBlbmQ7ZWxzZSByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydCkgYWRkaW5nLnRvID0gZW5kO2Vsc2UgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgIH1cbiAgfSk7XG4gIHJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0ci5zdGVwKHMpO1xuICB9KTtcbiAgYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0ci5zdGVwKHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gX3JlbW92ZU1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gIHZhciBtYXRjaGVkID0gW10sXG4gICAgICBzdGVwID0gMDtcbiAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgIGlmICghbm9kZS5pc0lubGluZSkgcmV0dXJuO1xuICAgIHN0ZXArKztcbiAgICB2YXIgdG9SZW1vdmUgPSBudWxsO1xuXG4gICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBwcm9zZW1pcnJvck1vZGVsLk1hcmtUeXBlKSB7XG4gICAgICB2YXIgc2V0ID0gbm9kZS5tYXJrcyxcbiAgICAgICAgICBmb3VuZDtcblxuICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hcmspIHtcbiAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgfVxuXG4gICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3R5bGUgPSB0b1JlbW92ZVtpXSxcbiAgICAgICAgICAgIF9mb3VuZCA9IHZvaWQgMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSkgX2ZvdW5kID0gbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZm91bmQpIHtcbiAgICAgICAgICBfZm91bmQudG8gPSBlbmQ7XG4gICAgICAgICAgX2ZvdW5kLnN0ZXAgPSBzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoZWQucHVzaCh7XG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLFxuICAgICAgICAgICAgdG86IGVuZCxcbiAgICAgICAgICAgIHN0ZXA6IHN0ZXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIG1hdGNoZWQuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9jbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlKSB7XG4gIHZhciBtYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogcGFyZW50VHlwZS5jb250ZW50TWF0Y2g7XG4gIHZhciBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICB2YXIgZGVsU3RlcHMgPSBbXSxcbiAgICAgIGN1ciA9IHBvcyArIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQoaSksXG4gICAgICAgIGVuZCA9IGN1ciArIGNoaWxkLm5vZGVTaXplO1xuICAgIHZhciBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuXG4gICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICBkZWxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IGFsbG93ZWQ7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKSB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXIgPSBlbmQ7XG4gIH1cblxuICBpZiAoIW1hdGNoLnZhbGlkRW5kKSB7XG4gICAgdmFyIGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHRyLnJlcGxhY2UoY3VyLCBjdXIsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGZpbGwsIDAsIDApKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gZGVsU3RlcHMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgIHRyLnN0ZXAoZGVsU3RlcHNbX2ldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJiAoZW5kID09IG5vZGUuY2hpbGRDb3VudCB8fCBub2RlLmNhblJlcGxhY2UoMCwgZW5kKSk7XG59XG5cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgdmFyIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcblxuICBmb3IgKHZhciBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgIHZhciBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgdmFyIGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLFxuICAgICAgICBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSkgcmV0dXJuIGRlcHRoO1xuICAgIGlmIChkZXB0aCA9PSAwIHx8IG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhY2FuQ3V0KG5vZGUsIGluZGV4LCBlbmRJbmRleCkpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIF9saWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gIHZhciAkZnJvbSA9IHJhbmdlLiRmcm9tLFxuICAgICAgJHRvID0gcmFuZ2UuJHRvLFxuICAgICAgZGVwdGggPSByYW5nZS5kZXB0aDtcbiAgdmFyIGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksXG4gICAgICBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgdmFyIHN0YXJ0ID0gZ2FwU3RhcnQsXG4gICAgICBlbmQgPSBnYXBFbmQ7XG4gIHZhciBiZWZvcmUgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LFxuICAgICAgb3BlblN0YXJ0ID0gMDtcblxuICBmb3IgKHZhciBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pIHtcbiAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgIGJlZm9yZSA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICBvcGVuU3RhcnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQtLTtcbiAgICB9XG4gIH1cblxuICB2YXIgYWZ0ZXIgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LFxuICAgICAgb3BlbkVuZCA9IDA7XG5cbiAgZm9yICh2YXIgX2QgPSBkZXB0aCwgX3NwbGl0dGluZyA9IGZhbHNlOyBfZCA+IHRhcmdldDsgX2QtLSkge1xuICAgIGlmIChfc3BsaXR0aW5nIHx8ICR0by5hZnRlcihfZCArIDEpIDwgJHRvLmVuZChfZCkpIHtcbiAgICAgIF9zcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgYWZ0ZXIgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJHRvLm5vZGUoX2QpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgIG9wZW5FbmQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kKys7XG4gICAgfVxuICB9XG5cbiAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIG9wZW5TdGFydCwgb3BlbkVuZCksIGJlZm9yZS5zaXplIC0gb3BlblN0YXJ0LCB0cnVlKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB2YXIgaW5uZXJSYW5nZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogcmFuZ2U7XG4gIHZhciBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gIHZhciBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICBpZiAoIWlubmVyKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKS5jb25jYXQoe1xuICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgIGF0dHJzOiBhdHRyc1xuICB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuXG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgYXR0cnM6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50LFxuICAgICAgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsXG4gICAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICB2YXIgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgaWYgKCFhcm91bmQpIHJldHVybiBudWxsO1xuICB2YXIgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsXG4gICAgICBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gIHZhciBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgdmFyIGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgaWYgKCFpbnNpZGUpIHJldHVybiBudWxsO1xuICB2YXIgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gIHZhciBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgfVxuXG4gIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIF93cmFwMih0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gIHZhciBjb250ZW50ID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcblxuICBmb3IgKHZhciBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgfVxuXG4gICAgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsXG4gICAgICBlbmQgPSByYW5nZS5lbmQ7XG4gIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbn1cblxuZnVuY3Rpb24gX3NldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gIHZhciBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzKSAmJiBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgIHRyLmNsZWFySW5jb21wYXRpYmxlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUpO1xuICAgICAgdmFyIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgdmFyIHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksXG4gICAgICAgICAgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksXG4gICAgICBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgcmV0dXJuICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBfc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgdmFyIG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpO1xuICBpZiAoIXR5cGUpIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICBpZiAobm9kZS5pc0xlYWYpIHJldHVybiB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG5ld05vZGUpO1xuICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obmV3Tm9kZSksIDAsIDApLCAxLCB0cnVlKSk7XG59XG5cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zKSB7XG4gIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgdmFyIHR5cGVzQWZ0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLFxuICAgICAgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgdmFyIGlubmVyVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdIHx8ICRwb3MucGFyZW50O1xuICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8ICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICB2YXIgbm9kZSA9ICRwb3Mubm9kZShkKSxcbiAgICAgICAgX2luZGV4ID0gJHBvcy5pbmRleChkKTtcblxuICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KF9pbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICB2YXIgYWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0gfHwgbm9kZTtcbiAgICBpZiAoYWZ0ZXIgIT0gbm9kZSkgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIGFmdGVyLnR5cGUuY3JlYXRlKGFmdGVyLmF0dHJzKSk7XG4gICAgaWYgKCFub2RlLmNhblJlcGxhY2UoX2luZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgdmFyIGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cblxuZnVuY3Rpb24gX3NwbGl0KHRyLCBwb3MpIHtcbiAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgdHlwZXNBZnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICB2YXIgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyksXG4gICAgICBiZWZvcmUgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LFxuICAgICAgYWZ0ZXIgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5O1xuXG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoLCBlID0gJHBvcy5kZXB0aCAtIGRlcHRoLCBpID0gZGVwdGggLSAxOyBkID4gZTsgZC0tLCBpLS0pIHtcbiAgICBiZWZvcmUgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgdmFyIHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICBhZnRlciA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICB9XG5cbiAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG5cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLFxuICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gIHJldHVybiAhIShhICYmIGIgJiYgIWEuaXNMZWFmICYmIGEuY2FuQXBwZW5kKGIpKTtcbn1cblxuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zKSB7XG4gIHZhciBkaXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IC0xO1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG5cbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICB2YXIgYmVmb3JlID0gdm9pZCAwLFxuICAgICAgICBhZnRlciA9IHZvaWQgMCxcbiAgICAgICAgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuXG4gICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICB9IGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICBpbmRleCsrO1xuICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKSByZXR1cm4gcG9zO1xuICAgIGlmIChkID09IDApIGJyZWFrO1xuICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2pvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgdmFyIHN0ZXAgPSBuZXcgUmVwbGFjZVN0ZXAocG9zIC0gZGVwdGgsIHBvcyArIGRlcHRoLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5LCB0cnVlKTtcbiAgdHIuc3RlcChzdGVwKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpIHJldHVybiBwb3M7XG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKSBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKSByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgIGlmIChpbmRleCA+IDApIHJldHVybiBudWxsO1xuICB9XG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpIGZvciAodmFyIF9kMiA9ICRwb3MuZGVwdGggLSAxOyBfZDIgPj0gMDsgX2QyLS0pIHtcbiAgICB2YXIgX2luZGV4MiA9ICRwb3MuaW5kZXhBZnRlcihfZDIpO1xuXG4gICAgaWYgKCRwb3Mubm9kZShfZDIpLmNhblJlcGxhY2VXaXRoKF9pbmRleDIsIF9pbmRleDIsIG5vZGVUeXBlKSkgcmV0dXJuICRwb3MuYWZ0ZXIoX2QyICsgMSk7XG4gICAgaWYgKF9pbmRleDIgPCAkcG9zLm5vZGUoX2QyKS5jaGlsZENvdW50KSByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gIGlmICghc2xpY2UuY29udGVudC5zaXplKSByZXR1cm4gcG9zO1xuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgfVxuXG4gIGZvciAodmFyIHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgdmFyIGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGQpLFxuICAgICAgICAgIGZpdHMgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZml0cykgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tKSB7XG4gIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZnJvbTtcbiAgdmFyIHNsaWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5O1xuICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSkgcmV0dXJuIG51bGw7XG4gIHZhciAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLFxuICAgICAgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuXG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiYgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuXG52YXIgRml0dGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaXR0ZXIoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRml0dGVyKTtcblxuICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICB0aGlzLiR0byA9ICR0bztcbiAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgdGhpcy5mcm9udGllciA9IFtdO1xuICAgIHRoaXMucGxhY2VkID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMiA9ICRmcm9tLmRlcHRoOyBfaTIgPiAwOyBfaTItLSkge1xuICAgICAgdGhpcy5wbGFjZWQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShfaTIpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRml0dGVyLCBbe1xuICAgIGtleTogXCJkZXB0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgdmFyIGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgIGlmIChmaXQpIHRoaXMucGxhY2VOb2RlcyhmaXQpO2Vsc2UgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksXG4gICAgICAgICAgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgIHZhciAkZnJvbSA9IHRoaXMuJGZyb20sXG4gICAgICAgICAgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgaWYgKCEkdG8pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnBsYWNlZCxcbiAgICAgICAgICBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCxcbiAgICAgICAgICBvcGVuRW5kID0gJHRvLmRlcHRoO1xuXG4gICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpY2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgaWYgKG1vdmVJbmxpbmUgPiAtMSkgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEZpdHRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgIGZvciAodmFyIHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICBmb3IgKHZhciBzbGljZURlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICAgICAgdmFyIGZyYWdtZW50ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGNvbnRlbnRBdCh0aGlzLnVucGxhY2VkLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxKS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgIGZvciAodmFyIGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJGZyb250aWVyJGZyb250aSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sXG4gICAgICAgICAgICAgICAgdHlwZSA9IF90aGlzJGZyb250aWVyJGZyb250aS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoID0gX3RoaXMkZnJvbnRpZXIkZnJvbnRpLm1hdGNoLFxuICAgICAgICAgICAgICAgIF93cmFwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGluamVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChwYXNzID09IDEgJiYgKGZpcnN0ID8gbWF0Y2gubWF0Y2hUeXBlKGZpcnN0LnR5cGUpIHx8IChpbmplY3QgPSBtYXRjaC5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSkgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKSByZXR1cm4ge1xuICAgICAgICAgICAgICBzbGljZURlcHRoOiBzbGljZURlcHRoLFxuICAgICAgICAgICAgICBmcm9udGllckRlcHRoOiBmcm9udGllckRlcHRoLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgaW5qZWN0OiBpbmplY3RcbiAgICAgICAgICAgIH07ZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmIChfd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpIHJldHVybiB7XG4gICAgICAgICAgICAgIHNsaWNlRGVwdGg6IHNsaWNlRGVwdGgsXG4gICAgICAgICAgICAgIGZyb250aWVyRGVwdGg6IGZyb250aWVyRGVwdGgsXG4gICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICB3cmFwOiBfd3JhcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5Nb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5Nb3JlKCkge1xuICAgICAgdmFyIF90aGlzJHVucGxhY2VkID0gdGhpcy51bnBsYWNlZCxcbiAgICAgICAgICBjb250ZW50ID0gX3RoaXMkdW5wbGFjZWQuY29udGVudCxcbiAgICAgICAgICBvcGVuU3RhcnQgPSBfdGhpcyR1bnBsYWNlZC5vcGVuU3RhcnQsXG4gICAgICAgICAgb3BlbkVuZCA9IF90aGlzJHVucGxhY2VkLm9wZW5FbmQ7XG4gICAgICB2YXIgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZikgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCArIDEsIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJvcE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJvcE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXMkdW5wbGFjZWQyID0gdGhpcy51bnBsYWNlZCxcbiAgICAgICAgICBjb250ZW50ID0gX3RoaXMkdW5wbGFjZWQyLmNvbnRlbnQsXG4gICAgICAgICAgb3BlblN0YXJ0ID0gX3RoaXMkdW5wbGFjZWQyLm9wZW5TdGFydCxcbiAgICAgICAgICBvcGVuRW5kID0gX3RoaXMkdW5wbGFjZWQyLm9wZW5FbmQ7XG4gICAgICB2YXIgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcblxuICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIHZhciBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsYWNlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2VOb2RlcyhfcmVmKSB7XG4gICAgICB2YXIgc2xpY2VEZXB0aCA9IF9yZWYuc2xpY2VEZXB0aCxcbiAgICAgICAgICBmcm9udGllckRlcHRoID0gX3JlZi5mcm9udGllckRlcHRoLFxuICAgICAgICAgIHBhcmVudCA9IF9yZWYucGFyZW50LFxuICAgICAgICAgIGluamVjdCA9IF9yZWYuaW5qZWN0LFxuICAgICAgICAgIHdyYXAgPSBfcmVmLndyYXA7XG5cbiAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aCkge1xuICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3cmFwKSBmb3IgKHZhciBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIHNsaWNlID0gdGhpcy51bnBsYWNlZCxcbiAgICAgICAgICBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgdmFyIHRha2VuID0gMCxcbiAgICAgICAgICBhZGQgPSBbXTtcbiAgICAgIHZhciBfdGhpcyRmcm9udGllciRmcm9udGkyID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSxcbiAgICAgICAgICBtYXRjaCA9IF90aGlzJGZyb250aWVyJGZyb250aTIubWF0Y2gsXG4gICAgICAgICAgdHlwZSA9IF90aGlzJGZyb250aWVyJGZyb250aTIudHlwZTtcblxuICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICBhZGQucHVzaChpbmplY3QuY2hpbGQoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcGVuRW5kQ291bnQgPSBmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcblxuICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICB2YXIgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSxcbiAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSBicmVhaztcbiAgICAgICAgdGFrZW4rKztcblxuICAgICAgICBpZiAodGFrZW4gPiAxIHx8IG9wZW5TdGFydCA9PSAwIHx8IG5leHQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgaWYgKCF0b0VuZCkgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKSB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIGN1ciA9IGZyYWdtZW50OyBfaTMgPCBvcGVuRW5kQ291bnQ7IF9pMysrKSB7XG4gICAgICAgIHZhciBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KVxuICAgICAgICB9KTtcbiAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCkgOiBzbGljZURlcHRoID09IDAgPyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5IDogbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVzdE1vdmVJbmxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jaykgcmV0dXJuIC0xO1xuICAgICAgdmFyIHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sXG4gICAgICAgICAgbGV2ZWw7XG4gICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8IHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpIHJldHVybiAtMTtcbiAgICAgIHZhciBkZXB0aCA9IHRoaXMuJHRvLmRlcHRoLFxuICAgICAgICAgIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuXG4gICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSkge1xuICAgICAgICArK2FmdGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRDbG9zZUxldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgc2NhbjogZm9yICh2YXIgaSA9IE1hdGgubWluKHRoaXMuZGVwdGgsICR0by5kZXB0aCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBfdGhpcyRmcm9udGllciRpID0gdGhpcy5mcm9udGllcltpXSxcbiAgICAgICAgICAgIG1hdGNoID0gX3RoaXMkZnJvbnRpZXIkaS5tYXRjaCxcbiAgICAgICAgICAgIHR5cGUgPSBfdGhpcyRmcm9udGllciRpLnR5cGU7XG4gICAgICAgIHZhciBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgIHZhciBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgIGlmICghZml0KSBjb250aW51ZTtcblxuICAgICAgICBmb3IgKHZhciBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGZyb250aWVyJGQgPSB0aGlzLmZyb250aWVyW2RdLFxuICAgICAgICAgICAgICBfbWF0Y2ggPSBfdGhpcyRmcm9udGllciRkLm1hdGNoLFxuICAgICAgICAgICAgICBfdHlwZSA9IF90aGlzJGZyb250aWVyJGQudHlwZTtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCBfdHlwZSwgX21hdGNoLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KSBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBmaXQ6IGZpdCxcbiAgICAgICAgICBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoJHRvKSB7XG4gICAgICB2YXIgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICBpZiAoIWNsb3NlKSByZXR1cm4gbnVsbDtcblxuICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aCkge1xuICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudCkgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICR0byA9IGNsb3NlLm1vdmU7XG5cbiAgICAgIGZvciAodmFyIGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSAkdG8ubm9kZShkKSxcbiAgICAgICAgICAgIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkdG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5Gcm9udGllck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkZyb250aWVyTm9kZSh0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIGNvbnRlbnQpKSk7XG4gICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZUZyb250aWVyTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgIHZhciBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgICAgIHZhciBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICBpZiAoYWRkLmNoaWxkQ291bnQpIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpdHRlcjtcbn0oKTtcblxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gIGlmIChkZXB0aCA9PSAwKSByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuXG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICBpZiAoZGVwdGggPT0gMCkgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpO1xufVxuXG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwdGg7IGkrKykge1xuICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgaWYgKG9wZW5TdGFydCA8PSAwKSByZXR1cm4gbm9kZTtcbiAgdmFyIGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gIGlmIChvcGVuU3RhcnQgPiAxKSBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuXG4gIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgaWYgKG9wZW5FbmQgPD0gMCkgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgfVxuXG4gIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgdmFyIG5vZGUgPSAkdG8ubm9kZShkZXB0aCksXG4gICAgICBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpIHJldHVybiBudWxsO1xuICB2YXIgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICBpZiAoIXNsaWNlLnNpemUpIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gIHZhciAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLFxuICAgICAgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpIHJldHVybiB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpKTtcbiAgdmFyIHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApIHRhcmdldERlcHRocy5wb3AoKTtcbiAgdmFyIHByZWZlcnJlZFRhcmdldCA9IC0oJGZyb20uZGVwdGggKyAxKTtcbiAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcblxuICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgdmFyIHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmRlZmluaW5nQXNDb250ZXh0IHx8IHNwZWMuaXNvbGF0aW5nKSBicmVhaztcbiAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSkgcHJlZmVycmVkVGFyZ2V0ID0gZDtlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKSB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgfVxuXG4gIHZhciBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gIHZhciBsZWZ0Tm9kZXMgPSBbXSxcbiAgICAgIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuXG4gIGZvciAodmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgIHZhciBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydCkgYnJlYWs7XG4gICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgfVxuXG4gIGZvciAodmFyIF9kMyA9IHByZWZlcnJlZERlcHRoIC0gMTsgX2QzID49IDA7IF9kMy0tKSB7XG4gICAgdmFyIHR5cGUgPSBsZWZ0Tm9kZXNbX2QzXS50eXBlLFxuICAgICAgICBkZWYgPSBkZWZpbmVzQ29udGVudCh0eXBlKTtcbiAgICBpZiAoZGVmICYmICRmcm9tLm5vZGUocHJlZmVycmVkVGFyZ2V0SW5kZXgpLnR5cGUgIT0gdHlwZSkgcHJlZmVycmVkRGVwdGggPSBfZDM7ZWxzZSBpZiAoZGVmIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSBicmVhaztcbiAgfVxuXG4gIGZvciAodmFyIGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgdmFyIG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICB2YXIgaW5zZXJ0ID0gbGVmdE5vZGVzW29wZW5EZXB0aF07XG4gICAgaWYgKCFpbnNlcnQpIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdGFyZ2V0RGVwdGhzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciB0YXJnZXREZXB0aCA9IHRhcmdldERlcHRoc1soX2k0ICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sXG4gICAgICAgICAgZXhwYW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHRhcmdldERlcHRoIDwgMCkge1xuICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksXG4gICAgICAgICAgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKSByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLCBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhcnRTdGVwcyA9IHRyLnN0ZXBzLmxlbmd0aDtcblxuICBmb3IgKHZhciBfaTUgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgX2k1ID49IDA7IF9pNS0tKSB7XG4gICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKSBicmVhaztcbiAgICB2YXIgZGVwdGggPSB0YXJnZXREZXB0aHNbX2k1XTtcbiAgICBpZiAoZGVwdGggPCAwKSBjb250aW51ZTtcbiAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICB0byA9ICR0by5hZnRlcihkZXB0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VGcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIG9sZE9wZW4sIG5ld09wZW4sIHBhcmVudCkge1xuICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgdmFyIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgfVxuXG4gIGlmIChkZXB0aCA+IG5ld09wZW4pIHtcbiAgICB2YXIgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgdmFyIHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICBmcmFnbWVudCA9IHN0YXJ0LmFwcGVuZChtYXRjaC5tYXRjaEZyYWdtZW50KHN0YXJ0KS5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gX3JlcGxhY2VSYW5nZVdpdGgodHIsIGZyb20sIHRvLCBub2RlKSB7XG4gIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICB2YXIgcG9pbnQgPSBpbnNlcnRQb2ludCh0ci5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgaWYgKHBvaW50ICE9IG51bGwpIGZyb20gPSB0byA9IHBvaW50O1xuICB9XG5cbiAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbn1cblxuZnVuY3Rpb24gX2RlbGV0ZVJhbmdlKHRyLCBmcm9tLCB0bykge1xuICB2YXIgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgdmFyIGNvdmVyZWQgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXB0aCA9IGNvdmVyZWRbaV0sXG4gICAgICAgIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCAmJiBkZXB0aCA9PSAwIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKSByZXR1cm4gdHJbXCJkZWxldGVcIl0oJGZyb20uc3RhcnQoZGVwdGgpLCAkdG8uZW5kKGRlcHRoKSk7XG4gICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpIHJldHVybiB0cltcImRlbGV0ZVwiXSgkZnJvbS5iZWZvcmUoZGVwdGgpLCAkdG8uYWZ0ZXIoZGVwdGgpKTtcbiAgfVxuXG4gIGZvciAodmFyIGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICBpZiAoZnJvbSAtICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLmRlcHRoIC0gZCAmJiB0byA+ICRmcm9tLmVuZChkKSAmJiAkdG8uZW5kKGQpIC0gdG8gIT0gJHRvLmRlcHRoIC0gZCkgcmV0dXJuIHRyW1wiZGVsZXRlXCJdKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICB9XG5cbiAgdHJbXCJkZWxldGVcIl0oZnJvbSwgdG8pO1xufVxuXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcblxuICBmb3IgKHZhciBkID0gbWluRGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIHN0YXJ0ID0gJGZyb20uc3RhcnQoZCk7XG4gICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHwgJHRvLmVuZChkKSA+ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gZCkgfHwgJGZyb20ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpIGJyZWFrO1xuICAgIGlmIChzdGFydCA9PSAkdG8uc3RhcnQoZCkgfHwgZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkgcmVzdWx0LnB1c2goZCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLlRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoX2NsYXNzLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKF9jbGFzcyk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoX2NsYXNzKTtcbn0oX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzLlRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIGVycjtcbn07XG5cbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLlRyYW5zZm9ybUVycm9yO1xuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcblxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtKGRvYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm0pO1xuXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtLCBbe1xuICAgIGtleTogXCJiZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcChfc3RlcCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKF9zdGVwKTtcbiAgICAgIGlmIChyZXN1bHQuZmFpbGVkKSB0aHJvdyBuZXcgZXhwb3J0cy5UcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXliZVN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVTdGVwKHN0ZXApIHtcbiAgICAgIHZhciByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgIGlmICghcmVzdWx0LmZhaWxlZCkgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9jQ2hhbmdlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgdGhpcy5kb2NzLnB1c2godGhpcy5kb2MpO1xuICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmcm9tO1xuICAgICAgdmFyIHNsaWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5O1xuICAgICAgdmFyIHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgIGlmIChzdGVwKSB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVdpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQocG9zLCBjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICBfcmVwbGFjZVJhbmdlKHRoaXMsIGZyb20sIHRvLCBzbGljZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlUmFuZ2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpIHtcbiAgICAgIF9yZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICBfZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaWZ0KHJhbmdlLCB0YXJnZXQpIHtcbiAgICAgIF9saWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHBvcykge1xuICAgICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgICBfam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgIF93cmFwMih0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QmxvY2tUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJsb2NrVHlwZShmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZyb207XG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gICAgICBfc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXROb2RlTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5vZGVNYXJrdXAocG9zLCB0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgbWFya3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuXG4gICAgICBfc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdChwb3MpIHtcbiAgICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgIHZhciB0eXBlc0FmdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIF9zcGxpdCh0aGlzLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgX2FkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICBfcmVtb3ZlTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckluY29tcGF0aWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZShwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gICAgICBfY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm07XG59KCk7XG5cbmV4cG9ydHMuQWRkTWFya1N0ZXAgPSBBZGRNYXJrU3RlcDtcbmV4cG9ydHMuTWFwUmVzdWx0ID0gTWFwUmVzdWx0O1xuZXhwb3J0cy5NYXBwaW5nID0gTWFwcGluZztcbmV4cG9ydHMuUmVtb3ZlTWFya1N0ZXAgPSBSZW1vdmVNYXJrU3RlcDtcbmV4cG9ydHMuUmVwbGFjZUFyb3VuZFN0ZXAgPSBSZXBsYWNlQXJvdW5kU3RlcDtcbmV4cG9ydHMuUmVwbGFjZVN0ZXAgPSBSZXBsYWNlU3RlcDtcbmV4cG9ydHMuU3RlcCA9IFN0ZXA7XG5leHBvcnRzLlN0ZXBNYXAgPSBTdGVwTWFwO1xuZXhwb3J0cy5TdGVwUmVzdWx0ID0gU3RlcFJlc3VsdDtcbmV4cG9ydHMuVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuZXhwb3J0cy5jYW5Kb2luID0gY2FuSm9pbjtcbmV4cG9ydHMuY2FuU3BsaXQgPSBjYW5TcGxpdDtcbmV4cG9ydHMuZHJvcFBvaW50ID0gZHJvcFBvaW50O1xuZXhwb3J0cy5maW5kV3JhcHBpbmcgPSBmaW5kV3JhcHBpbmc7XG5leHBvcnRzLmluc2VydFBvaW50ID0gaW5zZXJ0UG9pbnQ7XG5leHBvcnRzLmpvaW5Qb2ludCA9IGpvaW5Qb2ludDtcbmV4cG9ydHMubGlmdFRhcmdldCA9IGxpZnRUYXJnZXQ7XG5leHBvcnRzLnJlcGxhY2VTdGVwID0gcmVwbGFjZVN0ZXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbnZhciBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xudmFyIGFnZW50ID0gbmF2ICYmIG5hdi51c2VyQWdlbnQgfHwgXCJcIjtcbnZhciBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xudmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8uZXhlYyhhZ2VudCk7XG52YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG52YXIgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbnZhciBpZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMDtcbnZhciBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5cbnZhciBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuXG52YXIgY2hyb21lID0gISFfY2hyb21lO1xudmFyIGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbnZhciBzYWZhcmkgPSAhaWUgJiYgISFuYXYgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xudmFyIGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QoYWdlbnQpIHx8ICEhbmF2ICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xudmFyIGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xudmFyIHdlYmtpdCA9ICEhZG9jICYmIFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG52YXIgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxudmFyIGRvbUluZGV4ID0gZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgIGlmICghbm9kZSkgcmV0dXJuIGluZGV4O1xuICB9XG59O1xuXG52YXIgcGFyZW50Tm9kZSA9IGZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICB2YXIgcGFyZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSA/IHBhcmVudC5ob3N0IDogcGFyZW50O1xufTtcblxudmFyIHJldXNlZFJhbmdlID0gbnVsbDtcblxudmFyIHRleHRSYW5nZSA9IGZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0bykge1xuICB2YXIgcmFuZ2UgPSByZXVzZWRSYW5nZSB8fCAocmV1c2VkUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvID09IG51bGwgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiB0byk7XG4gIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbnZhciBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHwgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpO1xufTtcblxudmFyIGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8IG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9kZVNpemUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgZm9yICh2YXIgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHJldHVybiB0cnVlO1xuICAgIHZhciBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgdmFyIGRlc2M7XG5cbiAgZm9yICh2YXIgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYykgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKTtcbn1cblxudmFyIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpIHtcbiAgdmFyIGNvbGxhcHNlZCA9IGRvbVNlbC5pc0NvbGxhcHNlZDtcbiAgaWYgKGNvbGxhcHNlZCAmJiBjaHJvbWUgJiYgZG9tU2VsLnJhbmdlQ291bnQgJiYgIWRvbVNlbC5nZXRSYW5nZUF0KDApLmNvbGxhcHNlZCkgY29sbGFwc2VkID0gZmFsc2U7XG4gIHJldHVybiBjb2xsYXBzZWQ7XG59O1xuXG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gIGV2ZW50LmtleSA9IGV2ZW50LmNvZGUgPSBrZXk7XG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNpZGUodmFsdWUsIHNpZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cblxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgYm90dG9tOiByZWN0LnRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ICogc2NhbGVZXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICB2YXIgc2Nyb2xsVGhyZXNob2xkID0gdmlldy5zb21lUHJvcChcInNjcm9sbFRocmVzaG9sZFwiKSB8fCAwLFxuICAgICAgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICB2YXIgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcblxuICBmb3IgKHZhciBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7IHBhcmVudCA9IHBhcmVudE5vZGUocGFyZW50KSkge1xuICAgIGlmICghcGFyZW50KSBicmVhaztcbiAgICBpZiAocGFyZW50Lm5vZGVUeXBlICE9IDEpIGNvbnRpbnVlO1xuICAgIHZhciBlbHQgPSBwYXJlbnQ7XG4gICAgdmFyIGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgIHZhciBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgIHZhciBtb3ZlWCA9IDAsXG4gICAgICAgIG1vdmVZID0gMDtcbiAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7ZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJib3R0b21cIikpIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJsZWZ0XCIpKSBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO2Vsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKSBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpO1xuXG4gICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzdGFydFkgPSBlbHQuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAobW92ZVkpIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgIGlmIChtb3ZlWCkgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgIHZhciBkWCA9IGVsdC5zY3JvbGxMZWZ0IC0gc3RhcnRYLFxuICAgICAgICAgICAgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIGRYLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBkWSxcbiAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIGRYLFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdFRvcCkgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3Modmlldykge1xuICB2YXIgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICB2YXIgcmVmRE9NLCByZWZUb3A7XG5cbiAgZm9yICh2YXIgeCA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIHkgPSBzdGFydFkgKyAxOyB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgdmFyIGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSkgY29udGludWU7XG4gICAgdmFyIGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChsb2NhbFJlY3QudG9wID49IHN0YXJ0WSAtIDIwKSB7XG4gICAgICByZWZET00gPSBkb207XG4gICAgICByZWZUb3AgPSBsb2NhbFJlY3QudG9wO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWZET006IHJlZkRPTSxcbiAgICByZWZUb3A6IHJlZlRvcCxcbiAgICBzdGFjazogc2Nyb2xsU3RhY2sodmlldy5kb20pXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICB2YXIgc3RhY2sgPSBbXSxcbiAgICAgIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuXG4gIGZvciAodmFyIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICBzdGFjay5wdXNoKHtcbiAgICAgIGRvbTogY3VyLFxuICAgICAgdG9wOiBjdXIuc2Nyb2xsVG9wLFxuICAgICAgbGVmdDogY3VyLnNjcm9sbExlZnRcbiAgICB9KTtcbiAgICBpZiAoZG9tID09IGRvYykgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKF9yZWYpIHtcbiAgdmFyIHJlZkRPTSA9IF9yZWYucmVmRE9NLFxuICAgICAgcmVmVG9wID0gX3JlZi5yZWZUb3AsXG4gICAgICBzdGFjayA9IF9yZWYuc3RhY2s7XG4gIHZhciBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBuZXdSZWZUb3AgPT0gMCA/IDAgOiBuZXdSZWZUb3AgLSByZWZUb3ApO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfc3RhY2skaSA9IHN0YWNrW2ldLFxuICAgICAgICBkb20gPSBfc3RhY2skaS5kb20sXG4gICAgICAgIHRvcCA9IF9zdGFjayRpLnRvcCxcbiAgICAgICAgbGVmdCA9IF9zdGFjayRpLmxlZnQ7XG4gICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcCkgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgfVxufVxuXG52YXIgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgaWYgKGRvbS5zZXRBY3RpdmUpIHJldHVybiBkb20uc2V0QWN0aXZlKCk7XG4gIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICB2YXIgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgfSA6IHVuZGVmaW5lZCk7XG5cbiAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gIHZhciBjbG9zZXN0LFxuICAgICAgZHhDbG9zZXN0ID0gMmU4LFxuICAgICAgY29vcmRzQ2xvc2VzdCxcbiAgICAgIG9mZnNldCA9IDA7XG4gIHZhciByb3dCb3QgPSBjb29yZHMudG9wLFxuICAgICAgcm93VG9wID0gY29vcmRzLnRvcDtcblxuICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICB2YXIgcmVjdHMgPSB2b2lkIDA7XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtlbHNlIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY3QgPSByZWN0c1tpXTtcblxuICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICB2YXIgZHggPSByZWN0LmxlZnQgPiBjb29yZHMubGVmdCA/IHJlY3QubGVmdCAtIGNvb3Jkcy5sZWZ0IDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gY29vcmRzLmxlZnQgLSByZWN0LnJpZ2h0IDogMDtcblxuICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQsXG4gICAgICAgICAgICB0b3A6IGNvb3Jkcy50b3BcbiAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KSBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHwgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKSBvZmZzZXQgPSBjaGlsZEluZGV4ICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMpIHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xuICBpZiAoIWNsb3Nlc3QgfHwgZHhDbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMSkgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xufVxuXG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICB2YXIgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgIHZhciByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKSBjb250aW51ZTtcbiAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMClcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIG9mZnNldDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJlY3QoY29vcmRzLCByZWN0KSB7XG4gIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuXG5mdW5jdGlvbiB0YXJnZXRLbHVkZ2UoZG9tLCBjb29yZHMpIHtcbiAgdmFyIHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIHJldHVybiBwYXJlbnQ7XG4gIHJldHVybiBkb207XG59XG5cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gIHZhciBfZmluZE9mZnNldEluTm9kZSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLFxuICAgICAgbm9kZSA9IF9maW5kT2Zmc2V0SW5Ob2RlLm5vZGUsXG4gICAgICBvZmZzZXQgPSBfZmluZE9mZnNldEluTm9kZS5vZmZzZXQsXG4gICAgICBiaWFzID0gLTE7XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gIH1cblxuICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbn1cblxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gIHZhciBvdXRzaWRlID0gLTE7XG5cbiAgZm9yICh2YXIgY3VyID0gbm9kZTs7KSB7XG4gICAgaWYgKGN1ciA9PSB2aWV3LmRvbSkgYnJlYWs7XG4gICAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY3VyLCB0cnVlKTtcbiAgICBpZiAoIWRlc2MpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcCkgb3V0c2lkZSA9IGRlc2MucG9zQmVmb3JlO2Vsc2UgaWYgKHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApIG91dHNpZGUgPSBkZXNjLnBvc0FmdGVyO2Vsc2UgYnJlYWs7XG4gICAgfVxuXG4gICAgY3VyID0gZGVzYy5kb20ucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBvdXRzaWRlID4gLTEgPyBvdXRzaWRlIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCAxKTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICB2YXIgbGVuID0gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICBpZiAobGVuICYmIGJveC50b3AgPCBib3guYm90dG9tKSB7XG4gICAgZm9yICh2YXIgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSkgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKSBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gX3Bvc0F0Q29vcmRzKHZpZXcsIGNvb3Jkcykge1xuICB2YXIgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudCxcbiAgICAgIG5vZGUsXG4gICAgICBvZmZzZXQgPSAwO1xuXG4gIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3BvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcblxuICAgICAgaWYgKF9wb3MpIHtcbiAgICAgICAgbm9kZSA9IF9wb3Mub2Zmc2V0Tm9kZTtcbiAgICAgICAgb2Zmc2V0ID0gX3Bvcy5vZmZzZXQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge31cbiAgfVxuXG4gIGlmICghbm9kZSAmJiBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgIHZhciByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgbm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYykuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCArIDEpO1xuICB2YXIgcG9zO1xuXG4gIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgIHZhciBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpIHJldHVybiBudWxsO1xuICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICBpZiAoIWVsdCkgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2FmYXJpKSB7XG4gICAgZm9yICh2YXIgcCA9IGVsdDsgbm9kZSAmJiBwOyBwID0gcGFyZW50Tm9kZShwKSkge1xuICAgICAgaWYgKHAuZHJhZ2dhYmxlKSBub2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG5cbiAgaWYgKG5vZGUpIHtcbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuXG4gICAgICBpZiAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLFxuICAgICAgICAgICAgX2JveDtcblxuICAgICAgICBpZiAobmV4dC5ub2RlTmFtZSA9PSBcIklNR1wiICYmIChfYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiYgX2JveC5ib3R0b20gPiBjb29yZHMudG9wKSBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSBwb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemU7ZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gIH1cblxuICBpZiAocG9zID09IG51bGwpIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZWx0LCB0cnVlKTtcbiAgcmV0dXJuIHtcbiAgICBwb3M6IHBvcyxcbiAgICBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gIHZhciByZWN0cyA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpO1xuICByZXR1cm4gIXJlY3RzLmxlbmd0aCA/IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xufVxuXG52YXIgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG5cbmZ1bmN0aW9uIF9jb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgdmFyIF92aWV3JGRvY1ZpZXckZG9tRnJvbSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpLFxuICAgICAgbm9kZSA9IF92aWV3JGRvY1ZpZXckZG9tRnJvbS5ub2RlLFxuICAgICAgb2Zmc2V0ID0gX3ZpZXckZG9jVmlldyRkb21Gcm9tLm9mZnNldDtcblxuICB2YXIgc3VwcG9ydEVtcHR5UmFuZ2UgPSB3ZWJraXQgfHwgZ2Vja287XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICB2YXIgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG5cbiAgICAgIGlmIChnZWNrbyAmJiBvZmZzZXQgJiYgL1xccy8udGVzdChub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSkgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcblxuICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICB2YXIgcmVjdEFmdGVyID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0LCBvZmZzZXQgKyAxKSwgLTEpO1xuICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKSByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0LFxuICAgICAgICAgIHRvID0gb2Zmc2V0LFxuICAgICAgICAgIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG5cbiAgICAgIGlmIChzaWRlIDwgMCAmJiAhb2Zmc2V0KSB7XG4gICAgICAgIHRvKys7XG4gICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgdGFrZVNpZGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICBmcm9tLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0bysrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcykucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICBpZiAob2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICB2YXIgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKSByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKSByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICB9XG5cbiAgaWYgKG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgIHZhciBfYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgIHZhciB0YXJnZXQgPSBfYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoX2JlZm9yZSwgbm9kZVNpemUoX2JlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpIDogX2JlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChfYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhX2JlZm9yZS5uZXh0U2libGluZykgPyBfYmVmb3JlIDogbnVsbDtcbiAgICBpZiAodGFyZ2V0KSByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICB2YXIgX2FmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG5cbiAgICB3aGlsZSAoX2FmdGVyLnBtVmlld0Rlc2MgJiYgX2FmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKSB7XG4gICAgICBfYWZ0ZXIgPSBfYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIF90YXJnZXQgPSAhX2FmdGVyID8gbnVsbCA6IF9hZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKF9hZnRlciwgMCwgc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkgOiBfYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IF9hZnRlciA6IG51bGw7XG5cbiAgICBpZiAoX3RhcmdldCkgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QoX3RhcmdldCwgLTEpLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblYocmVjdCwgbGVmdCkge1xuICBpZiAocmVjdC53aWR0aCA9PSAwKSByZXR1cm4gcmVjdDtcbiAgdmFyIHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20sXG4gICAgbGVmdDogeCxcbiAgICByaWdodDogeFxuICB9O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgaWYgKHJlY3QuaGVpZ2h0ID09IDApIHJldHVybiByZWN0O1xuICB2YXIgeSA9IHRvcCA/IHJlY3QudG9wIDogcmVjdC5ib3R0b207XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LFxuICAgIGJvdHRvbTogeSxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICB2YXIgdmlld1N0YXRlID0gdmlldy5zdGF0ZSxcbiAgICAgIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICBpZiAodmlld1N0YXRlICE9IHN0YXRlKSB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSkgdmlldy5mb2N1cygpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKSB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJHBvcyA9IGRpciA9PSBcInVwXCIgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdmlldyRkb2NWaWV3JGRvbUZyb20yID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MoJHBvcy5wb3MsIGRpciA9PSBcInVwXCIgPyAtMSA6IDEpLFxuICAgICAgICBkb20gPSBfdmlldyRkb2NWaWV3JGRvbUZyb20yLm5vZGU7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb20sIHRydWUpO1xuICAgICAgaWYgKCFuZWFyZXN0KSBicmVhaztcblxuICAgICAgaWYgKG5lYXJlc3Qubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG9tID0gbmVhcmVzdC5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gX2Nvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcblxuICAgIGZvciAodmFyIGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICB2YXIgYm94ZXMgPSB2b2lkIDA7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkgYm94ZXMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO2Vsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO2Vsc2UgY29udGludWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJveCA9IGJveGVzW2ldO1xuICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMiA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG52YXIgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICB2YXIgJGhlYWQgPSBzdGF0ZS5zZWxlY3Rpb24uJGhlYWQ7XG4gIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIHZhciBvZmZzZXQgPSAkaGVhZC5wYXJlbnRPZmZzZXQsXG4gICAgICBhdFN0YXJ0ID0gIW9mZnNldCxcbiAgICAgIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gIHZhciBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSkgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRSYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApLFxuICAgICAgICBvbGROb2RlID0gc2VsLmZvY3VzTm9kZSxcbiAgICAgICAgb2xkT2ZmID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIHZhciBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWw7XG4gICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICB2YXIgcGFyZW50RE9NID0gJGhlYWQuZGVwdGggPyB2aWV3LmRvY1ZpZXcuZG9tQWZ0ZXJQb3MoJGhlYWQuYmVmb3JlKCkpIDogdmlldy5kb207XG4gICAgdmFyIHJlc3VsdCA9ICFwYXJlbnRET00uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxID8gc2VsLmZvY3VzTm9kZSA6IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSkgfHwgb2xkTm9kZSA9PSBzZWwuZm9jdXNOb2RlICYmIG9sZE9mZiA9PSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShvbGRSYW5nZSk7XG4gICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKSBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cbnZhciBjYWNoZWRTdGF0ZSA9IG51bGw7XG52YXIgY2FjaGVkRGlyID0gbnVsbDtcbnZhciBjYWNoZWRSZXN1bHQgPSBmYWxzZTtcblxuZnVuY3Rpb24gX2VuZE9mVGV4dGJsb2NrKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gIGNhY2hlZERpciA9IGRpcjtcbiAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKSA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxudmFyIE5PVF9ESVJUWSA9IDAsXG4gICAgQ0hJTERfRElSVFkgPSAxLFxuICAgIENPTlRFTlRfRElSVFkgPSAyLFxuICAgIE5PREVfRElSVFkgPSAzO1xuXG52YXIgVmlld0Rlc2MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdEZXNjKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgY29udGVudERPTSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3RGVzYyk7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5kb20gPSBkb207XG4gICAgdGhpcy5jb250ZW50RE9NID0gY29udGVudERPTTtcbiAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaWV3RGVzYywgW3tcbiAgICBrZXk6IFwibWF0Y2hlc1dpZGdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0KHdpZGdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzTWFyayhtYXJrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNIYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUnVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVJ1bGUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJvcmRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcykgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NCZWZvcmVDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IHRoaXMucG9zQXRTdGFydDs7IGkrKykge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGN1ciA9PSBjaGlsZCkgcmV0dXJuIHBvcztcbiAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NCZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zQXRTdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcykgKyB0aGlzLmJvcmRlciA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0FmdGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0F0RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbFBvc0Zyb21ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICB2YXIgZG9tQmVmb3JlLCBkZXNjO1xuXG4gICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSkge1xuICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZG9tQWZ0ZXIsIF9kZXNjO1xuXG4gICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKF9kZXNjID0gZG9tQWZ0ZXIucG1WaWV3RGVzYykgJiYgX2Rlc2MucGFyZW50ID09IHRoaXMpKSB7XG4gICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoX2Rlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYXRFbmQ7XG5cbiAgICAgIGlmIChkb20gPT0gdGhpcy5kb20gJiYgdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pKSB7XG4gICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT0gMCkgZm9yICh2YXIgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpIGZvciAodmFyIF9zZWFyY2ggPSBkb207OyBfc2VhcmNoID0gX3NlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKF9zZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfc2VhcmNoLm5leHRTaWJsaW5nKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJlc3REZXNjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3REZXNjKGRvbSkge1xuICAgICAgdmFyIG9ubHlOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksXG4gICAgICAgICAgICBub2RlRE9NID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChkZXNjICYmICghb25seU5vZGVzIHx8IGRlc2Mubm9kZSkpIHtcbiAgICAgICAgICBpZiAoZmlyc3QgJiYgKG5vZGVET00gPSBkZXNjLm5vZGVET00pICYmICEobm9kZURPTS5ub2RlVHlwZSA9PSAxID8gbm9kZURPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSA6IG5vZGVET00gPT0gZG9tKSkgZmlyc3QgPSBmYWxzZTtlbHNlIHJldHVybiBkZXNjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVzYyhkb20pIHtcbiAgICAgIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG5cbiAgICAgIGZvciAodmFyIGN1ciA9IGRlc2M7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBpZiAoY3VyID09IHRoaXMpIHJldHVybiBkZXNjO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NGcm9tRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgIGZvciAodmFyIHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgIGlmIChkZXNjKSByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNjQXQocG9zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgJiYgZW5kICE9IG9mZnNldCkge1xuICAgICAgICAgIHdoaWxlICghY2hpbGQuYm9yZGVyICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zIDwgZW5kKSByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tRnJvbVBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb21Gcm9tUG9zKHBvcywgc2lkZSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRoaXMuZG9tLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgZm9yICh2YXIgY3VyUG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSxcbiAgICAgICAgICAgIGVuZCA9IGN1clBvcyArIGNoaWxkLnNpemU7XG5cbiAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0KSByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcblxuICAgICAgZm9yICh2YXIgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkge31cblxuICAgICAgaWYgKHNpZGUgPD0gMCkge1xuICAgICAgICB2YXIgX3ByZXYsXG4gICAgICAgICAgICBlbnRlciA9IHRydWU7XG5cbiAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICBfcHJldiA9IGkgPyB0aGlzLmNoaWxkcmVuW2kgLSAxXSA6IG51bGw7XG4gICAgICAgICAgaWYgKCFfcHJldiB8fCBfcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9wcmV2ICYmIHNpZGUgJiYgZW50ZXIgJiYgIV9wcmV2LmJvcmRlciAmJiAhX3ByZXYuZG9tQXRvbSkgcmV0dXJuIF9wcmV2LmRvbUZyb21Qb3MoX3ByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogdGhpcy5jb250ZW50RE9NLFxuICAgICAgICAgIG9mZnNldDogX3ByZXYgPyBkb21JbmRleChfcHJldi5kb20pICsgMSA6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0LFxuICAgICAgICAgICAgX2VudGVyID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKDs7IGkrKywgX2VudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICYmIF9lbnRlciAmJiAhbmV4dC5ib3JkZXIgJiYgIW5leHQuZG9tQXRvbSkgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiB0aGlzLmNvbnRlbnRET00sXG4gICAgICAgICAgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSYW5nZShmcm9tLCB0bykge1xuICAgICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50RE9NLFxuICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICB0bzogdG8sXG4gICAgICAgIGZyb21PZmZzZXQ6IDAsXG4gICAgICAgIHRvT2Zmc2V0OiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGhcbiAgICAgIH07XG4gICAgICB2YXIgZnJvbU9mZnNldCA9IC0xLFxuICAgICAgICAgIHRvT2Zmc2V0ID0gLTE7XG5cbiAgICAgIGZvciAodmFyIG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuXG4gICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgdmFyIGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiYgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcblxuICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSkgZnJvbU9mZnNldCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbU9mZnNldCA+IC0xICYmIChlbmQgPiB0byB8fCBpID09IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICB0byA9IGVuZDtcblxuICAgICAgICAgIGZvciAodmFyIF9qID0gaSArIDE7IF9qIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jaGlsZHJlbltfal07XG5cbiAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICB0b09mZnNldCA9IGRvbUluZGV4KG5leHQuZG9tKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0aGlzLmNvbnRlbnRET00sXG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHRvOiB0byxcbiAgICAgICAgZnJvbU9mZnNldDogZnJvbU9mZnNldCxcbiAgICAgICAgdG9PZmZzZXQ6IHRvT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbXB0eUNoaWxkQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIGNoaWxkLnNpemUgPT0gMCB8fCBjaGlsZC5lbXB0eUNoaWxkQXQoc2lkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUFmdGVyUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbUFmdGVyUG9zKHBvcykge1xuICAgICAgdmFyIF90aGlzJGRvbUZyb21Qb3MgPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkZG9tRnJvbVBvcy5ub2RlLFxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJGRvbUZyb21Qb3Mub2Zmc2V0O1xuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxIHx8IG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpIHtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksXG4gICAgICAgICAgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChmcm9tID4gb2Zmc2V0ICYmIHRvIDwgZW5kKSByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgcm9vdCwgZm9yY2UpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgdmFyIGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgIHZhciBkb21TZWwgPSByb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGJyS2x1ZGdlID0gZmFsc2U7XG5cbiAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICB2YXIgX2FuY2hvckRPTSA9IGFuY2hvckRPTSxcbiAgICAgICAgICAgIG5vZGUgPSBfYW5jaG9yRE9NLm5vZGUsXG4gICAgICAgICAgICBfb2Zmc2V0ID0gX2FuY2hvckRPTS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgIGJyS2x1ZGdlID0gISEoX29mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtfb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG5cbiAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgX29mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIikgYW5jaG9yRE9NID0gaGVhZERPTSA9IHtcbiAgICAgICAgICAgICAgICAgIG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaykgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW19vZmZzZXQgLSAxXTtcbiAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdlY2tvICYmIGRvbVNlbC5mb2N1c05vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIHZhciBfYWZ0ZXIyID0gZG9tU2VsLmZvY3VzTm9kZS5jaGlsZE5vZGVzW2RvbVNlbC5mb2N1c09mZnNldF07XG4gICAgICAgIGlmIChfYWZ0ZXIyICYmIF9hZnRlcjIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgZm9yY2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgcmV0dXJuO1xuICAgICAgdmFyIGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIWJyS2x1ZGdlKSB7XG4gICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYW5jaG9yICE9IGhlYWQpIGRvbVNlbC5leHRlbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgZG9tU2VsRXh0ZW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pKSB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICBpZiAoYW5jaG9yID4gaGVhZCkge1xuICAgICAgICAgIHZhciB0bXAgPSBhbmNob3JET007XG4gICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTTtcbiAgICAgICAgICBoZWFkRE9NID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlTXV0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudExvc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmICF0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrRGlydHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICBmb3IgKHZhciBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PSBlbmQgPyBmcm9tIDw9IGVuZCAmJiB0byA+PSBvZmZzZXQgOiBmcm9tIDwgZW5kICYmIHRvID4gb2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyLFxuICAgICAgICAgICAgICBlbmRJbnNpZGUgPSBlbmQgLSBjaGlsZC5ib3JkZXI7XG5cbiAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmcm9tID09IG9mZnNldCB8fCB0byA9PSBlbmQgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiYgKGNoaWxkLmNvbnRlbnRMb3N0IHx8IGNoaWxkLmRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkpIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtlbHNlIGNoaWxkLm1hcmtEaXJ0eShmcm9tIC0gc3RhcnRJbnNpZGUsIHRvIC0gc3RhcnRJbnNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1BhcmVudHNEaXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgdmFyIGxldmVsID0gMTtcblxuICAgICAgZm9yICh2YXIgbm9kZSA9IHRoaXMucGFyZW50OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQsIGxldmVsKyspIHtcbiAgICAgICAgdmFyIGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSkgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BdG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlnbm9yZUZvckNvb3Jkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWV3RGVzYztcbn0oKTtcblxudmFyIFdpZGdldFZpZXdEZXNjID0gZnVuY3Rpb24gKF9WaWV3RGVzYykge1xuICBfaW5oZXJpdHMoV2lkZ2V0Vmlld0Rlc2MsIF9WaWV3RGVzYyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXaWRnZXRWaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gV2lkZ2V0Vmlld0Rlc2MocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXaWRnZXRWaWV3RGVzYyk7XG5cbiAgICB2YXIgc2VsZixcbiAgICAgICAgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgaWYgKHR5cGVvZiBkb20gPT0gXCJmdW5jdGlvblwiKSBkb20gPSBkb20odmlldywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmKSByZXR1cm4gcG9zO1xuICAgICAgaWYgKHNlbGYucGFyZW50KSByZXR1cm4gc2VsZi5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoc2VsZik7XG4gICAgfSk7XG5cbiAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdmFyIHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgfVxuXG4gICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgIF90aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICBfdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgc2VsZiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaWRnZXRWaWV3RGVzYywgW3tcbiAgICBrZXk6IFwibWF0Y2hlc1dpZGdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0KHdpZGdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSdWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWdub3JlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgcmV0dXJuIHN0b3AgPyBzdG9wKGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZ25vcmVNdXRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlKSwgXCJkZXN0cm95XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUF0b21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaWRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWRnZXQudHlwZS5zaWRlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXaWRnZXRWaWV3RGVzYztcbn0oVmlld0Rlc2MpO1xuXG52YXIgQ29tcG9zaXRpb25WaWV3RGVzYyA9IGZ1bmN0aW9uIChfVmlld0Rlc2MyKSB7XG4gIF9pbmhlcml0cyhDb21wb3NpdGlvblZpZXdEZXNjLCBfVmlld0Rlc2MyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihDb21wb3NpdGlvblZpZXdEZXNjKTtcblxuICBmdW5jdGlvbiBDb21wb3NpdGlvblZpZXdEZXNjKHBhcmVudCwgZG9tLCB0ZXh0RE9NLCB0ZXh0KSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb3NpdGlvblZpZXdEZXNjKTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbCh0aGlzLCBwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgIF90aGlzMi50ZXh0RE9NID0gdGV4dERPTTtcbiAgICBfdGhpczIudGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb21wb3NpdGlvblZpZXdEZXNjLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9jYWxQb3NGcm9tRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCkge1xuICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyAob2Zmc2V0ID8gdGhpcy5zaXplIDogMCk7XG4gICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21Gcm9tUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0aGlzLnRleHRET00sXG4gICAgICAgIG9mZnNldDogcG9zXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZ25vcmVNdXRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgIHJldHVybiBtdXQudHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29tcG9zaXRpb25WaWV3RGVzYztcbn0oVmlld0Rlc2MpO1xuXG52YXIgTWFya1ZpZXdEZXNjID0gZnVuY3Rpb24gKF9WaWV3RGVzYzMpIHtcbiAgX2luaGVyaXRzKE1hcmtWaWV3RGVzYywgX1ZpZXdEZXNjMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoTWFya1ZpZXdEZXNjKTtcblxuICBmdW5jdGlvbiBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtWaWV3RGVzYyk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIzLmNhbGwodGhpcywgcGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICBfdGhpczMubWFyayA9IG1hcms7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXJrVmlld0Rlc2MsIFt7XG4gICAga2V5OiBcInBhcnNlUnVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVJ1bGUoKSB7XG4gICAgICBpZiAodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkgfHwgdGhpcy5tYXJrLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcms6IHRoaXMubWFyay50eXBlLm5hbWUsXG4gICAgICAgIGF0dHJzOiB0aGlzLm1hcmsuYXR0cnMsXG4gICAgICAgIGNvbnRlbnRFbGVtZW50OiB0aGlzLmNvbnRlbnRET00gfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzTWFyayhtYXJrKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHRoaXMubWFyay5lcShtYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0RpcnR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFya1ZpZXdEZXNjLnByb3RvdHlwZSksIFwibWFya0RpcnR5XCIsIHRoaXMpLmNhbGwodGhpcywgZnJvbSwgdG8pO1xuXG4gICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpIHtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICB2YXIgY29weSA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMubWFyaywgdHJ1ZSwgdmlldyk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLFxuICAgICAgICAgIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICBpZiAodG8gPCBzaXplKSBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgdG8sIHNpemUsIHZpZXcpO1xuICAgICAgaWYgKGZyb20gPiAwKSBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgMCwgZnJvbSwgdmlldyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgIH1cblxuICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgdmFyIGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgIHZhciBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShtYXJrLCB2aWV3LCBpbmxpbmUpO1xuICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSkgc3BlYyA9IHByb3NlbWlycm9yTW9kZWwuRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICAgIHJldHVybiBuZXcgTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgc3BlYy5kb20sIHNwZWMuY29udGVudERPTSB8fCBzcGVjLmRvbSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmtWaWV3RGVzYztcbn0oVmlld0Rlc2MpO1xuXG52YXIgTm9kZVZpZXdEZXNjID0gZnVuY3Rpb24gKF9WaWV3RGVzYzQpIHtcbiAgX2luaGVyaXRzKE5vZGVWaWV3RGVzYywgX1ZpZXdEZXNjNCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoTm9kZVZpZXdEZXNjKTtcblxuICBmdW5jdGlvbiBOb2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVWaWV3RGVzYyk7XG5cbiAgICBfdGhpczQgPSBfc3VwZXI0LmNhbGwodGhpcywgcGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICBfdGhpczQubm9kZSA9IG5vZGU7XG4gICAgX3RoaXM0Lm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICBfdGhpczQuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgIF90aGlzNC5ub2RlRE9NID0gbm9kZURPTTtcbiAgICBpZiAoY29udGVudERPTSkgX3RoaXM0LnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyk7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlVmlld0Rlc2MsIFt7XG4gICAga2V5OiBcInBhcnNlUnVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVJ1bGUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMubm9kZS50eXBlLnNwZWMucmVwYXJzZUluVmlldykgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcnVsZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcy5ub2RlLnR5cGUubmFtZSxcbiAgICAgICAgYXR0cnM6IHRoaXMubm9kZS5hdHRyc1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG5cbiAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1Lm5vZGUuY29udGVudDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhjaGlsZC5kb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudCkgcnVsZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc05vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiBub2RlLmVxKHRoaXMubm9kZSkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCxcbiAgICAgICAgICBvZmYgPSBwb3M7XG4gICAgICB2YXIgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICB2YXIgbG9jYWxDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA+IC0xID8gY29tcG9zaXRpb24gOiBudWxsO1xuICAgICAgdmFyIGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICB2YXIgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUpO1xuICAgICAgaXRlckRlY28odGhpcy5ub2RlLCB0aGlzLmlubmVyRGVjbywgZnVuY3Rpb24gKHdpZGdldCwgaSwgaW5zaWRlTm9kZSkge1xuICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpIHVwZGF0ZXIuc3luY1RvTWFya3Mod2lkZ2V0LnNwZWMubWFya3MsIGlubGluZSwgdmlldyk7ZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKSB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gX3RoaXM2Lm5vZGUuY2hpbGRDb3VudCA/IHByb3NlbWlycm9yTW9kZWwuTWFyay5ub25lIDogX3RoaXM2Lm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgIHVwZGF0ZXIucGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBvZmYpO1xuICAgICAgfSwgZnVuY3Rpb24gKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkge1xuICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICB2YXIgY29tcEluZGV4O1xuICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8IG9mZiArIGNoaWxkLm5vZGVTaXplICYmIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJiB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtlbHNlIGlmICh1cGRhdGVyLnVwZGF0ZU5leHROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaSkpIDtlbHNlIHtcbiAgICAgICAgICB1cGRhdGVyLmFkZE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBvZmYpO1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcblxuICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgaWYgKGxvY2FsQ29tcG9zaXRpb24pIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgIHJlbmRlckRlc2NzKHRoaXMuY29udGVudERPTSwgdGhpcy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICAgIGlmIChpb3MpIGlvc0hhY2tzKHRoaXMuZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9jYWxDb21wb3NpdGlvbkluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICB2YXIgX3ZpZXckc3RhdGUkc2VsZWN0aW9uID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgZnJvbSA9IF92aWV3JHN0YXRlJHNlbGVjdGlvbi5mcm9tLFxuICAgICAgICAgIHRvID0gX3ZpZXckc3RhdGUkc2VsZWN0aW9uLnRvO1xuICAgICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgICAgdmFyIHRleHROb2RlID0gbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKSByZXR1cm4gbnVsbDtcblxuICAgICAgaWYgKHRoaXMubm9kZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICB2YXIgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDoge1xuICAgICAgICAgIG5vZGU6IHRleHROb2RlLFxuICAgICAgICAgIHBvczogdGV4dFBvcyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IHRleHROb2RlLFxuICAgICAgICAgIHBvczogLTEsXG4gICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm90ZWN0TG9jYWxDb21wb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCBfcmVmMikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmMi5ub2RlLFxuICAgICAgICAgIHBvcyA9IF9yZWYyLnBvcyxcbiAgICAgICAgICB0ZXh0ID0gX3JlZjIudGV4dDtcbiAgICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpIHJldHVybjtcbiAgICAgIHZhciB0b3BOb2RlID0gbm9kZTtcblxuICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSBicmVhaztcblxuICAgICAgICB3aGlsZSAodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKSB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjID0gbmV3IENvbXBvc2l0aW9uVmlld0Rlc2ModGhpcywgdG9wTm9kZSwgbm9kZSwgdGV4dCk7XG4gICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHwgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU91dGVyRGVjb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKSB7XG4gICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSkgcmV0dXJuO1xuICAgICAgdmFyIG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgdmFyIG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLCBjb21wdXRlT3V0ZXJEZWNvKHRoaXMub3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCksIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCkpO1xuXG4gICAgICBpZiAodGhpcy5kb20gIT0gb2xkRE9NKSB7XG4gICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Tm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSkgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzZWxlY3ROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSkgdGhpcy5kb20ucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BdG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmlzQXRvbTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgdmFyIGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSxcbiAgICAgICAgICBkZXNjT2JqO1xuICAgICAgdmFyIHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkZXNjT2JqKSByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoZGVzY09iai5wYXJlbnQpIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgIHZhciBkb20gPSBzcGVjICYmIHNwZWMuZG9tLFxuICAgICAgICAgIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcblxuICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGlmICghZG9tKSBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO2Vsc2UgaWYgKGRvbS5ub2RlVHlwZSAhPSAzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICB9IGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgdmFyIF9wcm9zZW1pcnJvck1vZGVsJERPTSA9IHByb3NlbWlycm9yTW9kZWwuRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSk7XG5cbiAgICAgICAgZG9tID0gX3Byb3NlbWlycm9yTW9kZWwkRE9NLmRvbTtcbiAgICAgICAgY29udGVudERPTSA9IF9wcm9zZW1pcnJvck1vZGVsJERPTS5jb250ZW50RE9NO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbnRlbnRET00gJiYgIW5vZGUuaXNUZXh0ICYmIGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpIHtcbiAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKSBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKSBkb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVET00gPSBkb207XG4gICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICBpZiAoc3BlYykgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtlbHNlIGlmIChub2RlLmlzVGV4dCkgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KTtlbHNlIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZVZpZXdEZXNjO1xufShWaWV3RGVzYyk7XG5cbmZ1bmN0aW9uIGRvY1ZpZXdEZXNjKGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgdmlldykge1xuICBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgZG9jKTtcbiAgcmV0dXJuIG5ldyBOb2RlVmlld0Rlc2ModW5kZWZpbmVkLCBkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGRvbSwgZG9tLCB2aWV3LCAwKTtcbn1cblxudmFyIFRleHRWaWV3RGVzYyA9IGZ1bmN0aW9uIChfTm9kZVZpZXdEZXNjKSB7XG4gIF9pbmhlcml0cyhUZXh0Vmlld0Rlc2MsIF9Ob2RlVmlld0Rlc2MpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKFRleHRWaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0Vmlld0Rlc2MpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjUuY2FsbCh0aGlzLCBwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG51bGwsIG5vZGVET00sIHZpZXcsIDApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHRWaWV3RGVzYywgW3tcbiAgICBrZXk6IFwicGFyc2VSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUnVsZSgpIHtcbiAgICAgIHZhciBza2lwID0gdGhpcy5ub2RlRE9NLnBhcmVudE5vZGU7XG5cbiAgICAgIHdoaWxlIChza2lwICYmIHNraXAgIT0gdGhpcy5kb20gJiYgIXNraXAucG1Jc0RlY28pIHtcbiAgICAgICAgc2tpcCA9IHNraXAucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2tpcDogc2tpcCB8fCB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8IHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZICYmICF0aGlzLmluUGFyZW50KCkgfHwgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuXG4gICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgICAgaWYgKHZpZXcudHJhY2tXcml0ZXMgPT0gdGhpcy5ub2RlRE9NKSB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5QYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5QYXJlbnQoKSB7XG4gICAgICB2YXIgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcblxuICAgICAgZm9yICh2YXIgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAobiA9PSBwYXJlbnRET00pIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUZyb21Qb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRoaXMubm9kZURPTSxcbiAgICAgICAgb2Zmc2V0OiBwb3NcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsUG9zRnJvbURPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgIGlmIChkb20gPT0gdGhpcy5ub2RlRE9NKSByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLm5vZGUudGV4dC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFRleHRWaWV3RGVzYy5wcm90b3R5cGUpLCBcImxvY2FsUG9zRnJvbURPTVwiLCB0aGlzKS5jYWxsKHRoaXMsIGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlTXV0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwiY2hhcmFjdGVyRGF0YVwiICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksXG4gICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0RpcnR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVGV4dFZpZXdEZXNjLnByb3RvdHlwZSksIFwibWFya0RpcnR5XCIsIHRoaXMpLmNhbGwodGhpcywgZnJvbSwgdG8pO1xuXG4gICAgICBpZiAodGhpcy5kb20gIT0gdGhpcy5ub2RlRE9NICYmIChmcm9tID09IDAgfHwgdG8gPT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZS5sZW5ndGgpKSB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0Vmlld0Rlc2M7XG59KE5vZGVWaWV3RGVzYyk7XG5cbnZhciBUcmFpbGluZ0hhY2tWaWV3RGVzYyA9IGZ1bmN0aW9uIChfVmlld0Rlc2M1KSB7XG4gIF9pbmhlcml0cyhUcmFpbGluZ0hhY2tWaWV3RGVzYywgX1ZpZXdEZXNjNSk7XG5cbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoVHJhaWxpbmdIYWNrVmlld0Rlc2MpO1xuXG4gIGZ1bmN0aW9uIFRyYWlsaW5nSGFja1ZpZXdEZXNjKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFpbGluZ0hhY2tWaWV3RGVzYyk7XG5cbiAgICByZXR1cm4gX3N1cGVyNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYWlsaW5nSGFja1ZpZXdEZXNjLCBbe1xuICAgIGtleTogXCJwYXJzZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSdWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWdub3JlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzSGFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzSGFjayhub2RlTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BdG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlRm9yQ29vcmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb20ubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhaWxpbmdIYWNrVmlld0Rlc2M7XG59KFZpZXdEZXNjKTtcblxudmFyIEN1c3RvbU5vZGVWaWV3RGVzYyA9IGZ1bmN0aW9uIChfTm9kZVZpZXdEZXNjMikge1xuICBfaW5oZXJpdHMoQ3VzdG9tTm9kZVZpZXdEZXNjLCBfTm9kZVZpZXdEZXNjMik7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoQ3VzdG9tTm9kZVZpZXdEZXNjKTtcblxuICBmdW5jdGlvbiBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICB2YXIgX3RoaXM3O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbU5vZGVWaWV3RGVzYyk7XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwodGhpcywgcGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgIF90aGlzNy5zcGVjID0gc3BlYztcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1c3RvbU5vZGVWaWV3RGVzYywgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5zcGVjLnVwZGF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSksIFwidXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3ROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUoKSB7XG4gICAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlKSwgXCJzZWxlY3ROb2RlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2VsZWN0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogX2dldChfZ2V0UHJvdG90eXBlT2YoQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSksIFwiZGVzZWxlY3ROb2RlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSkge1xuICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KSA6IF9nZXQoX2dldFByb3RvdHlwZU9mKEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUpLCBcInNldFNlbGVjdGlvblwiLCB0aGlzKS5jYWxsKHRoaXMsIGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpIHRoaXMuc3BlYy5kZXN0cm95KCk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUpLCBcImRlc3Ryb3lcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZ25vcmVNdXRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlKSwgXCJpZ25vcmVNdXRhdGlvblwiLCB0aGlzKS5jYWxsKHRoaXMsIG11dGF0aW9uKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VzdG9tTm9kZVZpZXdEZXNjO1xufShOb2RlVmlld0Rlc2MpO1xuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gIHZhciBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCxcbiAgICAgIHdyaXR0ZW4gPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2MgPSBkZXNjc1tpXSxcbiAgICAgICAgY2hpbGRET00gPSBkZXNjLmRvbTtcblxuICAgIGlmIChjaGlsZERPTS5wYXJlbnROb2RlID09IHBhcmVudERPTSkge1xuICAgICAgd2hpbGUgKGNoaWxkRE9NICE9IGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgIHBhcmVudERPTS5pbnNlcnRCZWZvcmUoY2hpbGRET00sIGRvbSk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgIHZhciBwb3MgPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogcGFyZW50RE9NLmxhc3RDaGlsZDtcbiAgICAgIHJlbmRlckRlc2NzKGRlc2MuY29udGVudERPTSwgZGVzYy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICBkb20gPSBwb3MgPyBwb3MubmV4dFNpYmxpbmcgOiBwYXJlbnRET00uZmlyc3RDaGlsZDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoZG9tKSB7XG4gICAgZG9tID0gcm0oZG9tKTtcbiAgICB3cml0dGVuID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKSB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cblxudmFyIE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gT3V0ZXJEZWNvTGV2ZWwobm9kZU5hbWUpIHtcbiAgaWYgKG5vZGVOYW1lKSB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuXG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWwoKV07XG5cbmZ1bmN0aW9uIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCBub2RlLCBuZWVkc1dyYXApIHtcbiAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMCkgcmV0dXJuIG5vRGVjbztcbiAgdmFyIHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCgpLFxuICAgICAgcmVzdWx0ID0gW3RvcF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICBpZiAoIWF0dHJzKSBjb250aW51ZTtcbiAgICBpZiAoYXR0cnMubm9kZU5hbWUpIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChhdHRycy5ub2RlTmFtZSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykge1xuICAgICAgdmFyIHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKSByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwobm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIikpO1xuICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiKSB0b3BbXCJjbGFzc1wiXSA9ICh0b3BbXCJjbGFzc1wiXSA/IHRvcFtcImNsYXNzXCJdICsgXCIgXCIgOiBcIlwiKSArIHZhbDtlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIikgdG9wLnN0eWxlID0gKHRvcC5zdHlsZSA/IHRvcC5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWw7ZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpIHRvcFtuYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pIHJldHVybiBub2RlRE9NO1xuICB2YXIgY3VyRE9NID0gbm9kZURPTTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlY28gPSBjdXJDb21wdXRlZFtpXSxcbiAgICAgICAgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcblxuICAgIGlmIChpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdm9pZCAwO1xuXG4gICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICBjdXJET00gPSBwYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRlY28ubm9kZU5hbWUpO1xuICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgcHJldiA9IG5vRGVjb1swXTtcbiAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgfVxuXG4gIHJldHVybiBjdXJET007XG59XG5cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICBmb3IgKHZhciBuYW1lIGluIHByZXYpIHtcbiAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIgJiYgbmFtZSAhPSBcInN0eWxlXCIgJiYgbmFtZSAhPSBcIm5vZGVOYW1lXCIgJiYgIShuYW1lIGluIGN1cikpIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICBmb3IgKHZhciBfbmFtZSBpbiBjdXIpIHtcbiAgICBpZiAoX25hbWUgIT0gXCJjbGFzc1wiICYmIF9uYW1lICE9IFwic3R5bGVcIiAmJiBfbmFtZSAhPSBcIm5vZGVOYW1lXCIgJiYgY3VyW19uYW1lXSAhPSBwcmV2W19uYW1lXSkgZG9tLnNldEF0dHJpYnV0ZShfbmFtZSwgY3VyW19uYW1lXSk7XG4gIH1cblxuICBpZiAocHJldltcImNsYXNzXCJdICE9IGN1cltcImNsYXNzXCJdKSB7XG4gICAgdmFyIHByZXZMaXN0ID0gcHJldltcImNsYXNzXCJdID8gcHJldltcImNsYXNzXCJdLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICB2YXIgY3VyTGlzdCA9IGN1cltcImNsYXNzXCJdID8gY3VyW1wiY2xhc3NcIl0uc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGN1ckxpc3QuaW5kZXhPZihwcmV2TGlzdFtpXSkgPT0gLTEpIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY3VyTGlzdC5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbX2ldKSA9PSAtMSkgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtfaV0pO1xuICAgIH1cblxuICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKSBkb20ucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH1cblxuICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICBpZiAocHJldi5zdHlsZSkge1xuICAgICAgdmFyIHByb3AgPSAvXFxzKihbXFx3XFwtXFx4YTEtXFx1ZmZmZl0rKVxccyo6KD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8Jyg/OlxcXFwufFteJ10pKid8XFwoLio/XFwpfFteO10pKi9nLFxuICAgICAgICAgIG07XG5cbiAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKSB7XG4gICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VyLnN0eWxlKSBkb20uc3R5bGUuY3NzVGV4dCArPSBjdXIuc3R5bGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlPdXRlckRlY28oZG9tLCBkZWNvLCBub2RlKSB7XG4gIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5cbmZ1bmN0aW9uIHNhbWVPdXRlckRlY28oYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gIHZhciBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIFZpZXdUcmVlVXBkYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlld1RyZWVVcGRhdGVyKHRvcCwgbG9jaykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3VHJlZVVwZGF0ZXIpO1xuXG4gICAgdGhpcy5sb2NrID0gbG9jaztcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlld1RyZWVVcGRhdGVyLCBbe1xuICAgIGtleTogXCJkZXN0cm95QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95QmV0d2VlbihzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoc3RhcnQgPT0gZW5kKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95UmVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95UmVzdCgpIHtcbiAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3luY1RvTWFya3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgdmFyIGtlZXAgPSAwLFxuICAgICAgICAgIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgIHZhciBtYXhLZWVwID0gTWF0aC5taW4oZGVwdGgsIG1hcmtzLmxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChrZWVwIDwgbWF4S2VlcCAmJiAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tba2VlcCArIDEgPDwgMV0pLm1hdGNoZXNNYXJrKG1hcmtzW2tlZXBdKSAmJiBtYXJrc1trZWVwXS50eXBlLnNwZWMuc3Bhbm5pbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIGtlZXArKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lSZXN0KCk7XG4gICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoZGVwdGggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgIHZhciBmb3VuZCA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXS5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kTm9kZU1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlTWF0Y2gobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGluZGV4KSB7XG4gICAgICB2YXIgZm91bmQgPSAtMSxcbiAgICAgICAgICB0YXJnZXREZXNjO1xuXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wcmVNYXRjaC5pbmRleCAmJiAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiYgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgZm91bmQgPSB0aGlzLnRvcC5jaGlsZHJlbi5pbmRleE9mKHRhcmdldERlc2MsIHRoaXMuaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXgsIGUgPSBNYXRoLm1pbih0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgsIGkgKyA1KTsgaSA8IGU7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVOb2RlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgaWYgKGNoaWxkLmRpcnR5ID09IE5PREVfRElSVFkgJiYgY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00pIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgIGlmICghY2hpbGQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpbmRleCk7XG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRJbmRleFdpdGhDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIC0xO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgIHZhciBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgIGlmIChkZXNjKSBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYykgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5leHROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5leHROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpbmRleCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgdmFyIF9wcmVNYXRjaCA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlZC5nZXQobmV4dCk7XG5cbiAgICAgICAgICBpZiAoX3ByZU1hdGNoICE9IG51bGwgJiYgX3ByZU1hdGNoICE9IGluZGV4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgdmFyIG5leHRET00gPSBuZXh0LmRvbTtcbiAgICAgICAgICB2YXIgbG9ja2VkID0gdGhpcy5sb2NrICYmIChuZXh0RE9NID09IHRoaXMubG9jayB8fCBuZXh0RE9NLm5vZGVUeXBlID09IDEgJiYgbmV4dERPTS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpICYmICEobm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlICYmIG5leHQubm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlRE9NLm5vZGVWYWx1ZSA9PSBub2RlLnRleHQgJiYgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuXG4gICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKG5leHQuZG9tICE9IG5leHRET00pIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSk7XG4gICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZVdpZGdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmluZGV4IDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gOiBudWxsO1xuXG4gICAgICBpZiAobmV4dCAmJiBuZXh0Lm1hdGNoZXNXaWRnZXQod2lkZ2V0KSAmJiAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUZXh0YmxvY2tIYWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sXG4gICAgICAgICAgcGFyZW50ID0gdGhpcy50b3A7XG5cbiAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgcGFyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxhc3RDaGlsZCB8fCAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHwgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpIHtcbiAgICAgICAgaWYgKChzYWZhcmkgfHwgY2hyb21lKSAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJCUlwiLCB0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEhhY2tOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG5cbiAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIjtcbiAgICAgICAgdmFyIGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKSBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtlbHNlIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlld1RyZWVVcGRhdGVyO1xufSgpO1xuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gIHZhciBjdXJEZXNjID0gcGFyZW50RGVzYyxcbiAgICAgIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gIHZhciBmSSA9IGZyYWcuY2hpbGRDb3VudCxcbiAgICAgIG1hdGNoZWQgPSBuZXcgTWFwKCksXG4gICAgICBtYXRjaGVzID0gW107XG5cbiAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICB2YXIgZGVzYyA9IHZvaWQgMDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICB2YXIgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcblxuICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNjSSA9IGN1ckRlc2MucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY3VyRGVzYyk7XG4gICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSkgYnJlYWs7XG4gICAgLS1mSTtcbiAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgbWF0Y2hlcy5wdXNoKGRlc2MpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbmRleDogZkksXG4gICAgbWF0Y2hlZDogbWF0Y2hlZCxcbiAgICBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgdmFyIGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksXG4gICAgICBvZmZzZXQgPSAwO1xuXG4gIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGVjb0luZGV4ID0gMCxcbiAgICAgIGFjdGl2ZSA9IFtdLFxuICAgICAgcmVzdE5vZGUgPSBudWxsO1xuXG4gIGZvciAodmFyIHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkZ2V0ID0gbG9jYWxzW2RlY29JbmRleCsrXSxcbiAgICAgICAgICB3aWRnZXRzID0gdm9pZCAwO1xuXG4gICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aWRnZXRzKSB7XG4gICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgd2lkZ2V0cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tfaTJdLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uV2lkZ2V0KHdpZGdldCwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfY2hpbGQgPSB2b2lkIDAsXG4gICAgICAgIGluZGV4ID0gdm9pZCAwO1xuXG4gICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgX2NoaWxkID0gcmVzdE5vZGU7XG4gICAgICByZXN0Tm9kZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgX2NoaWxkID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBhY3RpdmUubGVuZ3RoOyBfaTMrKykge1xuICAgICAgaWYgKGFjdGl2ZVtfaTNdLnRvIDw9IG9mZnNldCkgYWN0aXZlLnNwbGljZShfaTMtLSwgMSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpIHtcbiAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBvZmZzZXQgKyBfY2hpbGQubm9kZVNpemU7XG5cbiAgICBpZiAoX2NoaWxkLmlzVGV4dCkge1xuICAgICAgdmFyIGN1dEF0ID0gZW5kO1xuICAgICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8IGN1dEF0KSBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGFjdGl2ZS5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIGlmIChhY3RpdmVbX2k0XS50byA8IGN1dEF0KSBjdXRBdCA9IGFjdGl2ZVtfaTRdLnRvO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3V0QXQgPCBlbmQpIHtcbiAgICAgICAgcmVzdE5vZGUgPSBfY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgIGVuZCA9IGN1dEF0O1xuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvdXRlckRlY28gPSBfY2hpbGQuaXNJbmxpbmUgJiYgIV9jaGlsZC5pc0xlYWYgPyBhY3RpdmUuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gIWQuaW5saW5lO1xuICAgIH0pIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgb25Ob2RlKF9jaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgX2NoaWxkKSwgaW5kZXgpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpb3NIYWNrcyhkb20pIHtcbiAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgIHZhciBvbGRDU1MgPSBkb20uc3R5bGUuY3NzVGV4dDtcbiAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCkge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykgcmV0dXJuIG5vZGU7XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gb2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLm5vZGVUeXBlID09IDMpIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFRleHRJbkZyYWdtZW50KGZyYWcsIHRleHQsIGZyb20sIHRvKSB7XG4gIGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBpIDwgZnJhZy5jaGlsZENvdW50ICYmIHBvcyA8PSB0bzspIHtcbiAgICB2YXIgY2hpbGQgPSBmcmFnLmNoaWxkKGkrKyksXG4gICAgICAgIGNoaWxkU3RhcnQgPSBwb3M7XG4gICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIGlmICghY2hpbGQuaXNUZXh0KSBjb250aW51ZTtcbiAgICB2YXIgc3RyID0gY2hpbGQudGV4dDtcblxuICAgIHdoaWxlIChpIDwgZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICB2YXIgbmV4dCA9IGZyYWcuY2hpbGQoaSsrKTtcbiAgICAgIHBvcyArPSBuZXh0Lm5vZGVTaXplO1xuICAgICAgaWYgKCFuZXh0LmlzVGV4dCkgYnJlYWs7XG4gICAgICBzdHIgKz0gbmV4dC50ZXh0O1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgdmFyIGZvdW5kID0gY2hpbGRTdGFydCA8IHRvID8gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCAtIDEpIDogLTE7XG4gICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKSByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSB0byArIHRleHQubGVuZ3RoIC0gY2hpbGRTdGFydCAmJiBzdHIuc2xpY2UodG8gLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQgKyB0ZXh0Lmxlbmd0aCkgPT0gdGV4dCkgcmV0dXJuIHRvO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBub2Rlc1tpXSxcbiAgICAgICAgc3RhcnQgPSBvZmYsXG4gICAgICAgIGVuZCA9IG9mZiArPSBjaGlsZC5zaXplO1xuXG4gICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydCA8IGZyb20pIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuXG4gICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA+IHRvKSByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSB7XG4gIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpLFxuICAgICAgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gIGlmICghZG9tU2VsLmZvY3VzTm9kZSkgcmV0dXJuIG51bGw7XG4gIHZhciBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSxcbiAgICAgIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICB2YXIgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgMSk7XG4gIGlmIChoZWFkIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLFxuICAgICAgJGFuY2hvcixcbiAgICAgIHNlbGVjdGlvbjtcblxuICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAkYW5jaG9yID0gJGhlYWQ7XG5cbiAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpIHtcbiAgICAgIG5lYXJlc3REZXNjID0gbmVhcmVzdERlc2MucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuXG4gICAgaWYgKG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjTm9kZS5pc0F0b20gJiYgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudCAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICB2YXIgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgc2VsZWN0aW9uID0gbmV3IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbihoZWFkID09IHBvcyA/ICRoZWFkIDogZG9jLnJlc29sdmUocG9zKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBhbmNob3IgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgMSk7XG4gICAgaWYgKGFuY2hvciA8IDApIHJldHVybiBudWxsO1xuICAgICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICB9XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICB2YXIgYmlhcyA9IG9yaWdpbiA9PSBcInBvaW50ZXJcIiB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCA/IDEgOiAtMTtcbiAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6IGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSB7XG4gIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpKSByZXR1cm47XG5cbiAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgdmFyIGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksXG4gICAgICAgIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcblxuICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuXG4gIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmNob3IgPSBzZWwuYW5jaG9yLFxuICAgICAgICBoZWFkID0gc2VsLmhlYWQsXG4gICAgICAgIHJlc2V0RWRpdGFibGVGcm9tLFxuICAgICAgICByZXNldEVkaXRhYmxlVG87XG5cbiAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgIH1cblxuICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcblxuICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSkge1xuICAgICAgaWYgKHJlc2V0RWRpdGFibGVGcm9tKSByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgfVxuICB9XG5cbiAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgdmlldy5kb21PYnNlcnZlci5jb25uZWN0U2VsZWN0aW9uKCk7XG59XG5cbnZhciBicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSA9IHNhZmFyaSB8fCBjaHJvbWUgJiYgY2hyb21lX3ZlcnNpb24gPCA2MztcblxuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gIHZhciBfdmlldyRkb2NWaWV3JGRvbUZyb20zID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKSxcbiAgICAgIG5vZGUgPSBfdmlldyRkb2NWaWV3JGRvbUZyb20zLm5vZGUsXG4gICAgICBvZmZzZXQgPSBfdmlldyRkb2NWaWV3JGRvbUZyb20zLm9mZnNldDtcblxuICB2YXIgYWZ0ZXIgPSBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0gOiBudWxsO1xuICB2YXIgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuXG4gIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgIGlmIChhZnRlcikgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtlbHNlIGlmIChiZWZvcmUpIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcblxuICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gcmVzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuXG4gIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gIHZhciBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICB2YXIgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLFxuICAgICAgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSkgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICB9LCAyMCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpLFxuICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICB2YXIgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sXG4gICAgICBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gIGlmIChpbWcpIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIGRvbUluZGV4KG5vZGUpICsgMSk7ZWxzZSByYW5nZS5zZXRFbmQobm9kZSwgMCk7XG4gIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuXG4gIGlmICghaW1nICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmIGllICYmIGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHtcbiAgICB2YXIgZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQoc2VsLmZyb20pO1xuXG4gICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgaWYgKGRlc2MpIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhck5vZGVTZWxlY3Rpb24odmlldykge1xuICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLnBhcmVudCkgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywgJGFuY2hvciwgJGhlYWQpO1xuICB9KSB8fCBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgaWYgKHZpZXcuZWRpdGFibGUgJiYgdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5kb20pIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKHZpZXcpIHtcbiAgdmFyIHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gIGlmICghc2VsLmFuY2hvck5vZGUpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJiAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgdmFyIGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkYW5jaG9yID0gX3N0YXRlJHNlbGVjdGlvbi4kYW5jaG9yLFxuICAgICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uLiRoZWFkO1xuICB2YXIgJHNpZGUgPSBkaXIgPiAwID8gJGFuY2hvci5tYXgoJGhlYWQpIDogJGFuY2hvci5taW4oJGhlYWQpO1xuICB2YXIgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgcmV0dXJuICRzdGFydCAmJiBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5cbmZ1bmN0aW9uIGFwcGx5KHZpZXcsIHNlbCkge1xuICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcblxuICBpZiAoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIikpIHtcbiAgICAgIHZhciBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICBpZiAobmV4dCAmJiBuZXh0IGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uKSByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICB2YXIgJGhlYWQgPSBzZWwuJGhlYWQsXG4gICAgICAgICAgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsXG4gICAgICAgICAgZGVzYztcbiAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpO1xuICAgICAgfSBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbihkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuXG4gICAgaWYgKF9uZXh0KSByZXR1cm4gYXBwbHkodmlldywgX25leHQpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGlzSWdub3JhYmxlKGRvbSkge1xuICB2YXIgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICByZXR1cm4gZGVzYyAmJiBkZXNjLnNpemUgPT0gMCAmJiAoZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzTGVmdCh2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICB2YXIgbm9kZSA9IHNlbC5mb2N1c05vZGUsXG4gICAgICBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICB2YXIgbW92ZU5vZGUsXG4gICAgICBtb3ZlT2Zmc2V0LFxuICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdKSkgZm9yY2UgPSB0cnVlO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG5cbiAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSkpIHtcbiAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcblxuICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldikpIHtcbiAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pIGJyZWFrO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvcmNlKSBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG5vZGUsIG9mZnNldCk7ZWxzZSBpZiAobW92ZU5vZGUpIHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldykge1xuICB2YXIgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgdmFyIG5vZGUgPSBzZWwuZm9jdXNOb2RlLFxuICAgICAgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgdmFyIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gIHZhciBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkgYnJlYWs7XG4gICAgICB2YXIgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcblxuICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyKSkge1xuICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuXG4gICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0KSkge1xuICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmV4dCkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSkgYnJlYWs7XG4gICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobW92ZU5vZGUpIHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgdmFyIGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuXG5mdW5jdGlvbiBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG5vZGUsIG9mZnNldCkge1xuICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gIH0gZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgfVxuXG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKSBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgfSwgNTApO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHJldHVybiBmYWxzZTtcbiAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpIHJldHVybiBmYWxzZTtcbiAgdmFyICRmcm9tID0gc2VsLiRmcm9tLFxuICAgICAgJHRvID0gc2VsLiR0bztcblxuICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyIDwgMCA/IFwidXBcIiA6IFwiZG93blwiKSkge1xuICAgIHZhciBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgaWYgKG5leHQgJiYgbmV4dCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbikgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICB9XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgIHZhciBzaWRlID0gZGlyIDwgMCA/ICRmcm9tIDogJHRvO1xuICAgIHZhciBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbiA/IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSkgcmV0dXJuIHRydWU7XG4gIHZhciBfdmlldyRzdGF0ZSRzZWxlY3Rpb24yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkaGVhZCA9IF92aWV3JHN0YXRlJHNlbGVjdGlvbjIuJGhlYWQsXG4gICAgICAkYW5jaG9yID0gX3ZpZXckc3RhdGUkc2VsZWN0aW9uMi4kYW5jaG9yLFxuICAgICAgZW1wdHkgPSBfdmlldyRzdGF0ZSRzZWxlY3Rpb24yLmVtcHR5O1xuICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHJldHVybiB0cnVlO1xuICBpZiAoIWVtcHR5KSByZXR1cm4gZmFsc2U7XG4gIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHJldHVybiB0cnVlO1xuICB2YXIgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuXG4gIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgdmFyIHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAoZGlyIDwgMCkgdHJbXCJkZWxldGVcIl0oJGhlYWQucG9zIC0gbmV4dE5vZGUubm9kZVNpemUsICRoZWFkLnBvcyk7ZWxzZSB0cltcImRlbGV0ZVwiXSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gIG5vZGUuY29udGVudEVkaXRhYmxlID0gc3RhdGU7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cblxuZnVuY3Rpb24gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHtcbiAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBfdmlldyRkb21TZWxlY3Rpb24gPSB2aWV3LmRvbVNlbGVjdGlvbigpLFxuICAgICAgZm9jdXNOb2RlID0gX3ZpZXckZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gX3ZpZXckZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgdmFyIGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKTtcbiAgICB9LCAyMCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGlmIChldmVudC5jdHJsS2V5KSByZXN1bHQgKz0gXCJjXCI7XG4gIGlmIChldmVudC5tZXRhS2V5KSByZXN1bHQgKz0gXCJtXCI7XG4gIGlmIChldmVudC5hbHRLZXkpIHJlc3VsdCArPSBcImFcIjtcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5KSByZXN1bHQgKz0gXCJzXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gIHZhciBjb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcblxuICBpZiAoY29kZSA9PSA4IHx8IG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpIHtcbiAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gNDYgfHwgbWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikge1xuICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldyk7XG4gIH0gZWxzZSBpZiAoY29kZSA9PSAxMyB8fCBjb2RlID09IDI3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoY29kZSA9PSAzNyB8fCBtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSB7XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc0xlZnQodmlldyk7XG4gIH0gZWxzZSBpZiAoY29kZSA9PSAzOSB8fCBtYWMgJiYgY29kZSA9PSA3MCAmJiBtb2RzID09IFwiY1wiKSB7XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldyk7XG4gIH0gZWxzZSBpZiAoY29kZSA9PSAzOCB8fCBtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSB7XG4gICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgbWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikge1xuICAgIHJldHVybiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykgfHwgc2VsZWN0VmVydGljYWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldyk7XG4gIH0gZWxzZSBpZiAobW9kcyA9PSAobWFjID8gXCJtXCIgOiBcImNcIikgJiYgKGNvZGUgPT0gNjYgfHwgY29kZSA9PSA3MyB8fCBjb2RlID09IDg5IHx8IGNvZGUgPT0gOTApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICB2YXIgY29udGV4dCA9IFtdLFxuICAgICAgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsXG4gICAgICBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQsXG4gICAgICBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcblxuICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgb3BlblN0YXJ0LS07XG4gICAgb3BlbkVuZC0tO1xuICAgIHZhciBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgIGNvbnRleHQucHVzaChub2RlLnR5cGUubmFtZSwgbm9kZS5hdHRycyAhPSBub2RlLnR5cGUuZGVmYXVsdEF0dHJzID8gbm9kZS5hdHRycyA6IG51bGwpO1xuICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRTZXJpYWxpemVyXCIpIHx8IHByb3NlbWlycm9yTW9kZWwuRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgdmFyIGRvYyA9IGRldGFjaGVkRG9jKCksXG4gICAgICB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHdyYXAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudChjb250ZW50LCB7XG4gICAgZG9jdW1lbnQ6IGRvY1xuICB9KSk7XG4gIHZhciBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkLFxuICAgICAgbmVlZHNXcmFwLFxuICAgICAgd3JhcHBlcnMgPSAwO1xuXG4gIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgIGZvciAodmFyIGkgPSBuZWVkc1dyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3cmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQobmVlZHNXcmFwW2ldKTtcblxuICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZCkge1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICB3cmFwcGVycysrO1xuICAgIH1cblxuICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEpIGZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiLCBcIlwiLmNvbmNhdChvcGVuU3RhcnQsIFwiIFwiKS5jb25jYXQob3BlbkVuZCkuY29uY2F0KHdyYXBwZXJzID8gXCIgLVwiLmNvbmNhdCh3cmFwcGVycykgOiBcIlwiLCBcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGNvbnRleHQpKSk7XG4gIHZhciB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoc2xpY2UpO1xuICB9KSB8fCBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgXCJcXG5cXG5cIik7XG4gIHJldHVybiB7XG4gICAgZG9tOiB3cmFwLFxuICAgIHRleHQ6IHRleHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgdmFyIGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgdmFyIGRvbSwgc2xpY2U7XG4gIGlmICghaHRtbCAmJiAhdGV4dCkgcmV0dXJuIG51bGw7XG4gIHZhciBhc1RleHQgPSB0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcblxuICBpZiAoYXNUZXh0KSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgIHRleHQgPSBmKHRleHQsIGluQ29kZSB8fCBwbGFpblRleHQpO1xuICAgIH0pO1xuICAgIGlmIChpbkNvZGUpIHJldHVybiB0ZXh0ID8gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgICB2YXIgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICB2YXIgc2NoZW1hID0gdmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgc2VyaWFsaXplciA9IHByb3NlbWlycm9yTW9kZWwuRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgaWYgKGJsb2NrKSBwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplTm9kZShzY2hlbWEudGV4dChibG9jaywgbWFya3MpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZEhUTUxcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgIGh0bWwgPSBmKGh0bWwpO1xuICAgIH0pO1xuICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgIGlmICh3ZWJraXQpIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICB9XG5cbiAgdmFyIGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICB2YXIgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKSBmb3IgKHZhciBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDAgJiYgZG9tLmZpcnN0Q2hpbGQ7IGktLSkge1xuICAgIGRvbSA9IGRvbS5maXJzdENoaWxkO1xuICB9XG5cbiAgaWYgKCFzbGljZSkge1xuICAgIHZhciBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgcHJvc2VtaXJyb3JNb2RlbC5ET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgIHJ1bGVGcm9tTm9kZTogZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSByZXR1cm4ge1xuICAgICAgICAgIGlnbm9yZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzbGljZURhdGEpIHtcbiAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgc2xpY2UgPSBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcblxuICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgdmFyIG9wZW5TdGFydCA9IDAsXG4gICAgICAgICAgb3BlbkVuZCA9IDA7XG5cbiAgICAgIGZvciAodmFyIG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkge31cblxuICAgICAgZm9yICh2YXIgX25vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIV9ub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5FbmQrKywgX25vZGUgPSBfbm9kZS5sYXN0Q2hpbGQpIHt9XG5cbiAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gIH1cblxuICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgc2xpY2UgPSBmKHNsaWNlKTtcbiAgfSk7XG4gIHJldHVybiBzbGljZTtcbn1cblxudmFyIGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpIHJldHVybiBmcmFnbWVudDtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChkKSB7XG4gICAgdmFyIHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgdmFyIG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICB2YXIgbGFzdFdyYXAgPSB2b2lkIDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGZyYWdtZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XG4gICAgICB2YXIgd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpLFxuICAgICAgICAgIGluTGFzdDtcbiAgICAgIGlmICghd3JhcCkgcmV0dXJuIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBpbkxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh3cmFwcGVkLnR5cGUpO1xuICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHtcbiAgICAgIHY6IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShyZXN1bHQpXG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIF9yZXQgPSBfbG9vcChkKTtcblxuICAgIGlmIChfdHlwZW9mKF9yZXQpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCkge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICBmb3IgKHZhciBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IGZyb207IGktLSkge1xuICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obm9kZSkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgdmFyIGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICBpZiAoaW5uZXIpIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgIHZhciBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPT0gMCkgcmV0dXJuIG5vZGU7XG4gIHZhciBmcmFnbWVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQobm9kZS5jaGlsZENvdW50IC0gMSwgY2xvc2VSaWdodChub2RlLmxhc3RDaGlsZCwgZGVwdGggLSAxKSk7XG4gIHZhciBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VSYW5nZShmcmFnbWVudCwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoLCBvcGVuRW5kKSB7XG4gIHZhciBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLFxuICAgICAgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gIGlmIChkZXB0aCA8IHRvIC0gMSkgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgaWYgKGRlcHRoID49IGZyb20pIGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIGZyYWdtZW50LmNoaWxkQ291bnQgPiAxIHx8IG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcikgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgcmV0dXJuIHNsaWNlO1xufVxuXG52YXIgd3JhcE1hcCA9IHtcbiAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICB0Ym9keTogW1widGFibGVcIl0sXG4gIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcbnZhciBfZGV0YWNoZWREb2MgPSBudWxsO1xuXG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpO1xufVxuXG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gIHZhciBtZXRhcyA9IC9eKFxccyo8bWV0YSBbXj5dKj4pKi8uZXhlYyhodG1sKTtcbiAgaWYgKG1ldGFzKSBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICB2YXIgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB2YXIgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksXG4gICAgICB3cmFwO1xuICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pIGh0bWwgPSB3cmFwLm1hcChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIjxcIiArIG4gKyBcIj5cIjtcbiAgfSkuam9pbihcIlwiKSArIGh0bWwgKyB3cmFwLm1hcChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIjwvXCIgKyBuICsgXCI+XCI7XG4gIH0pLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICBlbHQuaW5uZXJIVE1MID0gaHRtbDtcbiAgaWYgKHdyYXApIGZvciAodmFyIGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKykge1xuICAgIGVsdCA9IGVsdC5xdWVyeVNlbGVjdG9yKHdyYXBbaV0pIHx8IGVsdDtcbiAgfVxuICByZXR1cm4gZWx0O1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKSB7XG4gIHZhciBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxceEEwXCIgJiYgbm9kZS5wYXJlbnROb2RlKSBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICBpZiAoIXNsaWNlLnNpemUpIHJldHVybiBzbGljZTtcbiAgdmFyIHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSxcbiAgICAgIGFycmF5O1xuXG4gIHRyeSB7XG4gICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LFxuICAgICAgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0LFxuICAgICAgb3BlbkVuZCA9IHNsaWNlLm9wZW5FbmQ7XG5cbiAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgYnJlYWs7XG4gICAgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICBvcGVuU3RhcnQrKztcbiAgICBvcGVuRW5kKys7XG4gIH1cblxuICByZXR1cm4gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxudmFyIGhhbmRsZXJzID0ge307XG52YXIgZWRpdEhhbmRsZXJzID0ge307XG5cbnZhciBJbnB1dFN0YXRlID0gX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIElucHV0U3RhdGUoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dFN0YXRlKTtcblxuICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gIHRoaXMubW91c2VEb3duID0gbnVsbDtcbiAgdGhpcy5sYXN0S2V5Q29kZSA9IG51bGw7XG4gIHRoaXMubGFzdEtleUNvZGVUaW1lID0gMDtcbiAgdGhpcy5sYXN0Q2xpY2sgPSB7XG4gICAgdGltZTogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgdHlwZTogXCJcIlxuICB9O1xuICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICB0aGlzLmxhc3RBbmRyb2lkRGVsZXRlID0gMDtcbiAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gIHRoaXMuZG9tQ2hhbmdlQ291bnQgPSAwO1xuICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLmhpZGVTZWxlY3Rpb25HdWFyZCA9IG51bGw7XG59KTtcblxuZnVuY3Rpb24gaW5pdElucHV0KHZpZXcpIHtcbiAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihldmVudCkge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgX2xvb3AyKGV2ZW50KTtcbiAgfVxuXG4gIGlmIChzYWZhcmkpIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG5cbiAgZm9yICh2YXIgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpIHtcbiAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSk7XG4gIH1cblxuICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBmdW5jdGlvbiAoY3VycmVudEhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpIHtcbiAgICAgIGlmICghdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKSB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGZ1bmN0aW9uIChoYW5kbGVycykge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpIHtcbiAgaWYgKCFldmVudC5idWJibGVzKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgbm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJiAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cblxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSBmdW5jdGlvbiAodmlldywgX2V2ZW50KSB7XG4gIHZhciBldmVudCA9IF9ldmVudDtcbiAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LmtleUNvZGUgPT0gMTYgfHwgZXZlbnQuc2hpZnRLZXk7XG4gIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSkgcmV0dXJuO1xuICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgZXZlbnQua2V5Q29kZSA9PSAxMykgcmV0dXJuO1xuICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuXG4gIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSBub3c7XG4gICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfSBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGV2ZW50KTtcbiAgfSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gIH1cbn07XG5cbmVkaXRIYW5kbGVycy5rZXl1cCA9IGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNikgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcblxuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8IG1hYyAmJiBldmVudC5tZXRhS2V5KSByZXR1cm47XG5cbiAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlQcmVzc1wiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGV2ZW50KTtcbiAgfSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcblxuICBpZiAoIShzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgIHZhciB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgaWYgKCF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZih2aWV3LCBzZWwuJGZyb20ucG9zLCBzZWwuJHRvLnBvcywgdGV4dCk7XG4gICAgfSkpIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV2ZW50Q29vcmRzKGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZXZlbnQuY2xpZW50WCxcbiAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICB2YXIgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCxcbiAgICAgIGR5ID0gY2xpY2sueSAtIGV2ZW50LmNsaWVudFk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cblxuZnVuY3Rpb24gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBwcm9wTmFtZSwgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gIGlmIChpbnNpZGUgPT0gLTEpIHJldHVybiBmYWxzZTtcbiAgdmFyICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG5cbiAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhpKSB7XG4gICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSkgOiBmKHZpZXcsIHBvcywgJHBvcy5ub2RlKGkpLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIGZhbHNlKTtcbiAgICB9KSkgcmV0dXJuIHtcbiAgICAgIHY6IHRydWVcbiAgICB9O1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciBfcmV0MiA9IF9sb29wMyhpKTtcblxuICAgIGlmIChfdHlwZW9mKF9yZXQyKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICBpZiAoIXZpZXcuZm9jdXNlZCkgdmlldy5mb2N1cygpO1xuICB2YXIgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKSB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICBpZiAoaW5zaWRlID09IC0xKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLFxuICAgICAgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuXG4gIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgbmV3IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBzZWxlY3RlZE5vZGUsXG4gICAgICBzZWxlY3RBdDtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbikgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gIHZhciAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuXG4gIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcblxuICAgIGlmIChwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiYgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcykgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO2Vsc2Ugc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHwgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywgcG9zLCBldmVudCk7XG4gIH0pIHx8IChzZWxlY3ROb2RlID8gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSA6IHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHwgdmlldy5zb21lUHJvcChcImhhbmRsZURvdWJsZUNsaWNrXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywgcG9zLCBldmVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHwgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywgcG9zLCBldmVudCk7XG4gIH0pIHx8IGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkb2MgPSB2aWV3LnN0YXRlLmRvYztcblxuICBpZiAoaW5zaWRlID09IC0xKSB7XG4gICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG5cbiAgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgIHZhciBub2RlUG9zID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCkgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtlbHNlIGlmIChwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB1cGRhdGVTZWxlY3Rpb24odmlldywgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7ZWxzZSBjb250aW51ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xufVxuXG52YXIgc2VsZWN0Tm9kZU1vZGlmaWVyID0gbWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMubW91c2Vkb3duID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgdmFyIGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG5cbiAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0pIHtcbiAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7ZWxzZSBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcImRvdWJsZUNsaWNrXCIpIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gIH1cblxuICB2aWV3LmlucHV0Lmxhc3RDbGljayA9IHtcbiAgICB0aW1lOiBub3csXG4gICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICB5OiBldmVudC5jbGllbnRZLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbiAgdmFyIHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgaWYgKCFwb3MpIHJldHVybjtcblxuICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pIHZpZXcuaW5wdXQubW91c2VEb3duLmRvbmUoKTtcbiAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgfSBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gIH1cbn07XG5cbnZhciBNb3VzZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VEb3duKTtcblxuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgdmFyIHRhcmdldE5vZGUsIHRhcmdldFBvcztcblxuICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcyk7XG4gICAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgICB0YXJnZXRQb3MgPSAkcG9zLmRlcHRoID8gJHBvcy5iZWZvcmUoKSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgIHZhciB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcbiAgICB2YXIgc2VsZWN0aW9uID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZSB8fCBzZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZyb20gPD0gdGFyZ2V0UG9zICYmIHNlbGVjdGlvbi50byA+IHRhcmdldFBvcykgdGhpcy5taWdodERyYWcgPSB7XG4gICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICBhZGRBdHRyOiAhISh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZHJhZ2dhYmxlKSxcbiAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAodGhpcy5taWdodERyYWcuYWRkQXR0ciB8fCB0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSkge1xuICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKSB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM4LnZpZXcuaW5wdXQubW91c2VEb3duID09IF90aGlzOCkgX3RoaXM4LnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgIH0sIDIwKTtcbiAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cblxuICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb3VzZURvd24sIFt7XG4gICAga2V5OiBcImRvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcblxuICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKSB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYykgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTShfdGhpczkudmlldyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cChldmVudCkge1xuICAgICAgdGhpcy5kb25lKCk7XG4gICAgICBpZiAoIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgIT0gdGhpcy5zdGFydERvYykgcG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG5cbiAgICAgIGlmICh0aGlzLmFsbG93RGVmYXVsdCB8fCAhcG9zKSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5idXR0b24gPT0gMCAmJiAodGhpcy5mbHVzaGVkIHx8IHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20gfHwgY2hyb21lICYmICEodGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbikgJiYgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHRoaXMudmlldywgcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8IE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgIGlmIChldmVudC5idXR0b25zID09IDApIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb3VzZURvd247XG59KCk7XG5cbmhhbmRsZXJzLnRvdWNoZG93biA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIGZvcmNlRE9NRmx1c2godmlldyk7XG4gIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuXG5oYW5kbGVycy5jb250ZXh0bWVudSA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIHJldHVybiBmb3JjZURPTUZsdXNoKHZpZXcpO1xufTtcblxuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICBpZiAodmlldy5jb21wb3NpbmcpIHJldHVybiB0cnVlO1xuXG4gIGlmIChzYWZhcmkgJiYgTWF0aC5hYnMoZXZlbnQudGltZVN0YW1wIC0gdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQpIDwgNTAwKSB7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcblxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBlZGl0SGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSBmdW5jdGlvbiAodmlldykge1xuICBpZiAoIXZpZXcuY29tcG9zaW5nKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5mbHVzaCgpO1xuICAgIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGUsXG4gICAgICAgICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG5cbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZTtcbiAgICB9KSkpIHtcbiAgICAgIHZpZXcubWFya0N1cnNvciA9IHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgfHwgJHBvcy5tYXJrcygpO1xuICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICB2aWV3Lm1hcmtDdXJzb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmRDb21wb3NpdGlvbih2aWV3KTtcblxuICAgICAgaWYgKGdlY2tvICYmIHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IG9mZnNldCA8IDAgPyBub2RlLmxhc3RDaGlsZCA6IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICBpZiAoIWJlZm9yZSkgYnJlYWs7XG5cbiAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuXG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSBmdW5jdGlvbiAodmlldywgZXZlbnQpIHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgMjApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgZGVsYXkpIHtcbiAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gIGlmIChkZWxheSA+IC0xKSB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG4gIH0sIGRlbGF5KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgfVxuXG4gIHdoaWxlICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBldmVudC5pbml0RXZlbnQoXCJldmVudFwiLCB0cnVlLCB0cnVlKTtcbiAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cblxuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldykge1xuICB2YXIgZm9yY2VVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICBpZiAoYW5kcm9pZCAmJiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoaW5nU29vbiA+PSAwKSByZXR1cm47XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuXG4gIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyk7XG4gICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtlbHNlIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpIHJldHVybjtcbiAgdmFyIHdyYXAgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gIHZhciBzZWwgPSBnZXRTZWxlY3Rpb24oKSxcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gIHZpZXcuZG9tLmJsdXIoKTtcbiAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3JhcC5wYXJlbnROb2RlKSB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgdmlldy5mb2N1cygpO1xuICB9LCA1MCk7XG59XG5cbnZhciBicm9rZW5DbGlwYm9hcmRBUEkgPSBpZSAmJiBpZV92ZXJzaW9uIDwgMTUgfHwgaW9zICYmIHdlYmtpdF92ZXJzaW9uIDwgNjA0O1xuXG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gIGlmIChzZWwuZW1wdHkpIHJldHVybjtcbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcblxuICB2YXIgc2xpY2UgPSBzZWwuY29udGVudCgpLFxuICAgICAgX3NlcmlhbGl6ZUZvckNsaXBib2FyID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSxcbiAgICAgIGRvbSA9IF9zZXJpYWxpemVGb3JDbGlwYm9hci5kb20sXG4gICAgICB0ZXh0ID0gX3NlcmlhbGl6ZUZvckNsaXBib2FyLnRleHQ7XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgfVxuXG4gIGlmIChjdXQpIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5cbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSkgcmV0dXJuO1xuICB2YXIgcGxhaW5UZXh0ID0gdmlldy5pbnB1dC5zaGlmdEtleSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gIHZhciB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICBpZiAoIXBsYWluVGV4dCkgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gIHRhcmdldC5mb2N1cygpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKSB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgIGlmIChwbGFpblRleHQpIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBldmVudCk7ZWxzZSBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgZXZlbnQpO1xuICB9LCA1MCk7XG59XG5cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgZXZlbnQpIHtcbiAgdmFyIHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHZpZXcuaW5wdXQuc2hpZnRLZXksIHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tKTtcbiAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KTtcbiAgfSkpIHJldHVybiB0cnVlO1xuICBpZiAoIXNsaWNlKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzaW5nbGVOb2RlID0gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKTtcbiAgdmFyIHRyID0gc2luZ2xlTm9kZSA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgdmlldy5pbnB1dC5zaGlmdEtleSkgOiB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZWRpdEhhbmRsZXJzLnBhc3RlID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIGlmICh2aWV3LmNvbXBvc2luZyAmJiAhYW5kcm9pZCkgcmV0dXJuO1xuICB2YXIgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZXZlbnQpKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KTtcbn07XG5cbnZhciBEcmFnZ2luZyA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBEcmFnZ2luZyhzbGljZSwgbW92ZSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ2dpbmcpO1xuXG4gIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgdGhpcy5tb3ZlID0gbW92ZTtcbn0pO1xuXG52YXIgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIHZhciBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgaWYgKG1vdXNlRG93bikgbW91c2VEb3duLmRvbmUoKTtcbiAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpIHJldHVybjtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7ZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKSkpO1xuICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgIHZhciBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpKSk7XG4gIH1cblxuICB2YXIgc2xpY2UgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KCksXG4gICAgICBfc2VyaWFsaXplRm9yQ2xpcGJvYXIyID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSxcbiAgICAgIGRvbSA9IF9zZXJpYWxpemVGb3JDbGlwYm9hcjIuZG9tLFxuICAgICAgdGV4dCA9IF9zZXJpYWxpemVGb3JDbGlwYm9hcjIudGV4dDtcblxuICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGJyb2tlbkNsaXBib2FyZEFQSSA/IFwiVGV4dFwiIDogXCJ0ZXh0L2h0bWxcIiwgZG9tLmlubmVySFRNTCk7XG4gIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSkgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xufTtcblxuaGFuZGxlcnMuZHJhZ2VuZCA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIHZhciBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmlldy5kcmFnZ2luZyA9PSBkcmFnZ2luZykgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gIH0sIDUwKTtcbn07XG5cbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSBmdW5jdGlvbiAoXywgZSkge1xuICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuZWRpdEhhbmRsZXJzLmRyb3AgPSBmdW5jdGlvbiAodmlldywgX2V2ZW50KSB7XG4gIHZhciBldmVudCA9IF9ldmVudDtcbiAgdmFyIGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKSByZXR1cm47XG4gIHZhciBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgaWYgKCFldmVudFBvcykgcmV0dXJuO1xuICB2YXIgJG1vdXNlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShldmVudFBvcy5wb3MpO1xuICBpZiAoISRtb3VzZSkgcmV0dXJuO1xuICB2YXIgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcblxuICBpZiAoc2xpY2UpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICBzbGljZSA9IGYoc2xpY2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKGJyb2tlbkNsaXBib2FyZEFQSSA/IFwiVGV4dFwiIDogXCJ0ZXh0L3BsYWluXCIpLCBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGZhbHNlLCAkbW91c2UpO1xuICB9XG5cbiAgdmFyIG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuXG4gIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5LCBtb3ZlKTtcbiAgfSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc2xpY2UpIHJldHVybjtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIGluc2VydFBvcyA9IHNsaWNlID8gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICBpZiAoaW5zZXJ0UG9zID09IG51bGwpIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gIGlmIChtb3ZlKSB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgdmFyIHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gIHZhciBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gIHZhciBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gIGlmIChpc05vZGUpIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7ZWxzZSB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKSByZXR1cm47XG4gIHZhciAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcblxuICBpZiAoaXNOb2RlICYmIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJiAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbigkcG9zKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgdHIubWFwcGluZy5tYXBzW3RyLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXS5mb3JFYWNoKGZ1bmN0aW9uIChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pIHtcbiAgICAgIHJldHVybiBlbmQgPSBuZXdUbztcbiAgICB9KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gIH1cblxuICB2aWV3LmZvY3VzKCk7XG4gIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn07XG5cbmhhbmRsZXJzLmZvY3VzID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgdmlldy5mb2N1c2VkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5oYXNGb2N1cygpICYmICF2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodmlldy5kb21TZWxlY3Rpb24oKSkpIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDIwKTtcbiAgfVxufTtcblxuaGFuZGxlcnMuYmx1ciA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuXG4gIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICB9XG59O1xuXG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuXG4gIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIikge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgdmFyIGRvbUNoYW5nZUNvdW50ID0gdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudDtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KSByZXR1cm47XG4gICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpO1xuICAgICAgfSkpIHJldHVybjtcbiAgICAgIHZhciAkY3Vyc29yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgICAgIGlmICgkY3Vyc29yICYmICRjdXJzb3IucG9zID4gMCkgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyW1wiZGVsZXRlXCJdKCRjdXJzb3IucG9zIC0gMSwgJGN1cnNvci5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH0sIDUwKTtcbiAgfVxufTtcblxuZm9yICh2YXIgcHJvcCBpbiBlZGl0SGFuZGxlcnMpIHtcbiAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIF9wIGluIGIpIHtcbiAgICBpZiAoIShfcCBpbiBhKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBXaWRnZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpZGdldFR5cGUpO1xuXG4gICAgdGhpcy50b0RPTSA9IHRvRE9NO1xuICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2lkZ2V0VHlwZSwgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgdmFyIF9tYXBwaW5nJG1hcFJlc3VsdCA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgcG9zID0gX21hcHBpbmckbWFwUmVzdWx0LnBvcyxcbiAgICAgICAgICBkZWxldGVkID0gX21hcHBpbmckbWFwUmVzdWx0LmRlbGV0ZWQ7XG5cbiAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VHlwZSAmJiAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8IHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveShub2RlKSB7XG4gICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpIHRoaXMuc3BlYy5kZXN0cm95KG5vZGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXaWRnZXRUeXBlO1xufSgpO1xuXG52YXIgSW5saW5lVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5saW5lVHlwZShhdHRycywgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmVUeXBlKTtcblxuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbmxpbmVUeXBlLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgICAgIHZhciB0byA9IG1hcHBpbmcubWFwKHNwYW4udG8gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVFbmQgPyAxIDogLTEpIC0gb2Zmc2V0O1xuICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZChfLCBzcGFuKSB7XG4gICAgICByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50bztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IG90aGVyIGluc3RhbmNlb2YgSW5saW5lVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzKHNwYW4pIHtcbiAgICAgIHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmxpbmVUeXBlO1xufSgpO1xuXG52YXIgTm9kZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGVUeXBlKGF0dHJzLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVUeXBlKTtcblxuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlVHlwZSwgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIDEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLnRvICsgb2xkT2Zmc2V0LCAtMSk7XG4gICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICB2YXIgX25vZGUkY29udGVudCRmaW5kSW5kID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pLFxuICAgICAgICAgIGluZGV4ID0gX25vZGUkY29udGVudCRmaW5kSW5kLmluZGV4LFxuICAgICAgICAgIG9mZnNldCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5vZmZzZXQsXG4gICAgICAgICAgY2hpbGQ7XG5cbiAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVUeXBlO1xufSgpO1xuXG52YXIgRGVjb3JhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjb3JhdGlvbihmcm9tLCB0bywgdHlwZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNvcmF0aW9uKTtcblxuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVjb3JhdGlvbiwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5lcShvdGhlci50eXBlKSAmJiB0aGlzLmZyb20gKyBvZmZzZXQgPT0gb3RoZXIuZnJvbSAmJiB0aGlzLnRvICsgb2Zmc2V0ID09IG90aGVyLnRvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLm1hcChtYXBwaW5nLCB0aGlzLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwZWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5saW5lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ3aWRnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkZ2V0KHBvcywgdG9ET00sIHNwZWMpIHtcbiAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihwb3MsIHBvcywgbmV3IFdpZGdldFR5cGUodG9ET00sIHNwZWMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IElubGluZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgTm9kZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVjb3JhdGlvbjtcbn0oKTtcblxudmFyIG5vbmUgPSBbXSxcbiAgICBub1NwZWMgPSB7fTtcblxudmFyIERlY29yYXRpb25TZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY29yYXRpb25TZXQpO1xuXG4gICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBub25lO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY29yYXRpb25TZXQsIFt7XG4gICAga2V5OiBcImZpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZChzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZElubmVyKHN0YXJ0LCBlbmQsIHJlc3VsdCwgb2Zmc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gPD0gZW5kICYmIHNwYW4udG8gPj0gc3RhcnQgJiYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNwYW4uc3BlYykpKSByZXN1bHQucHVzaChzcGFuLmNvcHkoc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBfaTUgKz0gMykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltfaTVdIDwgZW5kICYmIHRoaXMuY2hpbGRyZW5bX2k1ICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgIHZhciBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5bX2k1XSArIDE7XG5cbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW19pNSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcsIGRvYywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBJbm5lcihtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5ld0xvY2FsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKSAobmV3TG9jYWwgfHwgKG5ld0xvY2FsID0gW10pKS5wdXNoKG1hcHBlZCk7ZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSkgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO2Vsc2UgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIG5vbmUpIDogZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgaWYgKCFkZWNvcmF0aW9ucy5sZW5ndGgpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkSW5kZXggPSAwO1xuICAgICAgZG9jLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSwgY2hpbGRPZmZzZXQpIHtcbiAgICAgICAgdmFyIGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCxcbiAgICAgICAgICAgIGZvdW5kO1xuICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKSByZXR1cm47XG4gICAgICAgIGlmICghY2hpbGRyZW4pIGNoaWxkcmVuID0gX3RoaXMxMC5jaGlsZHJlbi5zbGljZSgpO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpIHtcbiAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGRyZW5bY2hpbGRJbmRleF0gPT0gY2hpbGRPZmZzZXQpIGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXSA9IGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXS5hZGRJbm5lcihjaGlsZE5vZGUsIGZvdW5kLCBiYXNlT2Zmc2V0ICsgMSk7ZWxzZSBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpO1xuICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICB9KTtcbiAgICAgIHZhciBsb2NhbCA9IG1vdmVTcGFucyhjaGlsZEluZGV4ID8gd2l0aG91dE51bGxzKGRlY29yYXRpb25zKSA6IGRlY29yYXRpb25zLCAtb2Zmc2V0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpIGxvY2FsLnNwbGljZShpLS0sIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCwgY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgIGlmIChkZWNvcmF0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzID09IGVtcHR5KSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlubmVyKGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbixcbiAgICAgICAgICBsb2NhbCA9IHRoaXMubG9jYWw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuICAgICAgICB2YXIgZnJvbSA9IGNoaWxkcmVuW2ldICsgb2Zmc2V0LFxuICAgICAgICAgICAgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHNwYW47IGogPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZCkgY29udGludWU7XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKSBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcblxuICAgICAgICBpZiAocmVtb3ZlZCAhPSBlbXB0eSkge1xuICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IHJlbW92ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9jYWwubGVuZ3RoKSBmb3IgKHZhciBfaTYgPSAwLCBfc3BhbjsgX2k2IDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICBpZiAoX3NwYW4gPSBkZWNvcmF0aW9uc1tfaTZdKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbG9jYWwubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgICAgaWYgKGxvY2FsW19qMl0uZXEoX3NwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpIGxvY2FsID0gdGhpcy5sb2NhbC5zbGljZSgpO1xuICAgICAgICAgICAgICBsb2NhbC5zcGxpY2UoX2oyLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4gJiYgbG9jYWwgPT0gdGhpcy5sb2NhbCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yQ2hpbGQob2Zmc2V0LCBub2RlKSB7XG4gICAgICBpZiAodGhpcyA9PSBlbXB0eSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAobm9kZS5pc0xlYWYpIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgdmFyIGNoaWxkLCBsb2NhbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldCkgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQgKyAxLFxuICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgbm9kZS5jb250ZW50LnNpemU7XG5cbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHRoaXMubG9jYWwubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICB2YXIgZGVjID0gdGhpcy5sb2NhbFtfaTddO1xuXG4gICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiBkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHN0YXJ0LCBkZWMuZnJvbSkgLSBzdGFydCxcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbihlbmQsIGRlYy50bykgLSBzdGFydDtcbiAgICAgICAgICBpZiAoZnJvbSA8IHRvKSAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgIHZhciBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fCB0aGlzLmxvY2FsLmxlbmd0aCAhPSBvdGhlci5sb2NhbC5sZW5ndGggfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBfaTggKz0gMykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltfaThdICE9IG90aGVyLmNoaWxkcmVuW19pOF0gfHwgdGhpcy5jaGlsZHJlbltfaTggKyAxXSAhPSBvdGhlci5jaGlsZHJlbltfaTggKyAxXSB8fCAhdGhpcy5jaGlsZHJlbltfaTggKyAyXS5lcShvdGhlci5jaGlsZHJlbltfaTggKyAyXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvY2Fsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbHMobm9kZSkge1xuICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvY2Fsc0lubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzID09IGVtcHR5KSByZXR1cm4gbm9uZTtcbiAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQgfHwgIXRoaXMubG9jYWwuc29tZShJbmxpbmVUeXBlLmlzKSkgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkgcmVzdWx0LnB1c2godGhpcy5sb2NhbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICByZXR1cm4gZGVjb3JhdGlvbnMubGVuZ3RoID8gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBkb2MsIDAsIG5vU3BlYykgOiBlbXB0eTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVjb3JhdGlvblNldDtcbn0oKTtcblxuRGVjb3JhdGlvblNldC5lbXB0eSA9IG5ldyBEZWNvcmF0aW9uU2V0KFtdLCBbXSk7XG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xudmFyIGVtcHR5ID0gRGVjb3JhdGlvblNldC5lbXB0eTtcblxudmFyIERlY29yYXRpb25Hcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjb3JhdGlvbkdyb3VwKTtcblxuICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVjb3JhdGlvbkdyb3VwLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgdmFyIG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgIHJldHVybiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmlzTGVhZikgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICB2YXIgZm91bmQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBlbXB0eSkgY29udGludWU7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtlbHNlIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSB8fCBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxzKG5vZGUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc29ydGVkID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxvY2FscyA9IHRoaXMubWVtYmVyc1tpXS5sb2NhbHNJbm5lcihub2RlKTtcbiAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IGxvY2FscztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChsb2NhbHNbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gcmVtb3ZlT3ZlcmxhcChzb3J0ZWQgPyByZXN1bHQgOiByZXN1bHQuc29ydChieVBvcykpIDogbm9uZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20obWVtYmVycykge1xuICAgICAgc3dpdGNoIChtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIGVtcHR5O1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbWVtYmVyc1swXTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWNvcmF0aW9uR3JvdXA7XG59KCk7XG5cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcblxuICB2YXIgc2hpZnQgPSBmdW5jdGlvbiBzaGlmdChvbGRTdGFydCwgb2xkRW5kLCBuZXdTdGFydCwgbmV3RW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgdmFyIGVuZCA9IGNoaWxkcmVuW2kgKyAxXSxcbiAgICAgICAgICBkU2l6ZSA9IHZvaWQgMDtcbiAgICAgIGlmIChlbmQgPCAwIHx8IG9sZFN0YXJ0ID4gZW5kICsgb2xkT2Zmc2V0KSBjb250aW51ZTtcbiAgICAgIHZhciBzdGFydCA9IGNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0O1xuXG4gICAgICBpZiAob2xkRW5kID49IHN0YXJ0KSB7XG4gICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IG9sZFN0YXJ0IDw9IHN0YXJ0ID8gLTIgOiAtMTtcbiAgICAgIH0gZWxzZSBpZiAobmV3U3RhcnQgPj0gb2Zmc2V0ICYmIChkU2l6ZSA9IG5ld0VuZCAtIG5ld1N0YXJ0IC0gKG9sZEVuZCAtIG9sZFN0YXJ0KSkpIHtcbiAgICAgICAgY2hpbGRyZW5baV0gKz0gZFNpemU7XG4gICAgICAgIGNoaWxkcmVuW2kgKyAxXSArPSBkU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaChzaGlmdCk7XG4gIH1cblxuICB2YXIgbXVzdFJlYnVpbGQgPSBmYWxzZTtcblxuICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBjaGlsZHJlbi5sZW5ndGg7IF9pOSArPSAzKSB7XG4gICAgaWYgKGNoaWxkcmVuW19pOSArIDFdIDwgMCkge1xuICAgICAgaWYgKGNoaWxkcmVuW19pOSArIDFdID09IC0yKSB7XG4gICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW5bX2k5ICsgMV0gPSAtMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5bX2k5XSArIG9sZE9mZnNldCksXG4gICAgICAgICAgZnJvbUxvY2FsID0gZnJvbSAtIG9mZnNldDtcblxuICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW19pOSArIDFdICsgb2xkT2Zmc2V0LCAtMSksXG4gICAgICAgICAgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuXG4gICAgICB2YXIgX25vZGUkY29udGVudCRmaW5kSW5kMiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKSxcbiAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZDIuaW5kZXgsXG4gICAgICAgICAgY2hpbGRPZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQyLm9mZnNldDtcblxuICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGRPZmZzZXQgPT0gZnJvbUxvY2FsICYmIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplID09IHRvTG9jYWwpIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IGNoaWxkcmVuW19pOSArIDJdLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW19pOV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgY2hpbGRyZW5bX2k5XSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICBjaGlsZHJlbltfaTkgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgICAgY2hpbGRyZW5bX2k5ICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW5bX2k5ICsgMV0gPSAtMjtcbiAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICB2YXIgZGVjb3JhdGlvbnMgPSBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgdmFyIGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuXG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBjaGlsZHJlbi5sZW5ndGg7IF9pMTAgKz0gMykge1xuICAgICAgaWYgKGNoaWxkcmVuW19pMTAgKyAxXSA8IDApIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKF9pMTAsIDMpO1xuICAgICAgICBfaTEwIC09IDM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMSA9IDAsIGogPSAwOyBfaTExIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBfaTExICs9IDMpIHtcbiAgICAgIHZhciBfZnJvbTIgPSBidWlsdC5jaGlsZHJlbltfaTExXTtcblxuICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBfZnJvbTIpIHtcbiAgICAgICAgaiArPSAzO1xuICAgICAgfVxuXG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5bX2kxMV0sIGJ1aWx0LmNoaWxkcmVuW19pMTEgKyAxXSwgYnVpbHQuY2hpbGRyZW5bX2kxMSArIDJdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gbW92ZVNwYW5zKHNwYW5zLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aCkgcmV0dXJuIHNwYW5zO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0LmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFwcGVkID0gc2V0LmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICBpZiAobWFwcGVkKSBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7ZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSkgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBzZXQuY2hpbGRyZW4ubGVuZ3RoOyBfaTEyICs9IDMpIHtcbiAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5bX2kxMiArIDJdLCBzZXQuY2hpbGRyZW5bX2kxMl0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSkgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvcmF0aW9ucztcbn1cblxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gIGlmIChub2RlLmlzTGVhZikgcmV0dXJuIG51bGw7XG4gIHZhciBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLFxuICAgICAgZm91bmQgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiB3aXRob3V0TnVsbHMoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbCkgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW10sXG4gICAgICBoYXNOdWxscyA9IGZhbHNlO1xuICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkge1xuICAgIHZhciBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG5cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgIHZhciBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KSBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBsb2NhbHMgPSBtb3ZlU3BhbnMoaGFzTnVsbHMgPyB3aXRob3V0TnVsbHMoc3BhbnMpIDogc3BhbnMsIC1vZmZzZXQpLnNvcnQoYnlQb3MpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSkgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eTtcbn1cblxuZnVuY3Rpb24gYnlQb3MoYSwgYikge1xuICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwKHNwYW5zKSB7XG4gIHZhciB3b3JraW5nID0gc3BhbnM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBzcGFuID0gd29ya2luZ1tpXTtcbiAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pIGZvciAodmFyIGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuZXh0ID0gd29ya2luZ1tqXTtcblxuICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKSB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiArIDEsIG5leHQuY29weShzcGFuLnRvLCBuZXh0LnRvKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgIHdvcmtpbmdbaV0gPSBzcGFuLmNvcHkoc3Bhbi5mcm9tLCBuZXh0LmZyb20pO1xuICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JraW5nO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKSB7XG4gICAgaSsrO1xuICB9XG5cbiAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICB2YXIgZm91bmQgPSBbXTtcbiAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIGZvdW5kLnB1c2goRGVjb3JhdGlvblNldC5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIFt2aWV3LmN1cnNvcldyYXBwZXIuZGVjb10pKTtcbiAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxudmFyIG9ic2VydmVPcHRpb25zID0ge1xuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG52YXIgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuXG52YXIgU2VsZWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvblN0YXRlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb25TdGF0ZSk7XG5cbiAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uU3RhdGUsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoc2VsKSB7XG4gICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShzZWwpIHtcbiAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PSB0aGlzLmFuY2hvck5vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PSB0aGlzLmFuY2hvck9mZnNldCAmJiBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb25TdGF0ZTtcbn0oKTtcblxudmFyIERPTU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBET01PYnNlcnZlcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NT2JzZXJ2ZXIpO1xuXG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uU3RhdGUoKTtcbiAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpczExLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fCBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfSkpIF90aGlzMTEuZmx1c2hTb29uKCk7ZWxzZSBfdGhpczExLmZsdXNoKCk7XG4gICAgfSk7XG5cbiAgICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICAgIHRoaXMub25DaGFyRGF0YSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMTEucXVldWUucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldCxcbiAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICBvbGRWYWx1ZTogZS5wcmV2VmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMxMS5mbHVzaFNvb24oKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01PYnNlcnZlciwgW3tcbiAgICBrZXk6IFwiZmx1c2hTb29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoU29vbigpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uIDwgMCkgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTIuZmx1c2hpbmdTb29uID0gLTE7XG5cbiAgICAgICAgX3RoaXMxMi5mbHVzaCgpO1xuICAgICAgfSwgMjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZUZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmNlRmx1c2goKSB7XG4gICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSkgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICB0aGlzLmNvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICB2YXIgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblxuICAgICAgICBpZiAodGFrZS5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0YWtlW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMxMy5mbHVzaCgpO1xuICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKSB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1cHByZXNzU2VsZWN0aW9uVXBkYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxNC5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH0sIDUwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25TZWxlY3Rpb25DaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcykgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG5cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgIHZhciBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKSByZXR1cm4gdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldCh0aGlzLnZpZXcuZG9tU2VsZWN0aW9uKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZ25vcmVTZWxlY3Rpb25DaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgaWYgKHNlbC5yYW5nZUNvdW50ID09IDApIHJldHVybiB0cnVlO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgdmFyIGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjb250YWluZXIpO1xuXG4gICAgICBpZiAoZGVzYyAmJiBkZXNjLmlnbm9yZU11dGF0aW9uKHtcbiAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICBpZiAoIXRoaXMudmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHJldHVybjtcbiAgICAgIHZhciBtdXRhdGlvbnMgPSB0aGlzLm9ic2VydmVyID8gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpIDogW107XG5cbiAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBtdXRhdGlvbnMgPSB0aGlzLnF1ZXVlLmNvbmNhdChtdXRhdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgICB2YXIgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpICYmICF0aGlzLmlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpO1xuICAgICAgdmFyIGZyb20gPSAtMSxcbiAgICAgICAgICB0byA9IC0xLFxuICAgICAgICAgIHR5cGVPdmVyID0gZmFsc2UsXG4gICAgICAgICAgYWRkZWQgPSBbXTtcblxuICAgICAgaWYgKHRoaXMudmlldy5lZGl0YWJsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgIHRvID0gdG8gPCAwID8gcmVzdWx0LnRvIDogTWF0aC5tYXgocmVzdWx0LnRvLCB0byk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKSB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnZWNrbyAmJiBhZGRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBicnMgPSBhZGRlZC5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5ub2RlTmFtZSA9PSBcIkJSXCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChicnMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICB2YXIgYSA9IGJyc1swXSxcbiAgICAgICAgICAgICAgYiA9IGJyc1sxXTtcbiAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSkgYi5yZW1vdmUoKTtlbHNlIGEucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiAtMSB8fCBuZXdTZWwpIHtcbiAgICAgICAgaWYgKGZyb20gPiAtMSkge1xuICAgICAgICAgIHRoaXMudmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgY2hlY2tDU1ModGhpcy52aWV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICBpZiAodGhpcy52aWV3LmRvY1ZpZXcgJiYgdGhpcy52aWV3LmRvY1ZpZXcuZGlydHkpIHRoaXMudmlldy51cGRhdGVTdGF0ZSh0aGlzLnZpZXcuc3RhdGUpO2Vsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSkgc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KTtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3Rlck11dGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb24obXV0LCBhZGRlZCkge1xuICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHwgbXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJzdHlsZVwiICYmICFtdXQub2xkVmFsdWUgJiYgIW11dC50YXJnZXQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWRkZWQucHVzaChtdXQuYWRkZWROb2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NICYmIGRlc2MuY29udGVudERPTSAhPSBkZXNjLmRvbSAmJiAhZGVzYy5jb250ZW50RE9NLmNvbnRhaW5zKG11dC50YXJnZXQpKSByZXR1cm4ge1xuICAgICAgICAgIGZyb206IGRlc2MucG9zQmVmb3JlLFxuICAgICAgICAgIHRvOiBkZXNjLnBvc0FmdGVyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmV2ID0gbXV0LnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICAgIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IF9pMTMrKykge1xuICAgICAgICAgICAgdmFyIF9tdXQkYWRkZWROb2RlcyRfaSA9IG11dC5hZGRlZE5vZGVzW19pMTNdLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2libGluZyA9IF9tdXQkYWRkZWROb2RlcyRfaS5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBfbXV0JGFkZGVkTm9kZXMkX2kubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMCkgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMCkgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldCA/IGRvbUluZGV4KHByZXYpICsgMSA6IDA7XG4gICAgICAgIHZhciBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICB2YXIgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0ID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgdG8gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCB0b09mZnNldCwgMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICB0bzogdG9cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlcixcbiAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCArIGRlc2MuYm9yZGVyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICB0eXBlT3ZlcjogbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTU9ic2VydmVyO1xufSgpO1xuXG52YXIgY3NzQ2hlY2tlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjaGVja0NTUyh2aWV3KSB7XG4gIGlmIChjc3NDaGVja2VkKSByZXR1cm47XG4gIGNzc0NoZWNrZWQgPSB0cnVlO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkud2hpdGVTcGFjZSA9PSBcIm5vcm1hbFwiKSBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgdmFyIF92aWV3JGRvY1ZpZXckcGFyc2VSYSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pLFxuICAgICAgcGFyZW50ID0gX3ZpZXckZG9jVmlldyRwYXJzZVJhLm5vZGUsXG4gICAgICBmcm9tT2Zmc2V0ID0gX3ZpZXckZG9jVmlldyRwYXJzZVJhLmZyb21PZmZzZXQsXG4gICAgICB0b09mZnNldCA9IF92aWV3JGRvY1ZpZXckcGFyc2VSYS50b09mZnNldCxcbiAgICAgIGZyb20gPSBfdmlldyRkb2NWaWV3JHBhcnNlUmEuZnJvbSxcbiAgICAgIHRvID0gX3ZpZXckZG9jVmlldyRwYXJzZVJhLnRvO1xuXG4gIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICB2YXIgZmluZDtcbiAgdmFyIGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuXG4gIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICBmaW5kID0gW3tcbiAgICAgIG5vZGU6IGFuY2hvcixcbiAgICAgIG9mZnNldDogZG9tU2VsLmFuY2hvck9mZnNldFxuICAgIH1dO1xuICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIGZpbmQucHVzaCh7XG4gICAgICBub2RlOiBkb21TZWwuZm9jdXNOb2RlLFxuICAgICAgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXRcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjaHJvbWUgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgIGZvciAodmFyIG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSxcbiAgICAgICAgICBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuXG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRlc2MpIHtcbiAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKSBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgdmFyIHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgcHJvc2VtaXJyb3JNb2RlbC5ET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gIHZhciAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG4gIHZhciBzZWwgPSBudWxsLFxuICAgICAgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICB0b3BNYXRjaDogJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLFxuICAgIHRvcE9wZW46IHRydWUsXG4gICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICB0bzogdG9PZmZzZXQsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICBydWxlRnJvbU5vZGU6IHJ1bGVGcm9tTm9kZSxcbiAgICBjb250ZXh0OiAkZnJvbVxuICB9KTtcblxuICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgdmFyIF9hbmNob3IgPSBmaW5kWzBdLnBvcyxcbiAgICAgICAgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgaWYgKGhlYWQgPT0gbnVsbCkgaGVhZCA9IF9hbmNob3I7XG4gICAgc2VsID0ge1xuICAgICAgYW5jaG9yOiBfYW5jaG9yICsgZnJvbSxcbiAgICAgIGhlYWQ6IGhlYWQgKyBmcm9tXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZG9jOiBkb2MsXG4gICAgc2VsOiBzZWwsXG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogdG9cbiAgfTtcbn1cblxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICB2YXIgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuXG4gIGlmIChkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MucGFyc2VSdWxlKCk7XG4gIH0gZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgIGlmIChzYWZhcmkgJiYgL14odWx8b2wpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICB2YXIgc2tpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBza2lwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBza2lwOiBza2lwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9tLnBhcmVudE5vZGUubGFzdENoaWxkID09IGRvbSB8fCBzYWZhcmkgJiYgL14odHJ8dGFibGUpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZ25vcmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlnbm9yZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkTm9kZXMpIHtcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgdmFyIG9yaWdpbiA9IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTAgPyB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gOiBudWxsO1xuICAgIHZhciBuZXdTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbik7XG5cbiAgICBpZiAobmV3U2VsICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShuZXdTZWwpKSB7XG4gICAgICB2YXIgX3RyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcblxuICAgICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIikgX3RyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO2Vsc2UgaWYgKG9yaWdpbiA9PSBcImtleVwiKSBfdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIHZpZXcuZGlzcGF0Y2goX3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gIHZhciBzaGFyZWQgPSAkYmVmb3JlLnNoYXJlZERlcHRoKHRvKTtcbiAgZnJvbSA9ICRiZWZvcmUuYmVmb3JlKHNoYXJlZCArIDEpO1xuICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIHZhciBwYXJzZSA9IHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tLCB0byk7XG5cbiAgaWYgKGNocm9tZSAmJiB2aWV3LmN1cnNvcldyYXBwZXIgJiYgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gdmlldy5jdXJzb3JXcmFwcGVyLmRlY28uZnJvbSkge1xuICAgIHZhciB0ZXh0ID0gdmlldy5jdXJzb3JXcmFwcGVyLmRlY28udHlwZS50b0RPTS5uZXh0U2libGluZztcbiAgICB2YXIgc2l6ZSA9IHRleHQgJiYgdGV4dC5ub2RlVmFsdWUgPyB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGggOiAxO1xuICAgIHBhcnNlLnNlbCA9IHtcbiAgICAgIGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsXG4gICAgICBoZWFkOiBwYXJzZS5zZWwuYW5jaG9yICsgc2l6ZVxuICAgIH07XG4gIH1cblxuICB2YXIgZG9jID0gdmlldy5zdGF0ZS5kb2MsXG4gICAgICBjb21wYXJlID0gZG9jLnNsaWNlKHBhcnNlLmZyb20sIHBhcnNlLnRvKTtcbiAgdmFyIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcblxuICBpZiAodmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUpIHtcbiAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgfSBlbHNlIHtcbiAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gIH1cblxuICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgdmFyIGNoYW5nZSA9IGZpbmREaWZmKGNvbXBhcmUuY29udGVudCwgcGFyc2UuZG9jLmNvbnRlbnQsIHBhcnNlLmZyb20sIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSk7XG5cbiAgaWYgKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1IHx8IGFuZHJvaWQpICYmIGFkZGVkTm9kZXMuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIjtcbiAgfSkgJiYgKCFjaGFuZ2UgfHwgY2hhbmdlLmVuZEEgPj0gY2hhbmdlLmVuZEIpICYmIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpO1xuICB9KSkge1xuICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWNoYW5nZSkge1xuICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiYgIXZpZXcuY29tcG9zaW5nICYmICEocGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgIT0gcGFyc2Uuc2VsLmhlYWQpKSB7XG4gICAgICBjaGFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBzZWwuZnJvbSxcbiAgICAgICAgZW5kQTogc2VsLnRvLFxuICAgICAgICBlbmRCOiBzZWwudG9cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgdmFyIF9zZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuZG9jLCBwYXJzZS5zZWwpO1xuXG4gICAgICAgIGlmIChfc2VsICYmICFfc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihfc2VsKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50Kys7XG5cbiAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pIHtcbiAgICBpZiAoY2hhbmdlLnN0YXJ0ID4gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAmJiBjaGFuZ2Uuc3RhcnQgPD0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDIgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPD0gcGFyc2UudG8pIHtcbiAgICAgIGNoYW5nZS5lbmRCICs9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEE7XG4gICAgICBjaGFuZ2UuZW5kQSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydCArIDEgJiYgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiYgcGFyc2UuZG9jLnRleHRCZXR3ZWVuKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gLSAxLCBjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tICsgMSkgPT0gXCIgXFx4QTBcIikge1xuICAgIGNoYW5nZS5zdGFydC0tO1xuICAgIGNoYW5nZS5lbmRBLS07XG4gICAgY2hhbmdlLmVuZEItLTtcbiAgfVxuXG4gIHZhciAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgdmFyICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICB2YXIgJGZyb21BID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KTtcbiAgdmFyIGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gIHZhciBuZXh0U2VsO1xuXG4gIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJiAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5ub2RlTmFtZSA9PSBcIkRJVlwiIHx8IG4ubm9kZU5hbWUgPT0gXCJQXCI7XG4gIH0pKSB8fCAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnBvcyA8IHBhcnNlLmRvYy5jb250ZW50LnNpemUgJiYgKG5leHRTZWwgPSBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSAmJiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTtcbiAgfSkpIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA+IGNoYW5nZS5zdGFydCAmJiBsb29rc0xpa2VKb2luKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiYgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSk7XG4gIH0pKSB7XG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKSB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuXG4gIGlmIChhbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHBhcnNlLnNlbC5oZWFkICYmIHBhcnNlLnNlbC5oZWFkID09IGNoYW5nZS5lbmRBKSB7XG4gICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTtcbiAgICAgIH0pO1xuICAgIH0sIDIwKTtcbiAgfVxuXG4gIHZhciBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsXG4gICAgICBjaFRvID0gY2hhbmdlLmVuZEE7XG4gIHZhciB0ciwgc3RvcmVkTWFya3MsIG1hcmtDaGFuZ2U7XG5cbiAgaWYgKGlubGluZUNoYW5nZSkge1xuICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykge1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgICB9XG5cbiAgICAgIHRyID0gdmlldy5zdGF0ZS50cltcImRlbGV0ZVwiXShjaEZyb20sIGNoVG8pO1xuICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJiAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpIHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO2Vsc2UgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgfSBlbHNlIGlmICgkZnJvbS5wYXJlbnQuY2hpbGQoJGZyb20uaW5kZXgoKSkuaXNUZXh0ICYmICRmcm9tLmluZGV4KCkgPT0gJHRvLmluZGV4KCkgLSAoJHRvLnRleHRPZmZzZXQgPyAwIDogMSkpIHtcbiAgICAgIHZhciBfdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuXG4gICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih2aWV3LCBjaEZyb20sIGNoVG8sIF90ZXh0KTtcbiAgICAgIH0pKSByZXR1cm47XG4gICAgICB0ciA9IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dChfdGV4dCwgY2hGcm9tLCBjaFRvKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRyKSB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcblxuICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgdmFyIF9zZWwyID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG5cbiAgICBpZiAoX3NlbDIgJiYgIShjaHJvbWUgJiYgYW5kcm9pZCAmJiB2aWV3LmNvbXBvc2luZyAmJiBfc2VsMi5lbXB0eSAmJiAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJiAoX3NlbDIuaGVhZCA9PSBjaEZyb20gfHwgX3NlbDIuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8IGllICYmIF9zZWwyLmVtcHR5ICYmIF9zZWwyLmhlYWQgPT0gY2hGcm9tKSkgdHIuc2V0U2VsZWN0aW9uKF9zZWwyKTtcbiAgfVxuXG4gIGlmIChzdG9yZWRNYXJrcykgdHIuZW5zdXJlTWFya3Moc3RvcmVkTWFya3MpO1xuICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gIGlmIChNYXRoLm1heChwYXJzZWRTZWwuYW5jaG9yLCBwYXJzZWRTZWwuaGVhZCkgPiBkb2MuY29udGVudC5zaXplKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG5cbmZ1bmN0aW9uIGlzTWFya0NoYW5nZShjdXIsIHByZXYpIHtcbiAgdmFyIGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsXG4gICAgICBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gIHZhciBhZGRlZCA9IGN1ck1hcmtzLFxuICAgICAgcmVtb3ZlZCA9IHByZXZNYXJrcyxcbiAgICAgIHR5cGUsXG4gICAgICBtYXJrLFxuICAgICAgdXBkYXRlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gIH1cblxuICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IGN1ck1hcmtzLmxlbmd0aDsgX2kxNCsrKSB7XG4gICAgcmVtb3ZlZCA9IGN1ck1hcmtzW19pMTRdLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgIG1hcmsgPSBhZGRlZFswXTtcbiAgICB0eXBlID0gXCJhZGRcIjtcblxuICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgIHR5cGUgPSBcInJlbW92ZVwiO1xuXG4gICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHVwZGF0ZWQgPSBbXTtcblxuICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IHByZXYuY2hpbGRDb3VudDsgX2kxNSsrKSB7XG4gICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKF9pMTUpKSk7XG4gIH1cblxuICBpZiAocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpIHJldHVybiB7XG4gICAgbWFyazogbWFyayxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrIHx8IGVuZCAtIHN0YXJ0IDw9ICRuZXdFbmQucG9zIC0gJG5ld1N0YXJ0LnBvcyB8fCBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcykgcmV0dXJuIGZhbHNlO1xuICB2YXIgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8IHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cblxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgdmFyIGRlcHRoID0gJHBvcy5kZXB0aCxcbiAgICAgIGVuZCA9IGZyb21FbmQgPyAkcG9zLmVuZCgpIDogJHBvcy5wb3M7XG5cbiAgd2hpbGUgKGRlcHRoID4gMCAmJiAoZnJvbUVuZCB8fCAkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRwb3Mubm9kZShkZXB0aCkuY2hpbGRDb3VudCkpIHtcbiAgICBkZXB0aC0tO1xuICAgIGVuZCsrO1xuICAgIGZyb21FbmQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChtYXlPcGVuKSB7XG4gICAgdmFyIG5leHQgPSAkcG9zLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJHBvcy5pbmRleEFmdGVyKGRlcHRoKSk7XG5cbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICBlbmQrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwb3MsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICB2YXIgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgaWYgKHN0YXJ0ID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBfYSRmaW5kRGlmZkVuZCA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpLFxuICAgICAgZW5kQSA9IF9hJGZpbmREaWZmRW5kLmEsXG4gICAgICBlbmRCID0gX2EkZmluZERpZmZFbmQuYjtcblxuICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgdmFyIGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gIH1cblxuICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgIHZhciBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICBlbmRBID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgdmFyIF9tb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuXG4gICAgc3RhcnQgLT0gX21vdmU7XG4gICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICBlbmRCID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmRBOiBlbmRBLFxuICAgIGVuZEI6IGVuZEJcbiAgfTtcbn1cblxudmFyIF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkO1xudmFyIF9fcGFyc2VGcm9tQ2xpcGJvYXJkID0gcGFyc2VGcm9tQ2xpcGJvYXJkO1xudmFyIF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcblxudmFyIEVkaXRvclZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVkaXRvclZpZXcocGxhY2UsIHByb3BzKSB7XG4gICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvclZpZXcpO1xuXG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlKCk7XG4gICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgIHRoaXMuZGlyZWN0UGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kb20gPSBwbGFjZSAmJiBwbGFjZS5tb3VudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgaWYgKHBsYWNlKSB7XG4gICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKSBwbGFjZSh0aGlzLmRvbSk7ZWxzZSBpZiAocGxhY2UubW91bnQpIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgdGhpcy5ub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgZnVuY3Rpb24gKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpIHtcbiAgICAgIHJldHVybiByZWFkRE9NQ2hhbmdlKF90aGlzMTUsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVkaXRvclZpZXcsIFt7XG4gICAga2V5OiBcImNvbXBvc2luZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9wc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXYpIHtcbiAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgIHByb3BzLnBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgIHZhciB1cGRhdGVkID0ge307XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgZm9yICh2YXIgX25hbWUyIGluIHByb3BzKSB7XG4gICAgICAgIHVwZGF0ZWRbX25hbWUyXSA9IHByb3BzW19uYW1lMl07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShzdGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLnN0YXRlLnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVN0YXRlSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgcmVjb25maWd1cmVkKSB7XG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICByZWRyYXcgPSBmYWxzZSxcbiAgICAgICAgICB1cGRhdGVTZWwgPSBmYWxzZTtcblxuICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgaWYgKHJlY29uZmlndXJlZCkge1xuICAgICAgICB2YXIgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG5cbiAgICAgICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IG5vZGVWaWV3cztcbiAgICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgdmFyIGlubmVyRGVjbyA9IHZpZXdEZWNvcmF0aW9ucyh0aGlzKSxcbiAgICAgICAgICBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgIHZhciBzY3JvbGwgPSByZWNvbmZpZ3VyZWQgPyBcInJlc2V0XCIgOiBzdGF0ZS5zY3JvbGxUb1NlbGVjdGlvbiA+IHByZXYuc2Nyb2xsVG9TZWxlY3Rpb24gPyBcInRvIHNlbGVjdGlvblwiIDogXCJwcmVzZXJ2ZVwiO1xuICAgICAgdmFyIHVwZGF0ZURvYyA9IHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3Lm1hdGNoZXNOb2RlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSkgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgIHZhciBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuXG4gICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2YXIgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmICFwcmV2LnNlbGVjdGlvbi5lbXB0eSAmJiAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHByZXYuc2VsZWN0aW9uLCBzdGF0ZS5zZWxlY3Rpb24pO1xuXG4gICAgICAgIGlmICh1cGRhdGVEb2MpIHtcbiAgICAgICAgICB2YXIgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gdGhpcy50cmFja1dyaXRlcyA9IHRoaXMuZG9tU2VsZWN0aW9uKCkuZm9jdXNOb2RlIDogbnVsbDtcblxuICAgICAgICAgIGlmIChyZWRyYXcgfHwgIXRoaXMuZG9jVmlldy51cGRhdGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28oW10pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKSBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VTZWxVcGRhdGUgfHwgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb24oKSkgJiYgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW5jTm9kZVNlbGVjdGlvbih0aGlzLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG5cbiAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgIHZhciBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uKCkuZm9jdXNOb2RlO1xuICAgICAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGYoX3RoaXMxNik7XG4gICAgICAgIH0pKSA7ZWxzZSBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyhzdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKSBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydERPTSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lQbHVnaW5WaWV3c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICB2YXIgdmlldztcblxuICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKSB7XG4gICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpIHZpZXcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQbHVnaW5WaWV3c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldykgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kxNiA9IDA7IF9pMTYgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBfaTE2KyspIHtcbiAgICAgICAgICB2YXIgX3BsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tfaTE2XTtcbiAgICAgICAgICBpZiAoX3BsdWdpbi5zcGVjLnZpZXcpIHRoaXMucGx1Z2luVmlld3MucHVzaChfcGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgdGhpcy5wbHVnaW5WaWV3cy5sZW5ndGg7IF9pMTcrKykge1xuICAgICAgICAgIHZhciBwbHVnaW5WaWV3ID0gdGhpcy5wbHVnaW5WaWV3c1tfaTE3XTtcbiAgICAgICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpIHBsdWdpblZpZXcudXBkYXRlKHRoaXMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic29tZVByb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLFxuICAgICAgICAgIHZhbHVlO1xuICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChfcHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKF9wcm9wKSA6IF9wcm9wKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgIGlmIChwbHVnaW5zKSBmb3IgKHZhciBfaTE4ID0gMDsgX2kxOCA8IHBsdWdpbnMubGVuZ3RoOyBfaTE4KyspIHtcbiAgICAgICAgdmFyIF9wcm9wMiA9IHBsdWdpbnNbX2kxOF0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoX3Byb3AyICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYoX3Byb3AyKSA6IF9wcm9wMikpIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5lZGl0YWJsZSkgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuZG9tKTtcbiAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb290XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG5cbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9yb290O1xuXG4gICAgICBpZiAoY2FjaGVkID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChzZWFyY2gpIHtcbiAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgc2VhcmNoLm5vZGVUeXBlID09IDExICYmIHNlYXJjaC5ob3N0KSB7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaC5nZXRTZWxlY3Rpb24pIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IF90aGlzMTcuX3Jvb3QgPSBzZWFyY2hcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3JldDMgPSBfbG9vcDQoc2VhcmNoKTtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKF9yZXQzKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQzLnY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zQXRDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICByZXR1cm4gX3Bvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvb3Jkc0F0UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHBvcykge1xuICAgICAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gX2Nvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUF0UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbUF0UG9zKHBvcykge1xuICAgICAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZURPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlRE9NKHBvcykge1xuICAgICAgdmFyIGRlc2MgPSB0aGlzLmRvY1ZpZXcuZGVzY0F0KHBvcyk7XG4gICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0F0RE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0F0RE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGJpYXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IC0xO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICBpZiAocG9zID09IG51bGwpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mVGV4dGJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrKGRpciwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBfZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG5cbiAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRGVzdHJveWVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2NWaWV3ID09IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgcmV0dXJuIF9kaXNwYXRjaEV2ZW50KHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcGF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2godHIpIHtcbiAgICAgIHZhciBkaXNwYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5fcHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbjtcbiAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKSBkaXNwYXRjaFRyYW5zYWN0aW9uLmNhbGwodGhpcywgdHIpO2Vsc2UgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb21TZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGl0b3JWaWV3O1xufSgpO1xuXG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGF0dHJzW1wiY2xhc3NcIl0gPSBcIlByb3NlTWlycm9yXCI7XG4gIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAodmFsdWUpIGZvciAodmFyIGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIikgYXR0cnNbXCJjbGFzc1wiXSArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuXG4gICAgICBpZiAoYXR0ciA9PSBcInN0eWxlXCIpIHtcbiAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgIH0gZWxzZSBpZiAoIWF0dHJzW2F0dHJdICYmIGF0dHIgIT0gXCJjb250ZW50ZWRpdGFibGVcIiAmJiBhdHRyICE9IFwibm9kZU5hbWVcIikgYXR0cnNbYXR0cl0gPSBTdHJpbmcodmFsdWVbYXR0cl0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgZG9tLnNldEF0dHJpYnV0ZShcImFsdFwiLCBcIlwiKTtcbiAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7XG4gICAgICBkb206IGRvbSxcbiAgICAgIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIGRvbSwge1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3JcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlKHZpZXcuc3RhdGUpID09PSBmYWxzZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgdmFyIGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKTtcbn1cblxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBhZGQob2JqKSB7XG4gICAgZm9yICh2YXIgX3Byb3AzIGluIG9iaikge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBfcHJvcDMpKSByZXN1bHRbX3Byb3AzXSA9IG9ialtfcHJvcDNdO1xuICAgIH1cbiAgfVxuXG4gIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgYWRkKTtcbiAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgdmFyIG5BID0gMCxcbiAgICAgIG5CID0gMDtcblxuICBmb3IgKHZhciBfcHJvcDQgaW4gYSkge1xuICAgIGlmIChhW19wcm9wNF0gIT0gYltfcHJvcDRdKSByZXR1cm4gdHJ1ZTtcbiAgICBuQSsrO1xuICB9XG5cbiAgZm9yICh2YXIgXyBpbiBiKSB7XG4gICAgbkIrKztcbiAgfVxuXG4gIHJldHVybiBuQSAhPSBuQjtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydHMuRGVjb3JhdGlvbiA9IERlY29yYXRpb247XG5leHBvcnRzLkRlY29yYXRpb25TZXQgPSBEZWNvcmF0aW9uU2V0O1xuZXhwb3J0cy5FZGl0b3JWaWV3ID0gRWRpdG9yVmlldztcbmV4cG9ydHMuX19lbmRDb21wb3NpdGlvbiA9IF9fZW5kQ29tcG9zaXRpb247XG5leHBvcnRzLl9fcGFyc2VGcm9tQ2xpcGJvYXJkID0gX19wYXJzZUZyb21DbGlwYm9hcmQ7XG5leHBvcnRzLl9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkID0gX19zZXJpYWxpemVGb3JDbGlwYm9hcmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIixcbiAgMjI5OiBcInFcIlxufTtcblxudmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiLFxuICAyMjk6IFwiUVwiXG59O1xuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgc2FmYXJpID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbnZhciBnZWNrbyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvR2Vja29cXC9cXGQrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIGJyb2tlbk1vZGlmaWVyTmFtZXMgPSBjaHJvbWUgJiYgKG1hYyB8fCArY2hyb21lWzFdIDwgNTcpIHx8IGdlY2tvICYmIG1hYztcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSk7XG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpO1xuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKTtcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXTtcblxuZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBEb24ndCB0cnVzdCBldmVudC5rZXkgaW4gQ2hyb21lIHdoZW4gdGhlcmUgYXJlIG1vZGlmaWVycyB1bnRpbFxuICAvLyB0aGV5IGZpeCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzM4MzhcbiAgdmFyIGlnbm9yZUtleSA9IGJyb2tlbk1vZGlmaWVyTmFtZXMgJiYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHx8XG4gICAgKHNhZmFyaSB8fCBpZSkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMTtcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiO1xuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiO1xuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIjtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiO1xuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIjtcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCI7XG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIjtcbiAgcmV0dXJuIG5hbWVcbn1cblxuZXhwb3J0cy5iYXNlID0gYmFzZTtcbmV4cG9ydHMua2V5TmFtZSA9IGtleU5hbWU7XG5leHBvcnRzLnNoaWZ0ID0gc2hpZnQ7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyAqL1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tICdwcm9zZW1pcnJvci1zY2hlbWEtYmFzaWMnO1xuaW1wb3J0IHsgZXhhbXBsZVNldHVwIH0gZnJvbSAncHJvc2VtaXJyb3ItZXhhbXBsZS1zZXR1cCc7XG5pbXBvcnQgeyBhdXRvY29tcGxldGUsIE9wdGlvbnMgfSBmcm9tICcuLi9zcmMnO1xuaW1wb3J0IHsgcmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcic7XG5cbmNvbnN0IGVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNlZGl0b3InKSBhcyBIVE1MRGl2RWxlbWVudDtcbmNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29udGVudCcpIGFzIEhUTUxEaXZFbGVtZW50O1xuXG5jb25zdCBvcHRpb25zOiBPcHRpb25zID0ge1xuICByZWR1Y2VyLFxuICB0cmlnZ2VyczogW1xuICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCBtYWtlIHRoZSBgI2AgYW5kIGBAYCBlYXNpZXIgdG8gY3JlYXRlXG4gICAgeyBuYW1lOiAnaGFzaHRhZycsIHRyaWdnZXI6IC8oIykkLyB9LFxuICAgIHsgbmFtZTogJ21lbnRpb24nLCB0cmlnZ2VyOiAvKEApJC8gfSxcbiAgICB7IG5hbWU6ICdlbW9qaScsIHRyaWdnZXI6ICc6JyB9LFxuICAgIHsgbmFtZTogJ2xpbmsnLCB0cmlnZ2VyOiAnW1snLCBjYW5jZWxPbkZpcnN0U3BhY2U6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnamluamEnLCB0cmlnZ2VyOiAne3snLCBjYW5jZWxPbkZpcnN0U3BhY2U6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnY29tbWFuZCcsIHRyaWdnZXI6ICcvJywgZGVjb3JhdGlvbkF0dHJzOiB7IGNsYXNzOiAnY29tbWFuZCcgfSB9LFxuICAgIHsgbmFtZTogJ3ZhcmlhYmxlJywgdHJpZ2dlcjogLygoPzpeW2EtekEtWjAtOV9dKylcXHM/PSkkLywgY2FuY2VsT25GaXJzdFNwYWNlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ2NvZGUnLCB0cmlnZ2VyOiAvKCg/OlthLXpBLVowLTlfXSspXFwuKSQvIH0sXG4gIF0sXG59O1xuXG4od2luZG93IGFzIGFueSkudmlldyA9IG5ldyBFZGl0b3JWaWV3KGVkaXRvciwge1xuICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICBkb2M6IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSkucGFyc2UoY29udGVudCksXG4gICAgcGx1Z2luczogWy4uLmF1dG9jb21wbGV0ZShvcHRpb25zKSwgLi4uZXhhbXBsZVNldHVwKHsgc2NoZW1hLCBtZW51QmFyOiBmYWxzZSB9KV0sXG4gIH0pLFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=